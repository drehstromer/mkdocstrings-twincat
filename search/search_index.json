{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mkdocstrings-twincat","text":"<p>A Twincat handler for mkdocstrings.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install mkdocstrings-twincat\n</code></pre> <p>This handler is using pytwincatparser to parse Twincatfiles. Currently supported are:</p> <ul> <li>.plcproj</li> <li>.tcio</li> <li>.tcpou</li> <li>.tcgvl</li> <li>.tcdut</li> </ul> <p>The handler can load recursivly all objects. You just have to add the .plcproj file, and it generates the documentation for all Function Blocks etc.</p>"},{"location":"#demo","title":"Demo","text":"<p>This is the famous TcUnit TwinCAT unit testing framework. Parsed and documentation generated by this handler. The documentation part is not quit right. You have to follow some requirements, so that the comments are parsed correctly.</p>"},{"location":"#used-packages","title":"Used packages","text":"<ul> <li>mkdocstrings</li> <li>mkdocstrings-python (heavily as inspiration. really great code!)</li> <li>pytwincatparser</li> </ul>"},{"location":"#be-aware","title":"Be aware","text":"<p>I am a plc programmer. I usually dont code in python. if you find bugs, flaws, mistakes or if you have an idea how to improve or make a new feature, do not hesitate to contact me!</p>"},{"location":"reference/api/","title":"API reference","text":""},{"location":"reference/api/#mkdocstrings_handlers.twincat","title":"twincat","text":"<p>Twincat handler for mkdocstrings.</p> <p>Classes:</p> <ul> <li> <code>TwincatConfig</code>           \u2013            <p>Twincat handler configuration.</p> </li> <li> <code>TwincatHandler</code>           \u2013            <p>The Twincat handler class.</p> </li> <li> <code>TwincatInputConfig</code>           \u2013            <p>Twincat handler configuration.</p> </li> <li> <code>TwincatInputOptions</code>           \u2013            <p>Accepted input options.</p> </li> <li> <code>TwincatOptions</code>           \u2013            <p>Final options passed as template context.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_handler</code>             \u2013              <p>Simply return an instance of <code>TwincatHandler</code>.</p> </li> </ul>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatConfig","title":"TwincatConfig  <code>dataclass</code>","text":"<pre><code>TwincatConfig(\n    paths: Annotated[\n        list[str],\n        _Field(\n            description=\"The paths to the twincat files.\"\n        ),\n    ] = lambda: [\".\"](),\n    default_strategy: Annotated[\n        str | None,\n        _Field(description=\"Strategy to parse the files\"),\n    ] = None,\n    options: Annotated[\n        dict[str, Any],\n        _Field(\n            description=\"Configuration options for collecting and rendering objects.\"\n        ),\n    ] = dict(),\n)\n</code></pre> <p>               Bases: <code>TwincatInputConfig</code></p> <p>Twincat handler configuration.</p> <p>Methods:</p> <ul> <li> <code>coerce</code>             \u2013              <p>Coerce data.</p> </li> <li> <code>from_data</code>             \u2013              <p>Create an instance from a dictionary.</p> </li> </ul>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatConfig.coerce","title":"coerce  <code>classmethod</code>","text":"<pre><code>coerce(**data: Any) -&gt; MutableMapping[str, Any]\n</code></pre> <p>Coerce data.</p> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\config.py</code> <pre><code>@classmethod\ndef coerce(cls, **data: Any) -&gt; MutableMapping[str, Any]:\n    \"\"\"Coerce data.\"\"\"\n    return super().coerce(**data)\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatConfig.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(**data: Any) -&gt; Self\n</code></pre> <p>Create an instance from a dictionary.</p> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\config.py</code> <pre><code>@classmethod\ndef from_data(cls, **data: Any) -&gt; Self:\n    \"\"\"Create an instance from a dictionary.\"\"\"\n    return cls(**cls.coerce(**data))\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler","title":"TwincatHandler","text":"<pre><code>TwincatHandler(\n    config: TwincatConfig, base_dir: Path, **kwargs: Any\n)\n</code></pre> <p>               Bases: <code>BaseHandler</code></p> <p>The Twincat handler class.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>TwincatConfig</code>)           \u2013            <p>The handler configuration.</p> </li> <li> <code>base_dir</code>               (<code>Path</code>)           \u2013            <p>The base directory of the project.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Arguments passed to the parent constructor.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>collect</code>             \u2013              <p>Collect data given an identifier and selection configuration.</p> </li> <li> <code>do_convert_markdown</code>             \u2013              <p>Render Markdown text; for use inside templates.</p> </li> <li> <code>do_heading</code>             \u2013              <p>Render an HTML heading and register it for the table of contents. For use inside templates.</p> </li> <li> <code>get_aliases</code>             \u2013              <p>Get aliases for a given identifier.</p> </li> <li> <code>get_extended_templates_dirs</code>             \u2013              <p>Load template extensions for the given handler, return their templates directories.</p> </li> <li> <code>get_headings</code>             \u2013              <p>Return and clear the headings gathered so far.</p> </li> <li> <code>get_inventory_urls</code>             \u2013              <p>Return the URLs (and configuration options) of the inventory files to download.</p> </li> <li> <code>get_options</code>             \u2013              <p>Get combined default, global and local options.</p> </li> <li> <code>get_templates_dir</code>             \u2013              <p>Return the path to the handler's templates directory.</p> </li> <li> <code>load_inventory</code>             \u2013              <p>Yield items and their URLs from an inventory file streamed from <code>in_file</code>.</p> </li> <li> <code>render</code>             \u2013              <p>Render a template using provided data and configuration options.</p> </li> <li> <code>render_backlinks</code>             \u2013              <p>Render backlinks.</p> </li> <li> <code>teardown</code>             \u2013              <p>Teardown the handler.</p> </li> <li> <code>update_env</code>             \u2013              <p>Update the Jinja environment with any custom settings/filters/options for this handler.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>base_dir</code>           \u2013            <p>The base directory of the project.</p> </li> <li> <code>config</code>           \u2013            <p>The handler configuration.</p> </li> <li> <code>custom_templates</code>           \u2013            <p>The path to custom templates.</p> </li> <li> <code>domain</code>               (<code>str</code>)           \u2013            <p>The cross-documentation domain/language for this handler.</p> </li> <li> <code>enable_inventory</code>               (<code>bool</code>)           \u2013            <p>Whether this handler is interested in enabling the creation of the <code>objects.inv</code> Sphinx inventory file.</p> </li> <li> <code>env</code>           \u2013            <p>The Jinja environment.</p> </li> <li> <code>extra_css</code>               (<code>str</code>)           \u2013            <p>Extra CSS.</p> </li> <li> <code>fallback_config</code>               (<code>dict</code>)           \u2013            <p>Fallback configuration when searching anchors for identifiers.</p> </li> <li> <code>fallback_theme</code>               (<code>str</code>)           \u2013            <p>The theme to fallback to.</p> </li> <li> <code>global_options</code>           \u2013            <p>The global configuration options.</p> </li> <li> <code>md</code>               (<code>Markdown</code>)           \u2013            <p>The Markdown instance.</p> </li> <li> <code>mdx</code>           \u2013            <p>The Markdown extensions to use.</p> </li> <li> <code>mdx_config</code>           \u2013            <p>The configuration for the Markdown extensions.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The handler's name.</p> </li> <li> <code>outer_layer</code>               (<code>bool</code>)           \u2013            <p>Whether we're in the outer Markdown conversion layer.</p> </li> <li> <code>theme</code>           \u2013            <p>The selected theme.</p> </li> </ul> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\handler.py</code> <pre><code>def __init__(self, config: TwincatConfig, base_dir: Path, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the handler.\n\n    Parameters:\n        config: The handler configuration.\n        base_dir: The base directory of the project.\n        **kwargs: Arguments passed to the parent constructor.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    self.config = config\n    \"\"\"The handler configuration.\"\"\"\n    self.base_dir = base_dir\n    \"\"\"The base directory of the project.\"\"\"\n    self.global_options = config.options\n    \"\"\"The global configuration options.\"\"\"\n\n    self._collected: dict[str, Objects] = {}\n    self._strategy: BaseStrategy = None\n    if config.default_strategy is not None:\n        strategy = get_strategy(config.default_strategy)\n    else:\n        strategy = get_default_strategy()\n\n\n    self._strategy = strategy()\n    self._loader: Loader = Loader(loader_strategy=self._strategy)\n\n    paths:List[Path] = []\n\n    for path in config.paths:\n        _path = Path(PureWindowsPath(path))\n        if _path.resolve().is_file():\n            paths.append(_path.resolve())\n            _logger.info(f\"filepath: {_path.resolve()} is appended and resolved\")\n        else:\n            _logger.info(f\"filepath: {_path.resolve()} is not appended and resolved\")\n            _logger.error(\"No directories are supported, specify a file!\")\n\n\n\n    self._paths = paths\n    _logger.info(f\"Search Paths: {self._paths}\")\n    self.load_all_objects(paths=self._paths)\n    _logger.info(f\"Parsed {len(self._collected)} twincat objects\")\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.base_dir","title":"base_dir  <code>instance-attribute</code>","text":"<pre><code>base_dir = base_dir\n</code></pre> <p>The base directory of the project.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config\n</code></pre> <p>The handler configuration.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.custom_templates","title":"custom_templates  <code>instance-attribute</code>","text":"<pre><code>custom_templates = custom_templates\n</code></pre> <p>The path to custom templates.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.domain","title":"domain  <code>class-attribute</code>","text":"<pre><code>domain: str = 'twincat'\n</code></pre> <p>The cross-documentation domain/language for this handler.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.enable_inventory","title":"enable_inventory  <code>class-attribute</code>","text":"<pre><code>enable_inventory: bool = False\n</code></pre> <p>Whether this handler is interested in enabling the creation of the <code>objects.inv</code> Sphinx inventory file.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.env","title":"env  <code>instance-attribute</code>","text":"<pre><code>env = Environment(\n    autoescape=True,\n    loader=FileSystemLoader(paths),\n    auto_reload=False,\n)\n</code></pre> <p>The Jinja environment.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.extra_css","title":"extra_css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra_css: str = ''\n</code></pre> <p>Extra CSS.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.fallback_config","title":"fallback_config  <code>class-attribute</code>","text":"<pre><code>fallback_config: dict = {}\n</code></pre> <p>Fallback configuration when searching anchors for identifiers.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.fallback_theme","title":"fallback_theme  <code>class-attribute</code>","text":"<pre><code>fallback_theme: str = 'material'\n</code></pre> <p>The theme to fallback to.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.global_options","title":"global_options  <code>instance-attribute</code>","text":"<pre><code>global_options = options\n</code></pre> <p>The global configuration options.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.md","title":"md  <code>property</code>","text":"<pre><code>md: Markdown\n</code></pre> <p>The Markdown instance.</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When the Markdown instance is not set yet.</p> </li> </ul>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.mdx","title":"mdx  <code>instance-attribute</code>","text":"<pre><code>mdx = mdx\n</code></pre> <p>The Markdown extensions to use.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.mdx_config","title":"mdx_config  <code>instance-attribute</code>","text":"<pre><code>mdx_config = mdx_config\n</code></pre> <p>The configuration for the Markdown extensions.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name: str = 'twincat'\n</code></pre> <p>The handler's name.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.outer_layer","title":"outer_layer  <code>property</code>","text":"<pre><code>outer_layer: bool\n</code></pre> <p>Whether we're in the outer Markdown conversion layer.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.theme","title":"theme  <code>instance-attribute</code>","text":"<pre><code>theme = theme\n</code></pre> <p>The selected theme.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.collect","title":"collect","text":"<pre><code>collect(\n    identifier: str, options: TwincatOptions\n) -&gt; CollectorItem\n</code></pre> <p>Collect data given an identifier and selection configuration.</p> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\handler.py</code> <pre><code>def collect(self, identifier: str, options: TwincatOptions) -&gt; CollectorItem:  # noqa: ARG002\n    \"\"\"Collect data given an identifier and selection configuration.\"\"\"\n    # In the implementation, you either run a specialized tool in a subprocess\n    # to capture its JSON output, that you load again in Python data structures,\n    # or you parse the source code directly, for example with tree-sitter.\n    #\n    # The `identifier` argument is the fully qualified name of the object to collect.\n    # For example, in Python, it would be 'package.module.function' to collect documentation\n    # for this function. Other languages have different conventions.\n    #\n    # The `options` argument is the configuration options for loading/rendering the data.\n    # It contains both the global and local options, combined together.\n    #\n    # You might want to store collected data in `self._collected`, for easier retrieval later,\n    # typically when mkdocstrings will try to get aliases for an identifier through your `get_aliases` method.\n\n\n    try:\n        doc_object = self._collected[identifier]\n    except KeyError as error:\n        raise CollectionError(f\"{identifier} could not be found\") from error\n\n    return doc_object  \n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.do_convert_markdown","title":"do_convert_markdown","text":"<pre><code>do_convert_markdown(\n    text: str,\n    heading_level: int,\n    html_id: str = \"\",\n    *,\n    strip_paragraph: bool = False,\n    autoref_hook: AutorefsHookInterface | None = None,\n) -&gt; Markup\n</code></pre> <p>Render Markdown text; for use inside templates.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The text to convert.</p> </li> <li> <code>heading_level</code>               (<code>int</code>)           \u2013            <p>The base heading level to start all Markdown headings from.</p> </li> <li> <code>html_id</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The HTML id of the element that's considered the parent of this element.</p> </li> <li> <code>strip_paragraph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to exclude the <code>&lt;p&gt;</code> tag from around the whole output.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Markup</code>           \u2013            <p>An HTML string.</p> </li> </ul> Source code in <code>.venv\\Lib\\site-packages\\mkdocstrings\\_internal\\handlers\\base.py</code> <pre><code>def do_convert_markdown(\n    self,\n    text: str,\n    heading_level: int,\n    html_id: str = \"\",\n    *,\n    strip_paragraph: bool = False,\n    autoref_hook: AutorefsHookInterface | None = None,\n) -&gt; Markup:\n    \"\"\"Render Markdown text; for use inside templates.\n\n    Arguments:\n        text: The text to convert.\n        heading_level: The base heading level to start all Markdown headings from.\n        html_id: The HTML id of the element that's considered the parent of this element.\n        strip_paragraph: Whether to exclude the `&lt;p&gt;` tag from around the whole output.\n\n    Returns:\n        An HTML string.\n    \"\"\"\n    global _markdown_conversion_layer  # noqa: PLW0603\n    _markdown_conversion_layer += 1\n    treeprocessors = self.md.treeprocessors\n    treeprocessors[HeadingShiftingTreeprocessor.name].shift_by = heading_level  # type: ignore[attr-defined]\n    treeprocessors[IdPrependingTreeprocessor.name].id_prefix = html_id and html_id + \"--\"  # type: ignore[attr-defined]\n    treeprocessors[ParagraphStrippingTreeprocessor.name].strip = strip_paragraph  # type: ignore[attr-defined]\n    if BacklinksTreeProcessor.name in treeprocessors:\n        treeprocessors[BacklinksTreeProcessor.name].initial_id = html_id  # type: ignore[attr-defined]\n\n    if autoref_hook:\n        self.md.inlinePatterns[AutorefsInlineProcessor.name].hook = autoref_hook  # type: ignore[attr-defined]\n\n    try:\n        return Markup(self.md.convert(text))\n    finally:\n        treeprocessors[HeadingShiftingTreeprocessor.name].shift_by = 0  # type: ignore[attr-defined]\n        treeprocessors[IdPrependingTreeprocessor.name].id_prefix = \"\"  # type: ignore[attr-defined]\n        treeprocessors[ParagraphStrippingTreeprocessor.name].strip = False  # type: ignore[attr-defined]\n        if BacklinksTreeProcessor.name in treeprocessors:\n            treeprocessors[BacklinksTreeProcessor.name].initial_id = None  # type: ignore[attr-defined]\n        self.md.inlinePatterns[AutorefsInlineProcessor.name].hook = None  # type: ignore[attr-defined]\n        self.md.reset()\n        _markdown_conversion_layer -= 1\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.do_heading","title":"do_heading","text":"<pre><code>do_heading(\n    content: Markup,\n    heading_level: int,\n    *,\n    role: str | None = None,\n    hidden: bool = False,\n    toc_label: str | None = None,\n    **attributes: str,\n) -&gt; Markup\n</code></pre> <p>Render an HTML heading and register it for the table of contents. For use inside templates.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>Markup</code>)           \u2013            <p>The HTML within the heading.</p> </li> <li> <code>heading_level</code>               (<code>int</code>)           \u2013            <p>The level of heading (e.g. 3 -&gt; <code>h3</code>).</p> </li> <li> <code>role</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional role for the object bound to this heading.</p> </li> <li> <code>hidden</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, only register it for the table of contents, don't render anything.</p> </li> <li> <code>toc_label</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The title to use in the table of contents ('data-toc-label' attribute).</p> </li> <li> <code>**attributes</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>Any extra HTML attributes of the heading.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Markup</code>           \u2013            <p>An HTML string.</p> </li> </ul> Source code in <code>.venv\\Lib\\site-packages\\mkdocstrings\\_internal\\handlers\\base.py</code> <pre><code>def do_heading(\n    self,\n    content: Markup,\n    heading_level: int,\n    *,\n    role: str | None = None,\n    hidden: bool = False,\n    toc_label: str | None = None,\n    **attributes: str,\n) -&gt; Markup:\n    \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates.\n\n    Arguments:\n        content: The HTML within the heading.\n        heading_level: The level of heading (e.g. 3 -&gt; `h3`).\n        role: An optional role for the object bound to this heading.\n        hidden: If True, only register it for the table of contents, don't render anything.\n        toc_label: The title to use in the table of contents ('data-toc-label' attribute).\n        **attributes: Any extra HTML attributes of the heading.\n\n    Returns:\n        An HTML string.\n    \"\"\"\n    # Produce a heading element that will be used later, in `AutoDocProcessor.run`, to:\n    # - register it in the ToC: right now we're in the inner Markdown conversion layer,\n    #   so we have to bubble up the information to the outer Markdown conversion layer,\n    #   for the ToC extension to pick it up.\n    # - register it in autorefs: right now we don't know what page is being rendered,\n    #   so we bubble up the information again to where autorefs knows the page,\n    #   and can correctly register the heading anchor (id) to its full URL.\n    # - register it in the objects inventory: same as for autorefs,\n    #   we don't know the page here, or the handler (and its domain),\n    #   so we bubble up the information to where the mkdocstrings extension knows that.\n    el = Element(f\"h{heading_level}\", attributes)\n    if toc_label is None:\n        toc_label = content.unescape() if isinstance(content, Markup) else content\n    el.set(\"data-toc-label\", toc_label)\n    if role:\n        el.set(\"data-role\", role)\n    if content:\n        el.text = str(content).strip()\n    self._headings.append(el)\n\n    if hidden:\n        return Markup('&lt;a id=\"{0}\"&gt;&lt;/a&gt;').format(attributes[\"id\"])\n\n    # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading.\n    # Start with a heading that has just attributes (no text), and add a placeholder into it.\n    el = Element(f\"h{heading_level}\", attributes)\n    el.append(Element(\"mkdocstrings-placeholder\"))\n    # Tell the inner 'toc' extension to make its additions if configured so.\n    toc = cast(\"TocTreeprocessor\", self.md.treeprocessors[\"toc\"])\n    if toc.use_anchors:\n        toc.add_anchor(el, attributes[\"id\"])\n    if toc.use_permalinks:\n        toc.add_permalink(el, attributes[\"id\"])\n\n    # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle\n    # of the heading with a placeholder that can never occur (text can't directly contain angle brackets).\n    # Now this HTML wrapper can be \"filled\" by replacing the placeholder.\n    html_with_placeholder = tostring(el, encoding=\"unicode\")\n    assert (  # noqa: S101\n        html_with_placeholder.count(\"&lt;mkdocstrings-placeholder /&gt;\") == 1\n    ), f\"Bug in mkdocstrings: failed to replace in {html_with_placeholder!r}\"\n    html = html_with_placeholder.replace(\"&lt;mkdocstrings-placeholder /&gt;\", content)\n    return Markup(html)\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.get_aliases","title":"get_aliases","text":"<pre><code>get_aliases(identifier: str) -&gt; tuple[str, ...]\n</code></pre> <p>Get aliases for a given identifier.</p> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\handler.py</code> <pre><code>def get_aliases(self, identifier: str) -&gt; tuple[str, ...]:\n    \"\"\"Get aliases for a given identifier.\"\"\"\n    try:\n        data = self._collected[identifier]\n    except KeyError:\n        return ()\n\n    aliases = []\n\n    parts = identifier.split(\".\")\n\n    aliases.append(identifier)\n\n    if len(parts) &gt;= 3:\n        aliases.append(f\"{parts[1]}.{parts[-1]}\")  # z.\u202fB. Lib.Fb_base.Do_something() -&gt; Fb_Base.DoSomething()\n\n    return tuple(aliases)\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.get_extended_templates_dirs","title":"get_extended_templates_dirs","text":"<pre><code>get_extended_templates_dirs(handler: str) -&gt; list[Path]\n</code></pre> <p>Load template extensions for the given handler, return their templates directories.</p> <p>Parameters:</p> <ul> <li> <code>handler</code>               (<code>str</code>)           \u2013            <p>The name of the handler to get the extended templates directory of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Path]</code>           \u2013            <p>The extensions templates directories.</p> </li> </ul> Source code in <code>.venv\\Lib\\site-packages\\mkdocstrings\\_internal\\handlers\\base.py</code> <pre><code>def get_extended_templates_dirs(self, handler: str) -&gt; list[Path]:\n    \"\"\"Load template extensions for the given handler, return their templates directories.\n\n    Arguments:\n        handler: The name of the handler to get the extended templates directory of.\n\n    Returns:\n        The extensions templates directories.\n    \"\"\"\n    discovered_extensions = entry_points(group=f\"mkdocstrings.{handler}.templates\")\n    return [extension.load()() for extension in discovered_extensions]\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.get_headings","title":"get_headings","text":"<pre><code>get_headings() -&gt; Sequence[Element]\n</code></pre> <p>Return and clear the headings gathered so far.</p> <p>Returns:</p> <ul> <li> <code>Sequence[Element]</code>           \u2013            <p>A list of HTML elements.</p> </li> </ul> Source code in <code>.venv\\Lib\\site-packages\\mkdocstrings\\_internal\\handlers\\base.py</code> <pre><code>def get_headings(self) -&gt; Sequence[Element]:\n    \"\"\"Return and clear the headings gathered so far.\n\n    Returns:\n        A list of HTML elements.\n    \"\"\"\n    result = list(self._headings)\n    self._headings.clear()\n    return result\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.get_inventory_urls","title":"get_inventory_urls","text":"<pre><code>get_inventory_urls() -&gt; list[tuple[str, dict[str, Any]]]\n</code></pre> <p>Return the URLs (and configuration options) of the inventory files to download.</p> Source code in <code>.venv\\Lib\\site-packages\\mkdocstrings\\_internal\\handlers\\base.py</code> <pre><code>def get_inventory_urls(self) -&gt; list[tuple[str, dict[str, Any]]]:\n    \"\"\"Return the URLs (and configuration options) of the inventory files to download.\"\"\"\n    return []\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.get_options","title":"get_options","text":"<pre><code>get_options(\n    local_options: Mapping[str, Any],\n) -&gt; HandlerOptions\n</code></pre> <p>Get combined default, global and local options.</p> <p>Parameters:</p> <ul> <li> <code>local_options</code>               (<code>Mapping[str, Any]</code>)           \u2013            <p>The local options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HandlerOptions</code>           \u2013            <p>The combined options.</p> </li> </ul> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\handler.py</code> <pre><code>def get_options(self, local_options: Mapping[str, Any]) -&gt; HandlerOptions:\n    \"\"\"Get combined default, global and local options.\n\n    Arguments:\n        local_options: The local options.\n\n    Returns:\n        The combined options.\n    \"\"\"\n    extra = {**self.global_options.get(\"extra\", {}), **local_options.get(\"extra\", {})}\n    options = {**self.global_options, **local_options, \"extra\": extra}\n    try:\n        return TwincatOptions.from_data(**options)\n    except Exception as error:\n        raise PluginError(f\"Invalid options: {error}\") from error\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.get_templates_dir","title":"get_templates_dir","text":"<pre><code>get_templates_dir(handler: str | None = None) -&gt; Path\n</code></pre> <p>Return the path to the handler's templates directory.</p> <p>Override to customize how the templates directory is found.</p> <p>Parameters:</p> <ul> <li> <code>handler</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the handler to get the templates directory of.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ModuleNotFoundError</code>             \u2013            <p>When no such handler is installed.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>When the templates directory cannot be found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>The templates directory path.</p> </li> </ul> Source code in <code>.venv\\Lib\\site-packages\\mkdocstrings\\_internal\\handlers\\base.py</code> <pre><code>def get_templates_dir(self, handler: str | None = None) -&gt; Path:\n    \"\"\"Return the path to the handler's templates directory.\n\n    Override to customize how the templates directory is found.\n\n    Arguments:\n        handler: The name of the handler to get the templates directory of.\n\n    Raises:\n        ModuleNotFoundError: When no such handler is installed.\n        FileNotFoundError: When the templates directory cannot be found.\n\n    Returns:\n        The templates directory path.\n    \"\"\"\n    handler = handler or self.name\n    try:\n        import mkdocstrings_handlers\n    except ModuleNotFoundError as error:\n        raise ModuleNotFoundError(f\"Handler '{handler}' not found, is it installed?\") from error\n\n    for path in mkdocstrings_handlers.__path__:\n        theme_path = Path(path, handler, \"templates\")\n        if theme_path.exists():\n            return theme_path\n\n    raise FileNotFoundError(f\"Can't find 'templates' folder for handler '{handler}'\")\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.load_inventory","title":"load_inventory  <code>classmethod</code>","text":"<pre><code>load_inventory(\n    in_file: BinaryIO,\n    url: str,\n    base_url: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator[tuple[str, str]]\n</code></pre> <p>Yield items and their URLs from an inventory file streamed from <code>in_file</code>.</p> <p>Parameters:</p> <ul> <li> <code>in_file</code>               (<code>BinaryIO</code>)           \u2013            <p>The binary file-like object to read the inventory from.</p> </li> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The URL that this file is being streamed from (used to guess <code>base_url</code>).</p> </li> <li> <code>base_url</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The URL that this inventory's sub-paths are relative to.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Ignore additional arguments passed from the config.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>tuple[str, str]</code>           \u2013            <p>Tuples of (item identifier, item URL).</p> </li> </ul> Source code in <code>.venv\\Lib\\site-packages\\mkdocstrings\\_internal\\handlers\\base.py</code> <pre><code>@classmethod\ndef load_inventory(\n    cls,\n    in_file: BinaryIO,  # noqa: ARG003\n    url: str,  # noqa: ARG003\n    base_url: str | None = None,  # noqa: ARG003\n    **kwargs: Any,  # noqa: ARG003\n) -&gt; Iterator[tuple[str, str]]:\n    \"\"\"Yield items and their URLs from an inventory file streamed from `in_file`.\n\n    Arguments:\n        in_file: The binary file-like object to read the inventory from.\n        url: The URL that this file is being streamed from (used to guess `base_url`).\n        base_url: The URL that this inventory's sub-paths are relative to.\n        **kwargs: Ignore additional arguments passed from the config.\n\n    Yields:\n        Tuples of (item identifier, item URL).\n    \"\"\"\n    yield from ()\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.render","title":"render","text":"<pre><code>render(data: CollectorItem, options: TwincatOptions) -&gt; str\n</code></pre> <p>Render a template using provided data and configuration options.</p> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\handler.py</code> <pre><code>def render(self, data: CollectorItem, options: TwincatOptions) -&gt; str:\n    \"\"\"Render a template using provided data and configuration options.\"\"\"\n    # The `data` argument is the data to render, that was collected above in `collect()`.\n    # The `options` argument is the configuration options for loading/rendering the data.\n    # It contains both the global and local options, combined together.\n\n    template_name = rendering.do_get_template(self.env, data)\n    template = self.env.get_template(template_name)\n\n    return template.render(\n        **{\n            \"config\": options,\n            data.kind: data, # depending on the class type of the data, the variable inside the jinja template will be named differently\n            \"heading_level\": options.heading_level,\n            \"root\": True,\n        },\n    )\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.render_backlinks","title":"render_backlinks","text":"<pre><code>render_backlinks(\n    backlinks: Mapping[str, Iterable[Backlink]],\n) -&gt; str\n</code></pre> <p>Render backlinks.</p> Source code in <code>.venv\\Lib\\site-packages\\mkdocstrings\\_internal\\handlers\\base.py</code> <pre><code>def render_backlinks(self, backlinks: Mapping[str, Iterable[Backlink]]) -&gt; str:  # noqa: ARG002\n    \"\"\"Render backlinks.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Teardown the handler.</p> <p>This method should be implemented to, for example, terminate a subprocess that was started when creating the handler instance.</p> Source code in <code>.venv\\Lib\\site-packages\\mkdocstrings\\_internal\\handlers\\base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Teardown the handler.\n\n    This method should be implemented to, for example, terminate a subprocess\n    that was started when creating the handler instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatHandler.update_env","title":"update_env","text":"<pre><code>update_env(config: dict) -&gt; None\n</code></pre> <p>Update the Jinja environment with any custom settings/filters/options for this handler.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>dict</code>)           \u2013            <p>MkDocs configuration, read from <code>mkdocs.yml</code>.</p> </li> </ul> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\handler.py</code> <pre><code>def update_env(self, config: dict) -&gt; None:  # noqa: ARG002\n    \"\"\"Update the Jinja environment with any custom settings/filters/options for this handler.\n\n    Parameters:\n        config: MkDocs configuration, read from `mkdocs.yml`.\n    \"\"\"\n    self.env.trim_blocks = True\n    self.env.lstrip_blocks = True\n    self.env.keep_trailing_newline = False\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatInputConfig","title":"TwincatInputConfig  <code>dataclass</code>","text":"<pre><code>TwincatInputConfig(\n    paths: Annotated[\n        list[str],\n        _Field(\n            description=\"The paths to the twincat files.\"\n        ),\n    ] = lambda: [\".\"](),\n    default_strategy: Annotated[\n        str | None,\n        _Field(description=\"Strategy to parse the files\"),\n    ] = None,\n    options: Annotated[\n        TwincatInputOptions,\n        _Field(\n            description=\"Configuration options for collecting and rendering objects.\"\n        ),\n    ] = TwincatInputOptions(),\n)\n</code></pre> <p>Twincat handler configuration.</p> <p>Methods:</p> <ul> <li> <code>coerce</code>             \u2013              <p>Coerce data.</p> </li> <li> <code>from_data</code>             \u2013              <p>Create an instance from a dictionary.</p> </li> </ul>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatInputConfig.coerce","title":"coerce  <code>classmethod</code>","text":"<pre><code>coerce(**data: Any) -&gt; MutableMapping[str, Any]\n</code></pre> <p>Coerce data.</p> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\config.py</code> <pre><code>@classmethod\ndef coerce(cls, **data: Any) -&gt; MutableMapping[str, Any]:\n    \"\"\"Coerce data.\"\"\"\n    return data\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatInputConfig.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(**data: Any) -&gt; Self\n</code></pre> <p>Create an instance from a dictionary.</p> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\config.py</code> <pre><code>@classmethod\ndef from_data(cls, **data: Any) -&gt; Self:\n    \"\"\"Create an instance from a dictionary.\"\"\"\n    return cls(**cls.coerce(**data))\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatInputOptions","title":"TwincatInputOptions  <code>dataclass</code>","text":"<pre><code>TwincatInputOptions(\n    extra: Annotated[\n        dict[str, Any],\n        _Field(\n            group=\"general\", description=\"Extra options.\"\n        ),\n    ] = dict(),\n    heading: Annotated[\n        str,\n        _Field(\n            group=\"headings\",\n            description=\"A custom string to override the autogenerated heading of the root object.\",\n        ),\n    ] = \"\",\n    heading_level: Annotated[\n        int,\n        _Field(\n            group=\"headings\",\n            description=\"The initial heading level to use.\",\n        ),\n    ] = 2,\n    show_symbol_type_heading: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"Show the symbol type in headings (e.g. mod, class, meth, func and attr).\",\n        ),\n    ] = False,\n    show_symbol_type_toc: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"Show the symbol type in the Table of Contents (e.g. mod, class, methd, func and attr).\",\n        ),\n    ] = False,\n    show_root_members_full_path: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"Show the full twincat path of the root members.\",\n        ),\n    ] = False,\n    show_object_full_path: Annotated[\n        bool,\n        _Field(\n            group=\"docstrings\",\n            description=\"Show the full twincat path of every object.\",\n        ),\n    ] = False,\n    show_root_heading: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"Show the heading of the object at the root of the documentation tree.\\n\\n            The root object is the object referenced by the identifier after `:::`.\\n            \",\n        ),\n    ] = False,\n    show_source: Annotated[\n        bool,\n        _Field(\n            group=\"general\",\n            description=\"Show the source code of this object.\",\n        ),\n    ] = True,\n    show_implements: Annotated[\n        bool,\n        _Field(\n            group=\"general\",\n            description=\"if the pou implements something.\",\n        ),\n    ] = True,\n    show_extends: Annotated[\n        bool,\n        _Field(\n            group=\"general\",\n            description=\"show if the pou extends something\",\n        ),\n    ] = True,\n    show_access_modifier: Annotated[\n        bool,\n        _Field(\n            group=\"general\",\n            description=\"show the access modifier of the method\",\n        ),\n    ] = True,\n    show_return: Annotated[\n        bool,\n        _Field(\n            group=\"general\",\n            description=\"show the return of the method\",\n        ),\n    ] = True,\n    show_root_toc_entry: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"If the root heading is not shown, at least add a ToC entry for it.\",\n        ),\n    ] = True,\n    show_labels: Annotated[\n        bool,\n        _Field(\n            group=\"docu\",\n            description=\"Whether to show labels of the members.\",\n        ),\n    ] = True,\n    variable_headings: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"Whether to render headings for variables (therefore showing variables in the ToC).\",\n        ),\n    ] = False,\n    toc_label: Annotated[\n        str,\n        _Field(\n            group=\"headings\",\n            description=\"A custom string to override the autogenerated toc label of the root object.\",\n        ),\n    ] = \"\",\n    summary: Annotated[\n        bool | SummaryOption,\n        _Field(\n            group=\"members\",\n            description=\"Whether to render summaries of tcplc proj, pous, duts, itfs, methods.\",\n        ),\n    ] = SummaryOption(),\n    show_category_heading: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"When grouped by categories, show a heading for each category.\",\n        ),\n    ] = False,\n    variable_section_style: Annotated[\n        Literal[\"table\", \"list\"],\n        _Field(\n            group=\"variable\",\n            description=\"The style used to render variable sections.\",\n        ),\n    ] = \"table\",\n    summary_section_style: Annotated[\n        Literal[\"table\", \"list\"],\n        _Field(\n            group=\"variable\",\n            description=\"The style used to render summarys.\",\n        ),\n    ] = \"table\",\n)\n</code></pre> <p>Accepted input options.</p> <p>Methods:</p> <ul> <li> <code>coerce</code>             \u2013              <p>Coerce data.</p> </li> <li> <code>from_data</code>             \u2013              <p>Create an instance from a dictionary.</p> </li> </ul>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatInputOptions.coerce","title":"coerce  <code>classmethod</code>","text":"<pre><code>coerce(**data: Any) -&gt; MutableMapping[str, Any]\n</code></pre> <p>Coerce data.</p> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\config.py</code> <pre><code>@classmethod\ndef coerce(cls, **data: Any) -&gt; MutableMapping[str, Any]:\n    \"\"\"Coerce data.\"\"\"\n    if \"summary\" in data:\n        summary = data[\"summary\"]\n        if summary is True:\n            summary = SummaryOption(properties=True, methods=True, pous=True, itfs=True, duts=True, gvls=True, variables=True)\n        elif summary is False:\n            summary = SummaryOption(properties=False, methods=False, pous=False, itfs=False, duts=False, gvls=False, variables=False)\n        else:\n            summary = SummaryOption(**summary)\n        data[\"summary\"] = summary\n    return data\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatInputOptions.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(**data: Any) -&gt; Self\n</code></pre> <p>Create an instance from a dictionary.</p> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\config.py</code> <pre><code>@classmethod\ndef from_data(cls, **data: Any) -&gt; Self:\n    \"\"\"Create an instance from a dictionary.\"\"\"\n    return cls(**cls.coerce(**data))\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatOptions","title":"TwincatOptions  <code>dataclass</code>","text":"<pre><code>TwincatOptions(\n    extra: Annotated[\n        dict[str, Any],\n        _Field(\n            group=\"general\", description=\"Extra options.\"\n        ),\n    ] = dict(),\n    heading: Annotated[\n        str,\n        _Field(\n            group=\"headings\",\n            description=\"A custom string to override the autogenerated heading of the root object.\",\n        ),\n    ] = \"\",\n    heading_level: Annotated[\n        int,\n        _Field(\n            group=\"headings\",\n            description=\"The initial heading level to use.\",\n        ),\n    ] = 2,\n    show_symbol_type_heading: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"Show the symbol type in headings (e.g. mod, class, meth, func and attr).\",\n        ),\n    ] = False,\n    show_symbol_type_toc: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"Show the symbol type in the Table of Contents (e.g. mod, class, methd, func and attr).\",\n        ),\n    ] = False,\n    show_root_members_full_path: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"Show the full twincat path of the root members.\",\n        ),\n    ] = False,\n    show_object_full_path: Annotated[\n        bool,\n        _Field(\n            group=\"docstrings\",\n            description=\"Show the full twincat path of every object.\",\n        ),\n    ] = False,\n    show_root_heading: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"Show the heading of the object at the root of the documentation tree.\\n\\n            The root object is the object referenced by the identifier after `:::`.\\n            \",\n        ),\n    ] = False,\n    show_source: Annotated[\n        bool,\n        _Field(\n            group=\"general\",\n            description=\"Show the source code of this object.\",\n        ),\n    ] = True,\n    show_implements: Annotated[\n        bool,\n        _Field(\n            group=\"general\",\n            description=\"if the pou implements something.\",\n        ),\n    ] = True,\n    show_extends: Annotated[\n        bool,\n        _Field(\n            group=\"general\",\n            description=\"show if the pou extends something\",\n        ),\n    ] = True,\n    show_access_modifier: Annotated[\n        bool,\n        _Field(\n            group=\"general\",\n            description=\"show the access modifier of the method\",\n        ),\n    ] = True,\n    show_return: Annotated[\n        bool,\n        _Field(\n            group=\"general\",\n            description=\"show the return of the method\",\n        ),\n    ] = True,\n    show_root_toc_entry: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"If the root heading is not shown, at least add a ToC entry for it.\",\n        ),\n    ] = True,\n    show_labels: Annotated[\n        bool,\n        _Field(\n            group=\"docu\",\n            description=\"Whether to show labels of the members.\",\n        ),\n    ] = True,\n    variable_headings: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"Whether to render headings for variables (therefore showing variables in the ToC).\",\n        ),\n    ] = False,\n    toc_label: Annotated[\n        str,\n        _Field(\n            group=\"headings\",\n            description=\"A custom string to override the autogenerated toc label of the root object.\",\n        ),\n    ] = \"\",\n    summary: SummaryOption = SummaryOption(),\n    show_category_heading: Annotated[\n        bool,\n        _Field(\n            group=\"headings\",\n            description=\"When grouped by categories, show a heading for each category.\",\n        ),\n    ] = False,\n    variable_section_style: Annotated[\n        Literal[\"table\", \"list\"],\n        _Field(\n            group=\"variable\",\n            description=\"The style used to render variable sections.\",\n        ),\n    ] = \"table\",\n    summary_section_style: Annotated[\n        Literal[\"table\", \"list\"],\n        _Field(\n            group=\"variable\",\n            description=\"The style used to render summarys.\",\n        ),\n    ] = \"table\",\n)\n</code></pre> <p>               Bases: <code>TwincatInputOptions</code></p> <p>Final options passed as template context.</p> <p>Methods:</p> <ul> <li> <code>coerce</code>             \u2013              <p>Create an instance from a dictionary.</p> </li> <li> <code>from_data</code>             \u2013              <p>Create an instance from a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>summary</code>               (<code>SummaryOption</code>)           \u2013            <p>Whether to render summaries of modules, classes, functions (methods) and attributes.</p> </li> </ul>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatOptions.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: SummaryOption = field(\n    default_factory=SummaryOption\n)\n</code></pre> <p>Whether to render summaries of modules, classes, functions (methods) and attributes.</p>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatOptions.coerce","title":"coerce  <code>classmethod</code>","text":"<pre><code>coerce(**data: Any) -&gt; MutableMapping[str, Any]\n</code></pre> <p>Create an instance from a dictionary.</p> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\config.py</code> <pre><code>@classmethod\ndef coerce(cls, **data: Any) -&gt; MutableMapping[str, Any]:\n    \"\"\"Create an instance from a dictionary.\"\"\"\n    # Coerce any field into its final form.\n    return super().coerce(**data)\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.TwincatOptions.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(**data: Any) -&gt; Self\n</code></pre> <p>Create an instance from a dictionary.</p> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\config.py</code> <pre><code>@classmethod\ndef from_data(cls, **data: Any) -&gt; Self:\n    \"\"\"Create an instance from a dictionary.\"\"\"\n    return cls(**cls.coerce(**data))\n</code></pre>"},{"location":"reference/api/#mkdocstrings_handlers.twincat.get_handler","title":"get_handler","text":"<pre><code>get_handler(\n    handler_config: MutableMapping[str, Any],\n    tool_config: MkDocsConfig,\n    **kwargs: Any,\n) -&gt; TwincatHandler\n</code></pre> <p>Simply return an instance of <code>TwincatHandler</code>.</p> <p>Parameters:</p> <ul> <li> <code>handler_config</code>               (<code>MutableMapping[str, Any]</code>)           \u2013            <p>The handler configuration.</p> </li> <li> <code>tool_config</code>               (<code>MkDocsConfig</code>)           \u2013            <p>The tool (SSG) configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TwincatHandler</code>           \u2013            <p>An instance of <code>TwincatHandler</code>.</p> </li> </ul> Source code in <code>src\\mkdocstrings_handlers\\twincat\\_internal\\handler.py</code> <pre><code>def get_handler(\n    handler_config: MutableMapping[str, Any],\n    tool_config: MkDocsConfig,\n    **kwargs: Any,\n) -&gt; TwincatHandler:\n    \"\"\"Simply return an instance of `TwincatHandler`.\n\n    Arguments:\n        handler_config: The handler configuration.\n        tool_config: The tool (SSG) configuration.\n\n    Returns:\n        An instance of `TwincatHandler`.\n    \"\"\"\n    base_dir = Path(tool_config.config_file_path or \"./mkdocs.yml\").parent\n    return TwincatHandler(\n        config=TwincatConfig.from_data(**handler_config),\n        base_dir=base_dir,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/tcunit/","title":"API reference","text":""},{"location":"reference/tcunit/#TcUnit","title":"TcUnit  <code>1.3.2</code>","text":"<p>TwinCAT unit testing framework. Documentation and examples are available at www.tcunit.org</p> <p>Interfaces</p> <ul> <li> <code>I_AssertMessageFormatter</code> </li> <li> <code>I_TestResultLogger</code> </li> <li> <code>I_TestResults</code> </li> </ul> <p>Function Blocks</p> <ul> <li> <code>FB_AdsAssertMessageFormatter</code> </li> <li> <code>FB_AdsLogStringMessageFifoQueue</code> </li> <li> <code>FB_AdsTestResultLogger</code> </li> <li> <code>FB_FileControl</code> </li> <li> <code>FB_StreamBuffer</code> </li> <li> <code>FB_xUnitXmlPublisher</code> </li> <li> <code>FB_TestResults</code> </li> <li> <code>FB_AdjustAssertFailureMessageToMax253CharLength</code> </li> <li> <code>FB_AssertResultStatic</code> </li> <li> <code>FB_AssertArrayResultStatic</code> </li> <li> <code>FB_TcUnitRunner</code> </li> <li> <code>FB_Test</code> </li> <li> <code>FB_TestSuite</code> </li> <li> <code>FB_XmlControl</code> </li> <li> <code>F_AnyToUnionValue</code> </li> <li> <code>F_AnyTypeClassToString</code> </li> <li> <code>F_AssertionTypeToString</code> </li> <li> <code>F_GetCpuCounterAs64bit</code> </li> <li> <code>F_GetTestSuiteNameFromTestInstancePath</code> </li> <li> <code>F_IsAnyEqualToUnionValue</code> </li> <li> <code>F_RemoveInstancePathAndProjectNameFromTestInstancePath</code> </li> <li> <code>IS_TEST_FINISHED</code> </li> <li> <code>RUN</code> </li> <li> <code>RUN_IN_SEQUENCE</code> </li> <li> <code>TCUNIT_ADSLOGSTR</code> </li> <li> <code>TEST</code> </li> <li> <code>TEST_FINISHED</code> </li> <li> <code>TEST_FINISHED_NAMED</code> </li> <li> <code>TEST_ORDERED</code> </li> <li> <code>WRITE_PROTECTED_BOOL</code> </li> <li> <code>WRITE_PROTECTED_BYTE</code> </li> <li> <code>WRITE_PROTECTED_DATE</code> </li> <li> <code>WRITE_PROTECTED_DATE_AND_TIME</code> </li> <li> <code>WRITE_PROTECTED_DINT</code> </li> <li> <code>WRITE_PROTECTED_DWORD</code> </li> <li> <code>WRITE_PROTECTED_INT</code> </li> <li> <code>WRITE_PROTECTED_LREAL</code> </li> <li> <code>WRITE_PROTECTED_REAL</code> </li> <li> <code>WRITE_PROTECTED_SINT</code> </li> <li> <code>WRITE_PROTECTED_STRING</code> </li> <li> <code>WRITE_PROTECTED_WSTRING</code> </li> <li> <code>WRITE_PROTECTED_TIME</code> </li> <li> <code>WRITE_PROTECTED_TIME_OF_DAY</code> </li> <li> <code>WRITE_PROTECTED_UDINT</code> </li> <li> <code>WRITE_PROTECTED_UINT</code> </li> <li> <code>WRITE_PROTECTED_ULINT</code> </li> <li> <code>WRITE_PROTECTED_LWORD</code> </li> <li> <code>WRITE_PROTECTED_LINT</code> </li> <li> <code>WRITE_PROTECTED_USINT</code> </li> <li> <code>WRITE_PROTECTED_WORD</code> </li> </ul> <p>User Datatypes</p> <ul> <li> <code>E_AssertionType</code> </li> <li> <code>E_XmlError</code> </li> <li> <code>ST_AdsLogStringMessage</code> </li> <li> <code>ST_AssertResult</code> </li> <li> <code>ST_AssertResultInstances</code> </li> <li> <code>ST_AssertArrayResult</code> </li> <li> <code>ST_AssertArrayResultInstances</code> </li> <li> <code>ST_TestCaseResult</code> </li> <li> <code>ST_TestSuiteResult</code> </li> <li> <code>ST_TestSuiteResults</code> </li> <li> <code>U_ExpectedOrActual</code> </li> </ul> <p>Global Variablelists</p> <ul> <li> <code>GVL_Param_TcUnit</code> </li> <li> <code>GVL_TcUnit</code> </li> <li> <code>Global_Version</code> </li> </ul> <p>Dependencies</p> <ul> <li> <code>SysDir</code>                 \u2013                  * \u2013 System                 </li> <li> <code>SysFile</code>                 \u2013                  * \u2013 System                 </li> <li> <code>Tc2_Standard</code>                 \u2013                  * \u2013 Beckhoff Automation GmbH                 </li> <li> <code>Tc2_System</code>                 \u2013                  * \u2013 Beckhoff Automation GmbH                 </li> <li> <code>Tc2_Utilities</code>                 \u2013                  * \u2013 Beckhoff Automation GmbH                 </li> </ul>"},{"location":"reference/tcunit/#TcUnit.I_AssertMessageFormatter","title":"I_AssertMessageFormatter","text":"<p>Methods</p> <ul> <li> <code>LogAssertFailure</code> </li> </ul>"},{"location":"reference/tcunit/#I_AssertMessageFormatter.LogAssertFailure","title":"LogAssertFailure","text":"<p>Inputs</p> <ul> <li> <code>Expected</code> </li> <li> <code>Actual</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD LogAssertFailure\nVAR_INPUT\n    Expected : T_MaxString;\n    Actual : T_MaxString;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#LogAssertFailure.Expected","title":"Expected  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#LogAssertFailure.Actual","title":"Actual  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#LogAssertFailure.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#LogAssertFailure.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.I_TestResultLogger","title":"I_TestResultLogger","text":"<p>Methods</p> <ul> <li> <code>LogTestSuiteResults</code> </li> </ul>"},{"location":"reference/tcunit/#I_TestResultLogger.LogTestSuiteResults","title":"LogTestSuiteResults  <code>PUBLIC</code>","text":"Source Code <pre><code>METHOD PUBLIC LogTestSuiteResults\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.I_TestResults","title":"I_TestResults","text":"<p>Methods</p> <ul> <li> <code>GetAreTestResultsAvailable</code> </li> <li> <code>GetTestSuiteResults</code> </li> </ul>"},{"location":"reference/tcunit/#I_TestResults.GetAreTestResultsAvailable","title":"GetAreTestResultsAvailable  <code>BOOL</code>","text":"Source Code <pre><code>METHOD GetAreTestResultsAvailable : BOOL\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#I_TestResults.GetTestSuiteResults","title":"GetTestSuiteResults  <code>REFERENCE TO ST_TestSuiteResults</code>","text":"Source Code <pre><code>METHOD GetTestSuiteResults : REFERENCE TO ST_TestSuiteResults;\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_AdsAssertMessageFormatter","title":"FB_AdsAssertMessageFormatter","text":"<p>Methods</p> <ul> <li> <code>LogAssertFailure</code> </li> </ul> Source Code <pre><code>(*\n    This function block is responsible for printing the results of the assertions using the built-in\n    ADSLOGSTR functionality provided by the Tc2_System library. This sends the result using ADS, which\n    is consumed by the error list of Visual Studio.\n*)\nFUNCTION_BLOCK FB_AdsAssertMessageFormatter IMPLEMENTS I_AssertMessageFormatter\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_AdsAssertMessageFormatter.LogAssertFailure","title":"LogAssertFailure  <code>PUBLIC</code>","text":"<p>Inputs</p> <ul> <li> <code>Expected</code> </li> <li> <code>Actual</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD PUBLIC LogAssertFailure\nVAR_INPUT\n    Expected : T_MaxString;\n    Actual : T_MaxString;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    AdjustAssertFailureMessageToMax253CharLength : FB_AdjustAssertFailureMessageToMax253CharLength;\n    TestInstancePathCleaned : T_MaxString;\n    TestInstancePathFinal : T_MaxString;\n    ReturnValue : DINT;\n    TestInstancePathProcessed : T_MaxString;\n    MessageProcessed : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>TestInstancePathCleaned := F_RemoveInstancePathAndProjectNameFromTestInstancePath(TestInstancePath);\nTestInstancePathFinal := CONCAT(STR1 := 'FAILED TEST $'',\n                                STR2 := TestInstancePathCleaned);\nTestInstancePathFinal := CONCAT(STR1 := TestInstancePathFinal,\n                                STR2 := '$'');\n\nTestInstancePathFinal := CONCAT(STR1 := TestInstancePathFinal,\n                                STR2 := ', EXP: ');\nTestInstancePathFinal := CONCAT(STR1 := TestInstancePathFinal,\n                                STR2 := Expected);\nTestInstancePathFinal := CONCAT(STR1 := TestInstancePathFinal,\n                                STR2 := ', ACT: ');\nTestInstancePathFinal := CONCAT(STR1 := TestInstancePathFinal,\n                                STR2 := Actual);\nIF LEN(STR := Message) &gt; 0 THEN\n    TestInstancePathFinal := CONCAT(STR1 := TestInstancePathFinal,\n                                    STR2 := ', MSG: %s');\nEND_IF\n\nAdjustAssertFailureMessageToMax253CharLength(TestInstancePath := TestInstancePathFinal,\n                                             TestMessage := Message,\n                                             TestInstancePathProcessed =&gt; TestInstancePathProcessed,\n                                             TestMessageProcessed =&gt; MessageProcessed);\n\nGVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                    MsgFmtStr := TestInstancePathProcessed,\n                                    StrArg := MessageProcessed);\n</code></pre>"},{"location":"reference/tcunit/#LogAssertFailure.Expected","title":"Expected  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#LogAssertFailure.Actual","title":"Actual  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#LogAssertFailure.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#LogAssertFailure.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AdsLogStringMessageFifoQueue","title":"FB_AdsLogStringMessageFifoQueue","text":"<p>Methods</p> <ul> <li> <code>GetAndRemoveLogFromQueue</code> </li> <li> <code>GetLogCount</code> </li> <li> <code>WriteLog</code> </li> </ul> Source Code <pre><code>(* This function block is responsible for making sure that the ADSLOGSTR-messages to the ADS-router are transmitted\n   cyclically and not in a burst. The reason this is necessary is because that if too many messages are sent at the\n   same time some get lost and are never printed to the error list output\n*)\nFUNCTION_BLOCK FB_AdsLogStringMessageFifoQueue\nVAR\n    ArrayBuffer : ARRAY[0..((GVL_Param_TcUnit.AdsLogMessageFifoRingBufferSize * (SIZEOF(ST_ADSLogStringMessage) + MEM_RING_BUFFER_INTERNAL_USE_PER_DATA_RECORD)) - 1)] OF BYTE;\n    MemRingBuffer : FB_MemRingBuffer;\n    TimerBetweenMessages : TON := (IN := TRUE, PT := TIME_BETWEEN_MESSAGES);\nEND_VAR\nVAR CONSTANT\n    MEM_RING_BUFFER_INTERNAL_USE_PER_DATA_RECORD : USINT := 4;\n    TIME_BETWEEN_MESSAGES : TIME := T#10MS;\nEND_VAR\nVAR_TEMP\n    MessageToBeSent : ST_AdsLogStringMessage;\n    ErrorGet : BOOL;\n    ReturnValue : DINT;\nEND_VAR\n</code></pre> <pre><code>TimerBetweenMessages();\nIF GetLogCount() &gt; 0 THEN\n    // Timer has elapsed, print message\n    IF TimerBetweenMessages.Q THEN\n        GetAndRemoveLogFromQueue(AdsLogStringMessage =&gt; MessageToBeSent,\n                                 Error =&gt; ErrorGet);\n        IF NOT ErrorGet THEN\n            ReturnValue := ADSLOGSTR(msgCtrlMask := MessageToBeSent.MsgCtrlMask,\n                                     msgFmtStr := MessageToBeSent.MsgFmtStr,\n                                     strArg := MessageToBeSent.StrArg);\n        END_IF\n        TimerBetweenMessages(IN := FALSE); // Reset timer\n        TimerBetweenMessages.IN := TRUE;\n    END_IF\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_AdsLogStringMessageFifoQueue.GetAndRemoveLogFromQueue","title":"GetAndRemoveLogFromQueue","text":"<p>Outputs</p> <ul> <li> <code>AdsLogStringMessage</code> </li> <li> <code>Error</code>             \u2013              <p>Buffer empty</p> </li> </ul> Source Code <pre><code>(* Reads and removes the oldest message *)\nMETHOD PRIVATE GetAndRemoveLogFromQueue\nVAR_OUTPUT\n    AdsLogStringMessage : ST_ADSLogStringMessage;\n    Error : BOOL; // Buffer empty\nEND_VAR\n</code></pre> <pre><code>MemRingBuffer.A_RemoveHead(pRead := ADR(AdsLogStringMessage),\n                           cbRead := SIZEOF(ST_ADSLogStringMessage),\n                           pBuffer := ADR(ArrayBuffer),\n                           cbBuffer := SIZEOF(ArrayBuffer));\nError := NOT MemRingBuffer.bOk;\n</code></pre>"},{"location":"reference/tcunit/#GetAndRemoveLogFromQueue.AdsLogStringMessage","title":"AdsLogStringMessage  <code>ST_ADSLogStringMessage</code>","text":""},{"location":"reference/tcunit/#GetAndRemoveLogFromQueue.Error","title":"Error  <code>BOOL</code>","text":"<p>Buffer empty</p>"},{"location":"reference/tcunit/#TcUnit.FB_AdsLogStringMessageFifoQueue.GetLogCount","title":"GetLogCount  <code>UDINT</code> <code>PRIVATE</code>","text":"Source Code <pre><code>METHOD PRIVATE GetLogCount : UDINT\n</code></pre> <pre><code>GetLogCount := MemRingBuffer.nCount;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_AdsLogStringMessageFifoQueue.WriteLog","title":"WriteLog","text":"<p>Inputs</p> <ul> <li> <code>MsgCtrlMask</code> </li> <li> <code>MsgFmtStr</code> </li> <li> <code>StrArg</code> </li> </ul> <p>Outputs</p> <ul> <li> <code>Error</code>             \u2013              <p>Buffer overflow</p> </li> </ul> Source Code <pre><code>// Writes a new data set into the ring buffer\nMETHOD INTERNAL WriteLog\nVAR_INPUT\n    MsgCtrlMask : DWORD;\n    MsgFmtStr : T_MaxString;\n    StrArg : T_MaxString;\nEND_VAR\nVAR_OUTPUT\n    Error : BOOL; // Buffer overflow\nEND_VAR\nVAR\n    AdsLogStringMessage : ST_AdsLogStringMessage;\nEND_VAR\n</code></pre> <pre><code>// Only log message types of ERROR if log extended results is not enabled\nIF MsgCtrlMask = ADSLOG_MSGTYPE_ERROR OR GVL_Param_TcUnit.LogExtendedResults THEN\n    AdsLogStringMessage.MsgCtrlMask := MsgCtrlMask;\n    AdsLogStringMessage.MsgFmtStr := MsgFmtStr;\n    AdsLogStringMessage.StrArg := StrArg;\n\n    MemRingBuffer.A_AddTail(pWrite := ADR(AdsLogStringMessage),\n                            cbWrite := SIZEOF(ST_AdsLogStringMessage),\n                            pBuffer := ADR(ArrayBuffer),\n                            cbBuffer := SIZEOF(ArrayBuffer));\n\n    Error := NOT MemRingBuffer.bOk;\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#WriteLog.MsgCtrlMask","title":"MsgCtrlMask  <code>DWORD</code>","text":""},{"location":"reference/tcunit/#WriteLog.MsgFmtStr","title":"MsgFmtStr  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#WriteLog.StrArg","title":"StrArg  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#WriteLog.Error","title":"Error  <code>BOOL</code>","text":"<p>Buffer overflow</p>"},{"location":"reference/tcunit/#TcUnit.FB_AdsTestResultLogger","title":"FB_AdsTestResultLogger","text":"<p>Methods</p> <ul> <li> <code>FB_init</code> </li> <li> <code>LogTestSuiteResults</code> </li> </ul> Source Code <pre><code>(*\n    This function block reports the results from the tests using the built-in ADSLOGSTR functionality\n    provided by the Tc2_System library. This sends the result using ADS, which is consumed by the \"Error List\"\n    of Visual Studio (which can print Errors, Warnings and Messages).\n*)\nFUNCTION_BLOCK FB_AdsTestResultLogger IMPLEMENTS I_TestResultLogger\nVAR\n    TestResults : I_TestResults;\n\n    PrintingTestSuiteResultNumber : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestSuites);\n    PrintingTestSuiteTrigger : R_TRIG;\n\n    // This flag is set once the final end result has printed\n    PrintedFinalTestResults : BOOL;\n\n    // This flag is set once the test suites result have been printed\n    PrintedTestSuitesResults : BOOL;\nEND_VAR\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_AdsTestResultLogger.FB_init","title":"FB_init  <code>BOOL</code>","text":"<p>Inputs</p> <ul> <li> <code>bInitRetains</code>             \u2013              <p>if TRUE, the retain variables are initialized (warm start / cold start)</p> </li> <li> <code>bInCopyCode</code>             \u2013              <p>if TRUE, the instance afterwards gets moved into the copy code (online change)</p> </li> <li> <code>iTestResults</code> </li> </ul> Source Code <pre><code>METHOD FB_init : BOOL\nVAR_INPUT\n\tbInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)\n\tbInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)\n    iTestResults : I_TestResults;\nEND_VAR\n</code></pre> <pre><code>TestResults := iTestResults;\n</code></pre>"},{"location":"reference/tcunit/#FB_init.bInitRetains","title":"bInitRetains  <code>BOOL</code>","text":"<p>if TRUE, the retain variables are initialized (warm start / cold start)</p>"},{"location":"reference/tcunit/#FB_init.bInCopyCode","title":"bInCopyCode  <code>BOOL</code>","text":"<p>if TRUE, the instance afterwards gets moved into the copy code (online change)</p>"},{"location":"reference/tcunit/#FB_init.iTestResults","title":"iTestResults  <code>I_TestResults</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AdsTestResultLogger.LogTestSuiteResults","title":"LogTestSuiteResults  <code>PUBLIC</code>","text":"Source Code <pre><code>METHOD PUBLIC LogTestSuiteResults\nVAR\n    TcUnitTestResults : REFERENCE TO ST_TestSuiteResults;\n    StringToPrint : T_MaxString; \n    TestsInTestSuiteCounter : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\n    MaxNumberOfTestsToPrint : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\nVAR CONSTANT\n    TEST_STATUS_SKIP : STRING := 'SKIP';\n    TEST_STATUS_PASS : STRING := 'PASS';\n    TEST_STATUS_FAIL : STRING := 'FAIL';\nEND_VAR\n</code></pre> <pre><code>TcUnitTestResults REF= TestResults.GetTestSuiteResults();\n\nIF PrintingTestSuiteResultNumber &lt;= GVL_TcUnit.NumberOfInitializedTestSuites AND NOT PrintedTestSuitesResults THEN\n    PrintingTestSuiteTrigger(CLK := GVL_TcUnit.TestSuiteAddresses[PrintingTestSuiteResultNumber]^.AreAllTestsFinished());\n    IF PrintingTestSuiteTrigger.Q THEN\n        StringToPrint := CONCAT(STR1 := '| Test suite ID=',\n                                STR2 := UINT_TO_STRING(TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].Identity));\n        StringToPrint := CONCAT(STR1 := StringToPrint,\n                                STR2 :=  ' $'%s$'');\n\n        // Print test suite name and ID\n        GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_HINT,\n                                            MsgFmtStr := StringToPrint,\n                                            StrArg := TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].Name);\n\n        // Print number of tests/number of failed tests in test suite\n        StringToPrint := CONCAT(STR1 := '| ID=',\n                                             STR2 := UINT_TO_STRING(TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].Identity));\n        StringToPrint := CONCAT(STR1 := StringToPrint,\n                                             STR2 := ' number of tests=');\n        StringToPrint := CONCAT(STR1 := StringToPrint,\n                                             STR2 := UINT_TO_STRING(TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].NumberOfTests));\n        StringToPrint := CONCAT(STR1 := StringToPrint,\n                                             STR2 := ', number of failed tests=');\n        StringToPrint := CONCAT(STR1 := StringToPrint,\n                                             STR2 := UINT_TO_STRING(TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].NumberOfFailedTests));\n        StringToPrint := CONCAT(STR1 := StringToPrint,\n                                             STR2 := ', duration=');\n        StringToPrint := CONCAT(STR1 := StringToPrint,\n                                             STR2 := LREAL_TO_STRING(TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].Duration));\n\n        GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_HINT,\n                                            MsgFmtStr := StringToPrint,\n                                            StrArg := '');\n\n        // Print error if there are too many tests in the test suite\n        IF (TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].NumberOfTests &gt; GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite) THEN\n            MaxNumberOfTestsToPrint := GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite;\n        ELSE\n            MaxNumberOfTestsToPrint := TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].NumberOfTests;\n        END_IF\n\n        // Iterate and print all tests in test suite\n        FOR TestsInTestSuiteCounter := 1 TO MaxNumberOfTestsToPrint BY 1 DO\n            // Print test name\n            GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_HINT,\n                                                MsgFmtStr := '| Test name=%s',\n                                                StrArg := TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].TestName);\n            // Print test class name\n            GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_HINT,\n                                                MsgFmtStr := '| Test class name=%s',\n                                                StrArg := TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].TestClassName);\n\n            // Print test result/status (SUCCESS, FAILED, SKIPPED) + number of assertions made\n            IF TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].TestIsFailed THEN\n                StringToPrint := CONCAT(STR1 := '| Test status=', STR2 := TEST_STATUS_FAIL);\n            ELSIF TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].TestIsSkipped THEN\n                StringToPrint := CONCAT(STR1 := '| Test status=', STR2 := TEST_STATUS_SKIP);\n            ELSE\n                StringToPrint := CONCAT(STR1 := '| Test status=', STR2 := TEST_STATUS_PASS);\n            END_IF\n\n            StringToPrint := CONCAT(STR1 := StringToPrint, STR2 := ', number of asserts=');\n            StringToPrint := CONCAT(STR1 := StringToPrint, STR2 :=\n                                                 UINT_TO_STRING(TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].NumberOfAsserts));\n            StringToPrint := CONCAT(STR1 := StringToPrint, STR2 := ', duration=');\n            StringToPrint := CONCAT(STR1 := StringToPrint, STR2 :=\n                                                 LREAL_TO_STRING(TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].Duration));\t\t\t\t\t\t\t\t\t\t\t\t \n            GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_HINT,\n                                                MsgFmtStr := StringToPrint,\n                                                StrArg := '');\n\n            // Print assertion/failure message (if existing)\n            IF (LEN(STR := TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].FailureMessage) &gt; 0) THEN\n                GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_HINT,\n                                                    MsgFmtStr := '| Test assert message=%s',\n                                                    StrArg := TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].FailureMessage);\n            END_IF\n\n            // Print assertion/failure type (if existing)\n            IF TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].FailureType &lt;&gt; E_AssertionType.Type_UNDEFINED THEN\n                GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_HINT,\n                                                    MsgFmtStr := '| Test assert type=%s',\n                                                    StrArg := F_AssertionTypeToString(AssertionType :=\n                                                        TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].FailureType));\n            END_IF\n        END_FOR\n\n        // Print error message if there are too many tests in the test suite\n        IF (TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].NumberOfTests &gt; GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite) THEN\n            GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                                MsgFmtStr := 'Tests failed because the number of tests (%s',\n                                                StrArg := CONCAT(STR1 := TO_STRING(TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].NumberOfTests),\n                                                                              STR2 := CONCAT(STR1 := ') in the test suite $'',\n                                                                                                          STR2 := CONCAT(STR1 := TcUnitTestResults.TestSuiteResults[PrintingTestSuiteResultNumber].Name,\n                                                                                                                                      STR2 := CONCAT(STR1 := '$' are more than is defined in parameter $'GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite$' (',\n                                                                                                                                                                  STR2 := CONCAT(STR1 := UINT_TO_STRING(GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite),\n                                                                                                                                                                                              STR2 := '). Please increase this parameter.'))))));\n        END_IF\n\n        IF PrintingTestSuiteResultNumber = GVL_TcUnit.NumberOfInitializedTestSuites THEN\n            PrintedTestSuitesResults := TRUE;\n        ELSE\n            PrintingTestSuiteResultNumber := PrintingTestSuiteResultNumber + 1;\n        END_IF\n        PrintingTestSuiteTrigger(CLK := FALSE); // Reset trigger\n    END_IF\nEND_IF\n\n// Log end results once all test suites have finished running\nIF (GVL_TcUnit.NumberOfInitializedTestSuites = 0 OR PrintingTestSuiteResultNumber = GVL_TcUnit.NumberOfInitializedTestSuites)\n    AND NOT PrintedFinalTestResults AND TestResults.GetAreTestResultsAvailable() THEN\n    GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                        MsgFmtStr := '%s',\n                                        StrArg := '| ==========TESTS FINISHED RUNNING==========');\n    GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                        MsgFmtStr := '| Test suites: %s',\n                                        StrArg := UINT_TO_STRING(TcUnitTestResults.NumberOfTestSuites));\n    GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                        MsgFmtStr := '| Tests: %s',\n                                        StrArg := UINT_TO_STRING(TcUnitTestResults.NumberOfTestCases));\n    GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                        MsgFmtStr := '| Successful tests: %s',\n                                        StrArg := UINT_TO_STRING(TcUnitTestResults.NumberOfSuccessfulTestCases));\n    GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                        MsgFmtStr := '| Failed tests: %s',\n                                        StrArg := UINT_TO_STRING(TcUnitTestResults.NumberOfFailedTestCases));\n    GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                        MsgFmtStr := '| Duration: %s',\n                                        StrArg := LREAL_TO_STRING(TcUnitTestResults.Duration));                                        \n    GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                        MsgFmtStr := '%s',\n                                        StrArg := '| ======================================');\n    PrintedFinalTestResults := TRUE;\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_FileControl","title":"FB_FileControl","text":"<p>Methods</p> <ul> <li> <code>Close</code> </li> <li> <code>Delete</code> </li> <li> <code>Open</code> </li> <li> <code>Read</code> </li> <li> <code>Write</code> </li> </ul> Source Code <pre><code>// This functionblock can open, close, read, write and delete files on the local filesystem\nFUNCTION_BLOCK FB_FileControl\nVAR\n    FileAccessMode : SysFile.ACCESS_MODE := SysFile.AM_APPEND_PLUS; // Append_Plus creates the file if it doesn't exist yet. \n    FileHandle : SysFile.SysTypes.RTS_IEC_HANDLE;\nEND_VAR\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_FileControl.Close","title":"Close","text":"Source Code <pre><code>// Closes the currently opened file.\nMETHOD PUBLIC Close : SysFile.SysTypes.RTS_IEC_RESULT;\n</code></pre> <pre><code>IF FileHandle &lt;&gt; SysFile.SysTypes.RTS_INVALID_HANDLE THEN\n    Close := SysFile.SysFileClose(hFile := FileHandle);\nELSE\n    Close := SysDir.CmpErrors.Errors.ERR_INVALID_HANDLE;\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_FileControl.Delete","title":"Delete","text":"<p>Inputs</p> <ul> <li> <code>FileName</code> </li> </ul> Source Code <pre><code>// Deletes a file specified by name, if it exists.\nMETHOD PUBLIC Delete : SysFile.SysTypes.RTS_IEC_RESULT;\nVAR_INPUT\n    // File name can contain an absolute or relative path to the file. Path entries must be separated with a forward slash (/)\n    FileName : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>Delete := SysFile.SysFileDelete(szFileName := FileName);\n</code></pre>"},{"location":"reference/tcunit/#Delete.FileName","title":"FileName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_FileControl.Open","title":"Open","text":"<p>Inputs</p> <ul> <li> <code>FileName</code>             \u2013              <p>File name can contain an absolute or relative path to the file. Path entries must be separated with a Slash (/)</p> </li> <li> <code>FileAccessMode</code> </li> </ul> Source Code <pre><code>// Opens a file\nMETHOD PUBLIC Open : SysFile.SysTypes.RTS_IEC_RESULT;\nVAR_INPUT\n    FileName : T_MaxString := 'filepath/output.xml';  // File name can contain an absolute or relative path to the file. Path entries must be separated with a Slash (/)\n    FileAccessMode : SysFile.ACCESS_MODE := SysFile.ACCESS_MODE.AM_APPEND_PLUS;\nEND_VAR\n</code></pre> <pre><code>FileHandle := SysFile.SysFileOpen(szFile := Filename,\n                                  am := FileAccessMode,\n                                  pResult := ADR(Open));\n</code></pre>"},{"location":"reference/tcunit/#Open.FileName","title":"FileName  <code>T_MaxString</code>","text":"<p>File name can contain an absolute or relative path to the file. Path entries must be separated with a Slash (/)</p>"},{"location":"reference/tcunit/#Open.FileAccessMode","title":"FileAccessMode  <code>SysFile.ACCESS_MODE</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_FileControl.Read","title":"Read","text":"<p>Inputs</p> <ul> <li> <code>BufferPointer</code>             \u2013              <p>Call with ADR();</p> </li> <li> <code>Size</code>             \u2013              <p>Call with SIZEOF();</p> </li> </ul> <p>Outputs</p> <ul> <li> <code>FileSize</code> </li> </ul> Source Code <pre><code>// Reads a file from disk into the buffer\nMETHOD PUBLIC Read : SysFile.SysTypes.RTS_IEC_RESULT;\nVAR_INPUT\n    BufferPointer : POINTER TO BYTE; // Call with ADR();\n    Size : UDINT; // Call with SIZEOF(); \nEND_VAR\nVAR_OUTPUT\n    FileSize : SysFile.SysTypes.RTS_IEC_SIZE;\nEND_VAR\n</code></pre> <pre><code>IF FileHandle &lt;&gt; SysFile.SysTypes.RTS_INVALID_HANDLE THEN\n    FileSize := SysFile.SysFileRead(hFile := FileHandle, \n                                    pbyBuffer := BufferPointer,\n                                    ulSize := Size,\n                                    pResult := ADR(Read));\nELSE\n    Read := SysDir.CmpErrors.Errors.ERR_INVALID_HANDLE;\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#Read.BufferPointer","title":"BufferPointer  <code>POINTER TO BYTE</code>","text":"<p>Call with ADR();</p>"},{"location":"reference/tcunit/#Read.Size","title":"Size  <code>UDINT</code>","text":"<p>Call with SIZEOF();</p>"},{"location":"reference/tcunit/#Read.FileSize","title":"FileSize  <code>SysFile.SysTypes.RTS_IEC_SIZE</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_FileControl.Write","title":"Write","text":"<p>Inputs</p> <ul> <li> <code>BufferPointer</code>             \u2013              <p>Call with ADR();</p> </li> <li> <code>Size</code>             \u2013              <p>Call with SIZEOF();</p> </li> </ul> Source Code <pre><code>// Writes the contents of the buffer into a file.\nMETHOD PUBLIC Write : SysFile.SysTypes.RTS_IEC_RESULT;\nVAR_INPUT\n    BufferPointer : POINTER TO BYTE; // Call with ADR();\n    Size : UDINT; // Call with SIZEOF();\nEND_VAR\n</code></pre> <pre><code>IF FileHandle &lt;&gt; SysFile.SysTypes.RTS_INVALID_HANDLE THEN\n    SysFile.SysFileWrite(hFile := FileHandle,\n                         pbyBuffer := BufferPointer,\n                         ulSize := Size,\n                         pResult := ADR(Write));\nELSE\n    Write := SysDir.CmpErrors.Errors.ERR_INVALID_HANDLE;\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#Write.BufferPointer","title":"BufferPointer  <code>POINTER TO BYTE</code>","text":"<p>Call with ADR();</p>"},{"location":"reference/tcunit/#Write.Size","title":"Size  <code>UDINT</code>","text":"<p>Call with SIZEOF();</p>"},{"location":"reference/tcunit/#TcUnit.FB_StreamBuffer","title":"FB_StreamBuffer","text":"<p>Methods</p> <ul> <li> <code>Clear</code> </li> <li> <code>Copy</code> </li> <li> <code>CutOff</code> </li> <li> <code>Find</code> </li> <li> <code>FindBack</code> </li> <li> <code>SetBuffer</code> </li> </ul> <p>Properties</p> <ul> <li> <code>Append</code> </li> <li> <code>BufferSize</code> </li> <li> <code>Length</code> </li> </ul> Source Code <pre><code>// This functionblock acts as a stream buffer for use with FB_XmlControl\nFUNCTION_BLOCK FB_StreamBuffer \nVAR\n    _PointerToStringBuffer : POINTER TO BYTE;\n    _BufferSize : UDINT;\n    _Length : UDINT;\nEND_VAR\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_StreamBuffer.Clear","title":"Clear","text":"Source Code <pre><code>// Clears the buffer and sets the length to 0\nMETHOD PUBLIC Clear\nVAR\n\tCount : UDINT;\nEND_VAR\n</code></pre> <pre><code>IF (_PointerToStringBuffer = 0) OR (_BufferSize = 0) THEN\n    RETURN;\nEND_IF\n\nFOR Count := 0 TO (_BufferSize - 1) DO\n    _PointerToStringBuffer[Count] := 0;\nEND_FOR\n\n_Length := 0;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_StreamBuffer.Copy","title":"Copy","text":"<p>Inputs</p> <ul> <li> <code>StartPos</code> </li> <li> <code>EndPos</code> </li> </ul> <p>Outputs</p> <ul> <li> <code>CopyLen</code> </li> <li> <code>XmlError</code> </li> </ul> Source Code <pre><code>// Copies a string from the character buffer\nMETHOD PUBLIC Copy : T_MaxString\nVAR_INPUT\n    StartPos : UDINT;\n    EndPos : UDINT;\nEND_VAR\nVAR_OUTPUT\n    CopyLen : UDINT;\n    XmlError : E_XmlError;\nEND_VAR\nVAR\n    Loop : UDINT;\n    PointerToByteToCopy : POINTER TO BYTE;\n    PointerToBuffer : POINTER TO BYTE;\n    CurPos : UDINT;\nEND_VAR\n</code></pre> <pre><code>Loop := 0;\nPointerToByteToCopy := ADR(Copy);\nPointerToBuffer := _PointerToStringBuffer + StartPos - 1;\n\nWHILE(Loop &lt; SIZEOF(Copy)) AND (StartPos - 1 + Loop &lt; _Length) AND (StartPos + Loop &lt; EndPos) DO\n    PointerToByteToCopy^ := PointerToBuffer^;\n    Loop := Loop + 1;\n    PointerToByteToCopy := ADR(Copy) + Loop;\n    PointerToBuffer := _PointerToStringBuffer + StartPos + Loop -1;\nEND_WHILE;\n\nIF Loop = SIZEOF(Copy) THEN\n    XmlError := E_XmlError.ErrorStringLen;\nELSIF StartPos - 1 + Loop = _Length THEN\n    XmlError := E_XmlError.ErrorMaxBufferLen;\nELSE\n    XmlError := E_XmlError.OK;\nEND_IF;\n\nPointerToByteToCopy^ := 0;\nCopyLen :=  Loop;\n</code></pre>"},{"location":"reference/tcunit/#Copy.StartPos","title":"StartPos  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#Copy.EndPos","title":"EndPos  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#Copy.CopyLen","title":"CopyLen  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#Copy.XmlError","title":"XmlError  <code>E_XmlError</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_StreamBuffer.CutOff","title":"CutOff  <code>T_MaxString</code> <code>PUBLIC</code>","text":"<p>Inputs</p> <ul> <li> <code>StartPos</code> </li> </ul> <p>Outputs</p> <ul> <li> <code>CutLen</code> </li> <li> <code>XmlError</code> </li> </ul> Source Code <pre><code>METHOD PUBLIC CutOff : T_MaxString\nVAR_INPUT\n    StartPos : UDINT;\nEND_VAR\nVAR_OUTPUT\n    CutLen : UDINT; \n    XmlError : E_XmlError;\nEND_VAR\nVAR\n    Loop : UDINT;\n    PointerToByteToCut : POINTER TO BYTE;\n    PointerToByteBuffer : POINTER TO BYTE;\nEND_VAR\n</code></pre> <pre><code>Loop := 0;\nPointerToByteToCut := ADR(CutOff);\nPointerToByteBuffer := _PointerToStringBuffer + StartPos - 1;\n\nWHILE PointerToByteBuffer^ &lt;&gt; 0 AND(Loop &lt; SIZEOF(CutOff)) AND StartPos -1  + Loop &lt; _Length DO\n    PointerToByteToCut^ := PointerToByteBuffer^;\n    Loop := Loop + 1;\n    PointerToByteToCut := ADR(CutOff) + Loop;\n    PointerToByteBuffer := _PointerToStringBuffer + StartPos - 1 + Loop;\nEND_WHILE;\n\nIF PointerToByteBuffer^ = 0 THEN\n    XmlError := E_XmlError.OK;\nELSIF Loop = SIZEOF(CutOff) THEN\n    XmlError := E_XmlError.ErrorStringLen;\nELSIF StartPos - 1 + Loop = _Length THEN\n    XmlError := E_XmlError.ErrorMaxBufferLen;\nEND_IF;\n\nPointerToByteToCut^ := 0;\n_Length := StartPos -1;\n\nPointerToByteBuffer := _PointerToStringBuffer + StartPos - 1;\nPointerToByteBuffer^ := 0;\n\nCutLen := Loop;\n</code></pre>"},{"location":"reference/tcunit/#CutOff.StartPos","title":"StartPos  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#CutOff.CutLen","title":"CutLen  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#CutOff.XmlError","title":"XmlError  <code>E_XmlError</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_StreamBuffer.Find","title":"Find","text":"<p>Inputs</p> <ul> <li> <code>SearchString</code> </li> <li> <code>StartPos</code> </li> </ul> Source Code <pre><code>(* \n    Find a searchstring in the buffer and returns its position.\n    It's possible to add a preffered startposition within buffer\n*)\nMETHOD PUBLIC Find : UDINT\nVAR_INPUT\n    SearchString : STRING;\n    StartPos : UDINT;\nEND_VAR\nVAR\n    Loop : UDINT;\n    Search : UDINT;\n    PointerToBuffer : POINTER TO BYTE;\n    PointerToSearch : POINTER TO BYTE;\nEND_VAR\n</code></pre> <pre><code>Loop := 0;\nSearch := 0;\n\nPointerToBuffer := _PointerToStringBuffer + StartPos;\nPointerToSearch := ADR(SearchString);\n\nWHILE(PointerToSearch^ &lt;&gt; 0 ) AND Loop + StartPos &lt; _Length DO\n    IF PointerToBuffer^ &lt;&gt; PointerToSearch^ THEN\n        Loop := Loop + 1;\n        PointerToBuffer := _PointerToStringBuffer + StartPos + Loop;\n        PointerToSearch := ADR(SearchString);\n        Search := 0;\n    ELSE\n        Search := Search + 1;\n        PointerToBuffer := _PointerToStringBuffer + StartPos + Loop + Search;\n        PointerToSearch := ADR(SearchString ) + Search;\n    END_IF;\nEND_WHILE;\nFind := Loop + 1 + StartPos;\n</code></pre>"},{"location":"reference/tcunit/#Find.SearchString","title":"SearchString  <code>STRING</code>","text":""},{"location":"reference/tcunit/#Find.StartPos","title":"StartPos  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_StreamBuffer.FindBack","title":"FindBack  <code>UDINT</code> <code>PUBLIC</code>","text":"<p>Inputs</p> <ul> <li> <code>SearchString</code> </li> </ul> Source Code <pre><code>METHOD PUBLIC FindBack : UDINT\nVAR_INPUT\n    SearchString : T_MaxString;\nEND_VAR\nVAR\n    Loop : UDINT;\n    Search : UDINT;\n    PointerToBuffer : POINTER TO BYTE;\n    PointerToSearch : POINTER TO BYTE;\nEND_VAR\n</code></pre> <pre><code>Loop := 0;\nSearch := 0;\n\nPointerToBuffer := _PointerToStringBuffer + _Length;\nPointerToSearch := ADR(SearchString);\n\nWHILE(PointerToSearch^ &lt;&gt; 0) AND Loop &lt; _Length DO\n    IF PointerToBuffer^ &lt;&gt; PointerToSearch^ THEN\n        Loop := Loop + 1;\n        PointerToBuffer := _PointerToStringBuffer + _Length - Loop;\n        PointerToSearch := ADR(SearchString);\n        Search := 0;\n    ELSE\n        Search := Search + 1;\n        PointerToBuffer := _PointerToStringBuffer + _Length - Loop + Search;\n        PointerToSearch := ADR(SearchString ) + Search;\n    END_IF;\nEND_WHILE;\nFindBack := _Length - Loop + 1;\n</code></pre>"},{"location":"reference/tcunit/#FindBack.SearchString","title":"SearchString  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_StreamBuffer.SetBuffer","title":"SetBuffer  <code>BOOL</code> <code>PUBLIC</code>","text":"<p>Inputs</p> <ul> <li> <code>PointerToBufferAddress</code>             \u2013              <p>Set buffer address (ADR ...)</p> </li> <li> <code>SizeOfBuffer</code>             \u2013              <p>Set buffer size (SIZEOF ...)</p> </li> </ul> Source Code <pre><code>METHOD PUBLIC SetBuffer : BOOL;\nVAR_INPUT\n    PointerToBufferAddress : POINTER TO BYTE; // Set buffer address (ADR ...)\n    SizeOfBuffer : UDINT; // Set buffer size (SIZEOF ...)\nEND_VAR\n</code></pre> <pre><code>IF (PointerToBufferAddress = 0) OR (SizeOfBuffer = 0) THEN\n    SetBuffer := FALSE;\n    RETURN;\nEND_IF;\n\n_BufferSize := SizeOfBuffer;\n_PointerToStringBuffer := PointerToBufferAddress;\n\nSetBuffer := TRUE;\n</code></pre>"},{"location":"reference/tcunit/#SetBuffer.PointerToBufferAddress","title":"PointerToBufferAddress  <code>POINTER TO BYTE</code>","text":"<p>Set buffer address (ADR ...)</p>"},{"location":"reference/tcunit/#SetBuffer.SizeOfBuffer","title":"SizeOfBuffer  <code>UDINT</code>","text":"<p>Set buffer size (SIZEOF ...)</p>"},{"location":"reference/tcunit/#TcUnit.FB_StreamBuffer.Append","title":"Append  <code>Set</code>","text":"Source Code <pre><code>ByteIn := ADR(Append); \nByteBuffer := _PointerToStringBuffer + _Length; // set start address\n\nWHILE ByteIn^ &lt;&gt; 0 AND (_Length &lt; _BufferSize ) DO\n    ByteBuffer^ := ByteIn^; //Copy the 1st byte\n    _Length := _Length + 1; // set new buffer length\n    ByteIn := ByteIn + 1; // calculate new start address \n    ByteBuffer := ByteBuffer + 1; // calculate new start address \nEND_WHILE;\n\nByteBuffer := _PointerToStringBuffer + _Length; // String End\nByteBuffer^ := 0; // null terminated string\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_StreamBuffer.BufferSize","title":"BufferSize  <code>Get</code>","text":"Source Code <pre><code>BufferSize := _BufferSize;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_StreamBuffer.Length","title":"Length  <code>Get/Set</code>","text":"Source Code <pre><code>Length := _Length;\n</code></pre> <pre><code>_Length := Length;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_xUnitXmlPublisher","title":"FB_xUnitXmlPublisher","text":"<p>Methods</p> <ul> <li> <code>DeleteOpenWriteClose</code> </li> <li> <code>FB_Init</code> </li> <li> <code>Initialised</code> </li> <li> <code>LogTestSuiteResults</code> </li> </ul> Source Code <pre><code>// Publishes test results into an xUnit compatible Xml file\nFUNCTION_BLOCK FB_xUnitXmlPublisher IMPLEMENTS I_TestResultLogger\nVAR\n    // Dependency injection via FB_Init\n    TestResults : I_TestResults;\n\n    // File access mode\n    AccessMode : SysFile.ACCESS_MODE := SysFile.AM_WRITE_PLUS;\n\n    File : FB_FileControl;\n    Xml : FB_XMLControl;\n    BufferInitialised : BOOL := FALSE;\n    Buffer : ARRAY [0..(GVL_Param_TcUnit.XUnitBufferSize - 1)] OF BYTE;\n    WritingTestSuiteResultNumber : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestSuites);\n    PublishTrigger : R_TRIG;\nEND_VAR\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_xUnitXmlPublisher.DeleteOpenWriteClose","title":"DeleteOpenWriteClose","text":"Source Code <pre><code>(*\n    Deletes the former file (if it exists).\n    Opens the file, writes the buffer and closes it.\n*)\nMETHOD PRIVATE DeleteOpenWriteClose : SysFile.SysTypes.RTS_IEC_RESULT;\n</code></pre> <pre><code>DeleteOpenWriteClose := SysDir.CmpErrors.Errors.ERR_OK;\nIF Initialised() THEN\n    DeleteOpenWriteClose := MAX(DeleteOpenWriteClose, File.Delete(Filename := GVL_Param_TcUnit.xUnitFilePath));\n    DeleteOpenWriteClose := MAX(DeleteOpenWriteClose, File.Open(Filename := GVL_Param_TcUnit.xUnitFilePath, FileAccessMode := AccessMode));\n    DeleteOpenWriteClose := MAX(DeleteOpenWriteClose, File.Write(BufferPointer := ADR(Buffer), Xml.Length)); \n    DeleteOpenWriteClose := MAX(DeleteOpenWriteClose, File.Close());\nELSE\n    DeleteOpenWriteClose := SysDir.CmpErrors.Errors.ERR_NOBUFFER;\nEND_IF;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_xUnitXmlPublisher.FB_Init","title":"FB_Init","text":"<p>Inputs</p> <ul> <li> <code>bInitRetains</code>             \u2013              <p>True</p> <p>the retain variables are initialized (reset warm / reset cold)</p> </li> <li> <code>bInCopyCode</code>             \u2013              <p>True</p> <p>the instance will be copied to the copy code afterward (online change)</p> </li> <li> <code>iTestResults</code>             \u2013              <p>Interface dependency injection</p> </li> </ul> Source Code <pre><code>(*\n    FB_Init is always available implicitly AND it is used primarily FOR initialization.\n    The return value is not evaluated. For a specific influence, you can also declare the\n    methods explicitly and provide additional code there with the standard initialization\n    code. You can evaluate the return value.\n*)\nMETHOD FB_Init: BOOL\nVAR_INPUT\n    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)\n    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)\n    iTestResults : I_TestResults; // Interface dependency injection\nEND_VAR\n</code></pre> <pre><code>// Set buffer and flag\nXml.SetBuffer(PointerToBuffer := ADR(Buffer), SizeOfBuffer := SIZEOF(Buffer));\n\n// Set buffer initialised\nBufferInitialised := TRUE;\n\n// Set testresult interface\nTHIS^.TestResults := iTestResults;\n</code></pre>"},{"location":"reference/tcunit/#FB_Init.bInitRetains","title":"bInitRetains  <code>BOOL</code>","text":"<p>True</p> <p>the retain variables are initialized (reset warm / reset cold)</p>"},{"location":"reference/tcunit/#FB_Init.bInCopyCode","title":"bInCopyCode  <code>BOOL</code>","text":"<p>True</p> <p>the instance will be copied to the copy code afterward (online change)</p>"},{"location":"reference/tcunit/#FB_Init.iTestResults","title":"iTestResults  <code>I_TestResults</code>","text":"<p>Interface dependency injection</p>"},{"location":"reference/tcunit/#TcUnit.FB_xUnitXmlPublisher.Initialised","title":"Initialised  <code>BOOL</code> <code>PRIVATE</code>","text":"Source Code <pre><code>METHOD PRIVATE Initialised : BOOL\n</code></pre> <pre><code>Initialised := THIS^.BufferInitialised;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_xUnitXmlPublisher.LogTestSuiteResults","title":"LogTestSuiteResults","text":"Source Code <pre><code>(*\n    This method is responsible for the entire generation of the output file. \n    The output of the xml writer is NOT beautified.\n\n    When new data is available, feel free to add it to the report\n*)\nMETHOD PUBLIC LogTestSuiteResults\nVAR\n    UnitTestResults : REFERENCE TO ST_TestSuiteResults;\n    CurrentSuiteNumber : UINT;\n    CurrentTestCount : UINT;\nEND_VAR\nVAR CONSTANT\n    TEST_STATUS_SKIP : STRING := 'SKIP';\n    TEST_STATUS_PASS : STRING := 'PASS';\n    TEST_STATUS_FAIL : STRING := 'FAIL';\nEND_VAR\n</code></pre> <pre><code>UnitTestResults REF= TestResults.GetTestSuiteResults();\n\n// Only publish once if \"GVL_Param_TcUnit.xUnitEnablePublish\" is enabled and all test results are stored.\nPublishTrigger(CLK := (TestResults.GetAreTestResultsAvailable() AND GVL_Param_TcUnit.xUnitEnablePublish));\nIF PublishTrigger.Q THEN\n\n    // &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n    Xml.WriteDocumentHeader(Header := '&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;');\n\n    // &lt;testsuites&gt;\n    Xml.NewTag('testsuites');\n    Xml.NewParameter('disabled', '');\n    Xml.NewParameter('failures', UINT_TO_STRING(UnitTestResults.NumberOfFailedTestCases));\n    Xml.NewParameter('tests', UINT_TO_STRING(UnitTestResults.NumberOfSuccessfulTestCases));\n    Xml.NewParameter('time', LREAL_TO_STRING(UnitTestResults.Duration));\n\n    FOR CurrentSuiteNumber := 1 TO UnitTestResults.NumberOfTestSuites BY 1 DO\n        // &lt;testsuite&gt;\n        Xml.NewTag('testsuite');\n        Xml.NewParameter('id', UINT_TO_STRING(UnitTestResults.TestSuiteResults[CurrentSuiteNumber].Identity));\n        Xml.NewParameter('name', UnitTestResults.TestSuiteResults[CurrentSuiteNumber].name);\n        Xml.NewParameter('tests', UINT_TO_STRING(UnitTestResults.TestSuiteResults[CurrentSuiteNumber].NumberOfTests));\n        Xml.NewParameter('failures', UINT_TO_STRING(UnitTestResults.TestSuiteResults[CurrentSuiteNumber].NumberOfFailedTests));\n        Xml.NewParameter('time', LREAL_TO_STRING(UnitTestResults.TestSuiteResults[CurrentSuiteNumber].Duration));\n\n        FOR CurrentTestCount := 1 TO UnitTestResults.TestSuiteResults[CurrentSuiteNumber].NumberOfTests BY 1 DO\n            // &lt;testcase&gt;\n            Xml.NewTag('testcase');\n            Xml.NewParameter('name', UnitTestResults.TestSuiteResults[CurrentSuiteNumber].TestCaseResults[CurrentTestCount].TestName);\n            Xml.NewParameter('classname', UnitTestResults.TestSuiteResults[CurrentSuiteNumber].TestCaseResults[CurrentTestCount].TestClassName);\n            Xml.NewParameter('time', LREAL_TO_STRING(UnitTestResults.TestSuiteResults[CurrentSuiteNumber].TestCaseResults[CurrentTestCount].Duration));\n\n            IF UnitTestResults.TestSuiteResults[CurrentSuiteNumber].TestCaseResults[CurrentTestCount].TestIsFailed THEN\n                Xml.NewParameter('status', TEST_STATUS_FAIL);\n            ELSIF UnitTestResults.TestSuiteResults[CurrentSuiteNumber].TestCaseResults[CurrentTestCount].TestIsSkipped THEN\n                Xml.NewParameter('status', TEST_STATUS_SKIP);\n            ELSE\n                Xml.NewParameter('status', TEST_STATUS_PASS);\n            END_IF\n\n            // Determine testcase fail or success\n            IF UnitTestResults.TestSuiteResults[CurrentSuiteNumber].TestCaseResults[CurrentTestCount].FailureType &lt;&gt; E_AssertionType.Type_UNDEFINED THEN\n                (* In case of fail \n                    &lt;failure message=\"Values differ\" type=\"BYTE\" /&gt;\n                *)\n                Xml.NewTag('failure');\n                Xml.NewParameter('message', UnitTestResults.TestSuiteResults[CurrentSuiteNumber].TestCaseResults[CurrentTestCount].FailureMessage);\n                Xml.NewParameter('type', F_AssertionTypeToString(UnitTestResults.TestSuiteResults[CurrentSuiteNumber].TestCaseResults[CurrentTestCount].FailureType));       \n                // Close failure tag\n                Xml.CloseTag();\n            ELSE\n            // In case of success\n            Xml.NewTagData('');\n\n            END_IF\n            // Close testcase tag\n            Xml.CloseTag();\n\n        END_FOR\n        // Close testsuite tag\n        Xml.CloseTag();\n\n    END_FOR\n    // Close testsuites\n    Xml.CloseTag();\n\n    // Delete, open, save and close the file\n    DeleteOpenWriteClose();\n\n    // Clear the internal buffer\n    Xml.ClearBuffer();\n\n    // Inform user\n    GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_HINT,\n                                        msgFmtStr := '%s',\n                                        strArg := '| ==========TEST RESULTS EXPORTED===========');\n\n    GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_HINT,\n                                        msgFmtStr :=  '| Location: %s ',\n                                        strArg := GVL_Param_TcUnit.xUnitFilePath);\n\n    GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_HINT,\n                                        MsgFmtStr := '%s',\n                                        StrArg := '| ======================================');\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestResults","title":"FB_TestResults","text":"<p>Methods</p> <ul> <li> <code>GetAreTestResultsAvailable</code> </li> <li> <code>GetTestSuiteResults</code> </li> </ul> Source Code <pre><code>// This function block holds results of the complete test run, i.e. results for all test suites\nFUNCTION_BLOCK FB_TestResults IMPLEMENTS I_TestResults\nVAR\n    // Test results\n    TestSuiteResults : ST_TestSuiteResults;\n\n    // Misc variables\n    StoringTestSuiteResultNumber : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestSuites);\n    StoringTestSuiteTrigger : R_TRIG;\n    StoredTestSuiteResults : BOOL;\n    StoredGeneralTestResults : BOOL;\n    NumberOfTestsToAnalyse : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\nVAR_TEMP\n    TestSuiteName : T_MaxString;\n    TestName : T_MaxString;\n\n    TestsInTestSuiteCounter : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\n\n    TestToBeStored : FB_Test;\n    GeneralTestResultsTestSuitesCounter : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestSuites);\nEND_VAR\n</code></pre> <pre><code>// The body of the function block stores the test results\nIF StoringTestSuiteResultNumber &lt;= GVL_TcUnit.NumberOfInitializedTestSuites AND NOT StoredTestSuiteResults THEN\n\tStoringTestSuiteTrigger(CLK := GVL_TcUnit.TestSuiteAddresses[StoringTestSuiteResultNumber]^.AreAllTestsFinished());\n\n    IF StoringTestSuiteTrigger.Q THEN\n        // Remove everything except the program name + \".\" + test suite name\n        TestSuiteName := F_RemoveInstancePathAndProjectNameFromTestInstancePath(TestInstancePath := GVL_TcUnit.TestSuiteAddresses[StoringTestSuiteResultNumber]^.GetInstancePath());\n\n        // Store test suite name and ID\n        TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].Name := TestSuiteName;\n        TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].Identity := StoringTestSuiteResultNumber - 1;\n\n        // Store number of tests in test suite\n        TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].NumberOfTests :=\n            GVL_TcUnit.TestSuiteAddresses[StoringTestSuiteResultNumber]^.GetNumberOfTests();\n\n        // Store number of failed tests in test suite\n        TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].NumberOfFailedTests :=\n            GVL_TcUnit.TestSuiteAddresses[StoringTestSuiteResultNumber]^.GetNumberOfFailedTests();\n\n        // Store the duration\n        TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].Duration :=\n            GVL_TcUnit.TestSuiteAddresses[StoringTestSuiteResultNumber]^.GetDuration();\n\n        // Limit the test analyse to the max array limit of 'Tests[]' in FB_TestSuite\n        NumberOfTestsToAnalyse := GVL_TcUnit.TestSuiteAddresses[StoringTestSuiteResultNumber]^.GetNumberOfTestsToAnalyse();\n\n        // Iterate and print all tests in test suite\n        FOR TestsInTestSuiteCounter := 1 TO NumberOfTestsToAnalyse BY 1 DO\n            TestToBeStored := GVL_TcUnit.TestSuiteAddresses[StoringTestSuiteResultNumber]^.GetTestByPosition(TestsInTestSuiteCounter);\n            // Store test name\n            TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].TestName := TestToBeStored.GetName();\n\n            // Store test class name\n            TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].TestClassName :=\n                F_RemoveInstancePathAndProjectNameFromTestInstancePath(GVL_TcUnit.TestSuiteAddresses[StoringTestSuiteResultNumber]^.GetInstancePath());\n\n            // Store whether the test has failed\n            TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].TestIsFailed :=\n                TestToBeStored.IsFailed();\n\n            // Store whether the test was skipped\n            TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].TestIsSkipped :=\n                TestToBeStored.IsSkipped();\n\n            // Store the (first failed) assertion message\n            TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].FailureMessage :=\n                TestToBeStored.GetAssertionMessage();\n\n            // Store the (first failed) assertion type\n            TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].FailureType :=\n                TestToBeStored.GetAssertionType();\n\n            // Store number of assertions made\n            TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].NumberOfAsserts :=\n                TestToBeStored.GetNumberOfAssertions();\n\n            // Store the duration of the test\n            TestSuiteResults.TestSuiteResults[StoringTestSuiteResultNumber].TestCaseResults[TestsInTestSuiteCounter].Duration :=\n                TestToBeStored.GetDuration();\n        END_FOR\n\n        IF StoringTestSuiteResultNumber = GVL_TcUnit.NumberOfInitializedTestSuites THEN\n            StoredTestSuiteResults := TRUE;\n        ELSE\n            StoringTestSuiteResultNumber := StoringTestSuiteResultNumber + 1;\n        END_IF\n        StoringTestSuiteTrigger(CLK := FALSE); // Reset trigger\n    END_IF\nEND_IF\n\n(* If all test suites have finished running, store the general test results.\n   Take care OF the special CASE where no tests have NOT yet been defined *)\nIF GVL_TcUnit.NumberOfInitializedTestSuites = 0 AND (NOT StoredGeneralTestResults) THEN\n    StoredGeneralTestResults := TRUE;\n    StoredTestSuiteResults := TRUE;\nELSIF StoringTestSuiteResultNumber = GVL_TcUnit.NumberOfInitializedTestSuites AND_THEN\n    GVL_TcUnit.TestSuiteAddresses[StoringTestSuiteResultNumber]^.AreAllTestsFinished() AND StoredTestSuiteResults AND (NOT StoredGeneralTestResults) THEN\n    TestSuiteResults.NumberOfTestSuites := GVL_TcUnit.NumberOfInitializedTestSuites;\n\tGVL_TcUnit.Duration := LWORD_TO_LREAL(F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter) - GVL_TcUnit.StartedAt) * GVL_TcUnit.HundredNanosecondToSecond; // Seconds\n    TestSuiteResults.Duration := GVL_TcUnit.Duration;\n    FOR GeneralTestResultsTestSuitesCounter := 1 TO GVL_TcUnit.NumberOfInitializedTestSuites BY 1 DO\n        TestSuiteResults.NumberOfTestCases := TestSuiteResults.NumberOfTestCases + TestSuiteResults.TestSuiteResults[GeneralTestResultsTestSuitesCounter].NumberOfTests;\n        TestSuiteResults.NumberOfSuccessfulTestCases := TestSuiteResults.NumberOfSuccessfulTestCases +\n                                                        (TestSuiteResults.TestSuiteResults[GeneralTestResultsTestSuitesCounter].NumberOfTests -\n                                                         TestSuiteResults.TestSuiteResults[GeneralTestResultsTestSuitesCounter].NumberOfFailedTests);\n        TestSuiteResults.NumberOfFailedTestCases := TestSuiteResults.NumberOfFailedTestCases + TestSuiteResults.TestSuiteResults[GeneralTestResultsTestSuitesCounter].NumberOfFailedTests;\n    END_FOR\n    StoredGeneralTestResults := TRUE;\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestResults.GetAreTestResultsAvailable","title":"GetAreTestResultsAvailable","text":"Source Code <pre><code>// Returns whether the storing of the test results is finished\nMETHOD PUBLIC GetAreTestResultsAvailable : BOOL\n</code></pre> <pre><code>GetAreTestResultsAvailable := (StoredTestSuiteResults AND StoredGeneralTestResults);\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestResults.GetTestSuiteResults","title":"GetTestSuiteResults  <code>REFERENCE TO ST_TestSuiteResults</code> <code>PUBLIC</code>","text":"Source Code <pre><code>METHOD PUBLIC GetTestSuiteResults : REFERENCE TO ST_TestSuiteResults;\n</code></pre> <pre><code>GetTestSuiteResults REF=TestSuiteResults;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_AdjustAssertFailureMessageToMax253CharLength","title":"FB_AdjustAssertFailureMessageToMax253CharLength","text":"<p>Inputs</p> <ul> <li> <code>TestInstancePath</code> </li> <li> <code>TestMessage</code> </li> </ul> <p>Outputs</p> <ul> <li> <code>TestInstancePathProcessed</code> </li> <li> <code>TestMessageProcessed</code> </li> </ul> Source Code <pre><code>(*\n    This function block is responsible for making sure that the asserted test instance path and test message are not\n    loo long. The total printed message can not be more than 253 characters long.\n*)\nFUNCTION_BLOCK FB_AdjustAssertFailureMessageToMax253CharLength\nVAR_INPUT\n    TestInstancePath : T_MaxString;\n    TestMessage : T_MaxString;\nEND_VAR\nVAR_OUTPUT\n    TestInstancePathProcessed : T_MaxString;\n    TestMessageProcessed : T_MaxString;\nEND_VAR\nVAR_TEMP\n    TestInstancePathTemporary : T_MaxString;\nEND_VAR\nVAR CONSTANT\n    MESSAGE_FORMATTED_STRING_MAX_NUMBER_OF_CHARACTERS : INT := 253; // This is actually 254, but if StrArg-argument is used (which it is in TcUnit) it is 253.\n    TEST_NAME_TOO_LONG : STRING := '...TestName too long';\n    TEST_MESSAGE_TOO_LONG : STRING := '...TestMsg too long';\nEND_VAR\n</code></pre> <pre><code>// Check if any of the two strings are too long (or the combination of them)\n\n// All OK\nIF (LEN(STR := TestInstancePath) + LEN(STR := TestMessage)) &lt;= MESSAGE_FORMATTED_STRING_MAX_NUMBER_OF_CHARACTERS THEN\n    TestInstancePathProcessed := TestInstancePath;\n    TestMessageProcessed := TestMessage;\n// If test instance path is longer than 253 chars, shorten it down to 253 characters and additionally with the length of the '...TestName too long'. Add the text '...TestName too long' to the test instance path. Leave no characters for the message.\nELSIF LEN(STR := TestInstancePath) &gt; MESSAGE_FORMATTED_STRING_MAX_NUMBER_OF_CHARACTERS THEN\n    TestInstancePathTemporary := LEFT(STR := TestInstancePath,\n                                      SIZE := (MESSAGE_FORMATTED_STRING_MAX_NUMBER_OF_CHARACTERS - LEN(STR := TEST_NAME_TOO_LONG)));\n    TestInstancePathProcessed := CONCAT(STR1 := TestInstancePathTemporary,\n                                        STR2 := TEST_NAME_TOO_LONG);\n    TestMessageProcessed := '';\n// If test message is too long (so we cant fit the text \"...TestMsg too long\" to the end of it) , shorten it (so that we can fit the text)\nELSIF (MESSAGE_FORMATTED_STRING_MAX_NUMBER_OF_CHARACTERS - LEN(STR := TEST_MESSAGE_TOO_LONG)) &gt;= LEN(STR := TestInstancePath) THEN\n    TestInstancePathProcessed := TestInstancePath;\n    TestMessageProcessed := LEFT(STR := TestMessage,\n                                 SIZE := (MESSAGE_FORMATTED_STRING_MAX_NUMBER_OF_CHARACTERS - LEN(STR := TEST_MESSAGE_TOO_LONG) - LEN(STR := TestInstancePathProcessed)));\n    TestMessageProcessed := CONCAT(STR1 := TestMessageProcessed,\n                                   STR2 := TEST_MESSAGE_TOO_LONG);\n// If test instance path is too long (length is between 233 and 253 characters long), shorten it and add the text '...TestName too long'. Leave no characters for the message\nELSE\n    TestInstancePathTemporary := LEFT(STR := TestInstancePath,\n                                      SIZE := (MESSAGE_FORMATTED_STRING_MAX_NUMBER_OF_CHARACTERS - LEN(STR := TEST_NAME_TOO_LONG)));\n    TestInstancePathProcessed := CONCAT(STR1 := TestInstancePathTemporary,\n                                        STR2 := TEST_NAME_TOO_LONG);\n    TestMessageProcessed := '';\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_AdjustAssertFailureMessageToMax253CharLength.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AdjustAssertFailureMessageToMax253CharLength.TestMessage","title":"TestMessage  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AdjustAssertFailureMessageToMax253CharLength.TestInstancePathProcessed","title":"TestInstancePathProcessed  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AdjustAssertFailureMessageToMax253CharLength.TestMessageProcessed","title":"TestMessageProcessed  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertResultStatic","title":"FB_AssertResultStatic","text":"<p>Methods</p> <ul> <li> <code>AddAssertResult</code> </li> <li> <code>CopyDetectionCountAndResetDetectionCountInThisCycle</code> </li> <li> <code>CreateAssertResultInstance</code> </li> <li> <code>GetDetectionCount</code> </li> <li> <code>GetDetectionCountThisCycle</code> </li> <li> <code>GetNumberOfAssertsForTest</code> </li> <li> <code>ReportResult</code> </li> </ul> Source Code <pre><code>(*\n    This function block is responsible for keeping track of which asserts that have been made. The reason we need to\n    keep track of these is because if the user does the same assert twice (because of running a test suite over several\n    PLC-cycles) we want to know it so we don't print several times (if the assert fails).\n    An instance of an assert is keyed/identified with the following parameters as key:\n    - Value of expected\n    - Value of actual\n    - Message (string)\n    - Test instance path (string)\n*)\nFUNCTION_BLOCK FB_AssertResultStatic\nVAR\n    // The total number of instances of each of the \"AssertResults\"\n    AssertResults : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite] OF ST_AssertResult;\n\n    // The total number of unique asserts\n    TotalAsserts : UINT := 0;\n\n    // Function block to get the current task cycle\n    GetCurrentTaskIndex : GETCURTASKINDEX;\n\n    // The total number of instances of each of the \"AssertResults\"\n    AssertResultInstances : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite] OF ST_AssertResultInstances;\n\n    // The last PLC cycle count\n    CycleCount : UDINT;\n\n    // Only run first cycle\n    FirstCycleExecuted : BOOL;\nEND_VAR\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_AssertResultStatic.AddAssertResult","title":"AddAssertResult  <code>PRIVATE</code>","text":"<p>Inputs</p> <ul> <li> <code>ExpectedSize</code> </li> <li> <code>ExpectedTypeClass</code> </li> <li> <code>ExpectedValue</code> </li> <li> <code>ActualSize</code> </li> <li> <code>ActualTypeClass</code> </li> <li> <code>ActualValue</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD PRIVATE AddAssertResult\nVAR_INPUT\n    ExpectedSize : UDINT;\n    ExpectedTypeClass : IBaseLibrary.TypeClass;\n    ExpectedValue : POINTER TO BYTE;\n    ActualSize : UDINT;\n    ActualTypeClass : IBaseLibrary.TypeClass;\n    ActualValue : POINTER TO BYTE;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR_INST\n\tAssertResultOverflow : BOOL := FALSE;\nEND_VAR\nVAR\n    sErrorString : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>IF TotalAsserts &lt; GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite THEN\n    TotalAsserts := TotalAsserts + 1;\n    AssertResults[TotalAsserts].Expected := F_AnyToUnionValue(AnySize := ExpectedSize, AnyTypeClass := ExpectedTypeClass, AnyValue := ExpectedValue);\n    AssertResults[TotalAsserts].Actual := F_AnyToUnionValue(AnySize := ActualSize, AnyTypeClass := ActualTypeClass, AnyValue := ActualValue);\n    AssertResults[TotalAsserts].Message := Message;\n    AssertResults[TotalAsserts].TestInstancePath := TestInstancePath;\nELSE\n    IF NOT AssertResultOverflow THEN\n        sErrorString := CONCAT(STR1 := F_GetTestSuiteNameFromTestInstancePath(TestInstancePath := TestInstancePath),\n                               STR2 := '. Max number of assertions exceeded. Check parameter MaxNumberOfAssertsForEachTestSuite.');\n\t\tGVL_TcUnit.AdsMessageQueue.WriteLog(msgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n\t\t\t\t\t\t\t\t\t\t\tmsgFmtStr := sErrorString,\n\t\t\t\t\t\t\t\t\t\t\tstrArg := '');\n\t\tAssertResultOverflow := TRUE;\n\tEND_IF\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AddAssertResult.ExpectedSize","title":"ExpectedSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#AddAssertResult.ExpectedTypeClass","title":"ExpectedTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#AddAssertResult.ExpectedValue","title":"ExpectedValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#AddAssertResult.ActualSize","title":"ActualSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#AddAssertResult.ActualTypeClass","title":"ActualTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#AddAssertResult.ActualValue","title":"ActualValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#AddAssertResult.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#AddAssertResult.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertResultStatic.CopyDetectionCountAndResetDetectionCountInThisCycle","title":"CopyDetectionCountAndResetDetectionCountInThisCycle  <code>PRIVATE</code>","text":"Source Code <pre><code>METHOD PRIVATE CopyDetectionCountAndResetDetectionCountInThisCycle\nVAR\n    IteratorCounter : UINT;\nEND_VAR\n</code></pre> <pre><code>FOR IteratorCounter := 1 TO GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite BY 1 DO\n    AssertResultInstances[IteratorCounter].DetectionCount := AssertResultInstances[IteratorCounter].DetectionCountThisCycle;\n    AssertResultInstances[IteratorCounter].DetectionCountThisCycle := 0;\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_AssertResultStatic.CreateAssertResultInstance","title":"CreateAssertResultInstance  <code>PRIVATE</code>","text":"<p>Inputs</p> <ul> <li> <code>ExpectedSize</code> </li> <li> <code>ExpectedTypeClass</code> </li> <li> <code>ExpectedValue</code> </li> <li> <code>ActualSize</code> </li> <li> <code>ActualTypeClass</code> </li> <li> <code>ActualValue</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD PRIVATE CreateAssertResultInstance\nVAR_INPUT\n    ExpectedSize : UDINT;\n    ExpectedTypeClass : IBaseLibrary.TypeClass;\n    ExpectedValue : POINTER TO BYTE;\n    ActualSize : UDINT;\n    ActualTypeClass : IBaseLibrary.TypeClass;\n    ActualValue : POINTER TO BYTE;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    IteratorCounter : UINT;\nEND_VAR\n</code></pre> <pre><code>FOR IteratorCounter := 1 TO GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite BY 1 DO\n    IF AssertResultInstances[IteratorCounter].DetectionCount = 0 AND\n        AssertResultInstances[IteratorCounter].DetectionCountThisCycle = 0 THEN // Find first free spot\n        AssertResultInstances[IteratorCounter].AssertResult.Expected := F_AnyToUnionValue(AnySize := ExpectedSize, AnyTypeClass := ExpectedTypeClass, AnyValue := ExpectedValue);\n        AssertResultInstances[IteratorCounter].AssertResult.Actual := F_AnyToUnionValue(AnySize := ActualSize, AnyTypeClass := ActualTypeClass, AnyValue := ActualValue);\n        AssertResultInstances[IteratorCounter].AssertResult.Message := Message;\n        AssertResultInstances[IteratorCounter].AssertResult.TestInstancePath := TestInstancePath;\n        AssertResultInstances[IteratorCounter].DetectionCountThisCycle := 1;\n        EXIT;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#CreateAssertResultInstance.ExpectedSize","title":"ExpectedSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.ExpectedTypeClass","title":"ExpectedTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.ExpectedValue","title":"ExpectedValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.ActualSize","title":"ActualSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.ActualTypeClass","title":"ActualTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.ActualValue","title":"ActualValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertResultStatic.GetDetectionCount","title":"GetDetectionCount  <code>UINT</code> <code>PRIVATE</code>","text":"<p>Inputs</p> <ul> <li> <code>ExpectedSize</code> </li> <li> <code>ExpectedTypeClass</code> </li> <li> <code>ExpectedValue</code> </li> <li> <code>ActualSize</code> </li> <li> <code>ActualTypeClass</code> </li> <li> <code>ActualValue</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD PRIVATE GetDetectionCount : UINT\nVAR_INPUT\n    ExpectedSize : UDINT;\n    ExpectedTypeClass : IBaseLibrary.TypeClass;\n    ExpectedValue : POINTER TO BYTE;\n    ActualSize : UDINT;\n    ActualTypeClass : IBaseLibrary.TypeClass;\n    ActualValue : POINTER TO BYTE;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    IteratorCounter : UINT;\nEND_VAR\n</code></pre> <pre><code>FOR IteratorCounter := 1 TO GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite BY 1 DO\n    IF F_IsAnyEqualToUnionValue(ExpectedOrActual := AssertResultInstances[IteratorCounter].AssertResult.Expected,\n                                ExpectedOrActualSize := ExpectedSize,\n                                ExpectedOrActualTypeClass := ExpectedTypeClass,\n                                ExpectedOrActualValue := ExpectedValue) AND\n       F_IsAnyEqualToUnionValue(ExpectedOrActual := AssertResultInstances[IteratorCounter].AssertResult.Actual,\n                                ExpectedOrActualSize := ActualSize,\n                                ExpectedOrActualTypeClass := ActualTypeClass,\n                                ExpectedOrActualValue := ActualValue) AND\n        AssertResultInstances[IteratorCounter].AssertResult.Message = Message AND\n        AssertResultInstances[IteratorCounter].AssertResult.TestInstancePath = TestInstancePath THEN\n        GetDetectionCount := AssertResultInstances[IteratorCounter].DetectionCount;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#GetDetectionCount.ExpectedSize","title":"ExpectedSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.ExpectedTypeClass","title":"ExpectedTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.ExpectedValue","title":"ExpectedValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.ActualSize","title":"ActualSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.ActualTypeClass","title":"ActualTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.ActualValue","title":"ActualValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertResultStatic.GetDetectionCountThisCycle","title":"GetDetectionCountThisCycle  <code>UINT</code> <code>PRIVATE</code>","text":"<p>Inputs</p> <ul> <li> <code>ExpectedSize</code> </li> <li> <code>ExpectedTypeClass</code> </li> <li> <code>ExpectedValue</code> </li> <li> <code>ActualSize</code> </li> <li> <code>ActualTypeClass</code> </li> <li> <code>ActualValue</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD PRIVATE GetDetectionCountThisCycle : UINT\nVAR_INPUT\n    ExpectedSize : UDINT;\n    ExpectedTypeClass : IBaseLibrary.TypeClass;\n    ExpectedValue : POINTER TO BYTE;\n    ActualSize : UDINT;\n    ActualTypeClass : IBaseLibrary.TypeClass;\n    ActualValue : POINTER TO BYTE;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    IteratorCounter : UINT;\nEND_VAR\n</code></pre> <pre><code>FOR IteratorCounter := 1 TO GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite BY 1 DO\n    IF F_IsAnyEqualToUnionValue(ExpectedOrActual := AssertResultInstances[IteratorCounter].AssertResult.Expected,\n                                ExpectedOrActualSize := ExpectedSize,\n                                ExpectedOrActualTypeClass := ExpectedTypeClass,\n                                ExpectedOrActualValue := ExpectedValue) AND\n       F_IsAnyEqualToUnionValue(ExpectedOrActual := AssertResultInstances[IteratorCounter].AssertResult.Actual,\n                                ExpectedOrActualSize := ActualSize,\n                                ExpectedOrActualTypeClass := ActualTypeClass,\n                                ExpectedOrActualValue := ActualValue) AND\n        AssertResultInstances[IteratorCounter].AssertResult.Message = Message AND\n        AssertResultInstances[IteratorCounter].AssertResult.Message = TestInstancePath THEN\n        GetDetectionCountThisCycle := AssertResultInstances[IteratorCounter].DetectionCountThisCycle;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#GetDetectionCountThisCycle.ExpectedSize","title":"ExpectedSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.ExpectedTypeClass","title":"ExpectedTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.ExpectedValue","title":"ExpectedValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.ActualSize","title":"ActualSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.ActualTypeClass","title":"ActualTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.ActualValue","title":"ActualValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertResultStatic.GetNumberOfAssertsForTest","title":"GetNumberOfAssertsForTest  <code>UINT</code> <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>CompleteTestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD INTERNAL GetNumberOfAssertsForTest : UINT\nVAR_INPUT\n    CompleteTestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    Counter : UINT;\n    NumberOfAsserts : UINT := 0;\nEND_VAR\n</code></pre> <pre><code>IF TotalAsserts &gt; 0 THEN\n    FOR Counter := 1 TO TotalAsserts BY 1 DO\n        IF AssertResults[Counter].TestInstancePath = CompleteTestInstancePath THEN\n            NumberOfAsserts := NumberOfAsserts + 1;\n        END_IF\n    END_FOR\nEND_IF\n\nGetNumberOfAssertsForTest := NumberOfAsserts;\n</code></pre>"},{"location":"reference/tcunit/#GetNumberOfAssertsForTest.CompleteTestInstancePath","title":"CompleteTestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertResultStatic.ReportResult","title":"ReportResult","text":"<p>Inputs</p> <ul> <li> <code>ExpectedSize</code> </li> <li> <code>ExpectedTypeClass</code> </li> <li> <code>ExpectedValue</code> </li> <li> <code>ActualSize</code> </li> <li> <code>ActualTypeClass</code> </li> <li> <code>ActualValue</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> <p>Outputs</p> <ul> <li> <code>AlreadyReported</code> </li> </ul> Source Code <pre><code>(*\n    This method is called in every assert and returns whether this particular assert has already been called.\n    The reason one would like to know whether this assert has already been reported or not is to not report it several\n    times to any logging service. Because a test-suite can consist of several tests, and certain tests can require the\n    test to run over several cycles it means that certain asserts could be called several times and thus we need to\n    keep track of which asserts we've already reported. The user of the framework should not need to care for any of\n    this and he/she should be able to call the asserts in any way they find suitable.\n\n    To know what assert this is we need to check for the total combination of:\n    - Test message\n    - Test instance path\n    - Expected value\n    - Actual value\n    Theoretically we can have a situation where a test has three different asserts, each and one with the same test\n    message/test instance path/actual value/expected value but called within the same or different cycles. In order for\n    us to handle all situations we need a simple algorithm that works according to:\n    - Keep track of how many instances the combination of test message/test instance path/expected value/actual value\n      we have. So for example, if we have called Assert(Exp := 5, Act := 5, 'Hello there', 'PRG.InstanceTestSuite.Test')\n      two times in one cycle, we have two instances of that combination. This is done according to:\n    - Iterate all existing reports.\n      - If we have a new PLC-cycle, set the current detection-count to zero.\n      - If new report does not match in any of the above fields, create it (together with current PLC-cycle).\n        Also store the information that we have one instance of this combination and +1 on the detection-count.\n      - If new report matches in all of the above, +1 in the detection-count. If this detection-count is larger than\n        the stored detection-count for this combination, create a new report and add +1 to the storage of\n        the detection-count.\n*)\nMETHOD INTERNAL ReportResult\nVAR_INPUT\n    ExpectedSize : UDINT;\n    ExpectedTypeClass : IBaseLibrary.TypeClass;\n    ExpectedValue : POINTER TO BYTE;\n    ActualSize : UDINT;\n    ActualTypeClass : IBaseLibrary.TypeClass;\n    ActualValue : POINTER TO BYTE;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR_OUTPUT\n    AlreadyReported : BOOL := FALSE;\nEND_VAR\nVAR\n    LocationIndex : UINT;\n    DataTypesNotEquals : BOOL;\n    DataSizeNotEquals : BOOL;\n    DataContentNotEquals : BOOL;\n    CurrentCycleCount : UDINT;\n    IteratorCounter : UINT;\n    DetectionCountTemp : UINT := 0;\n    FoundOne : BOOL;\n    AdditionalIdenticalAssert : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF NOT FirstCycleExecuted THEN\n    GetCurrentTaskIndex();\n    FirstCycleExecuted := TRUE;\nEND_IF\n\nCurrentCycleCount := TwinCAT_SystemInfoVarList._TaskInfo[GetCurrentTaskIndex.index].CycleCount;\n(* Is current cycle the same as the last call to this method?\n   If not, reset the detection count *)\nIF CurrentCycleCount &lt;&gt; CycleCount THEN\n    CopyDetectionCountAndResetDetectionCountInThisCycle();\nEND_IF\n\nFOR IteratorCounter := 1 TO TotalAsserts BY 1 DO\n      IF F_IsAnyEqualToUnionValue(ExpectedOrActual := AssertResultInstances[IteratorCounter].AssertResult.Expected,\n                                  ExpectedOrActualSize := ExpectedSize,\n                                  ExpectedOrActualTypeClass := ExpectedTypeClass,\n                                  ExpectedOrActualValue := ExpectedValue) AND\n         F_IsAnyEqualToUnionValue(ExpectedOrActual := AssertResultInstances[IteratorCounter].AssertResult.Actual,\n                                  ExpectedOrActualSize := ActualSize,\n                                  ExpectedOrActualTypeClass := ActualTypeClass,\n                                  ExpectedOrActualValue := ActualValue) AND\n        AssertResultInstances[IteratorCounter].AssertResult.Message = Message AND\n        AssertResultInstances[IteratorCounter].AssertResult.TestInstancePath = TestInstancePath THEN\n            AssertResultInstances[IteratorCounter].DetectionCountThisCycle :=\n                AssertResultInstances[IteratorCounter].DetectionCountThisCycle + 1;\n            FoundOne := TRUE;\n        IF AssertResultInstances[IteratorCounter].DetectionCountThisCycle &gt;\n            AssertResultInstances[IteratorCounter].DetectionCount THEN // This assert is new\n            AdditionalIdenticalAssert := TRUE;\n        END_IF\n        EXIT;\n    END_IF\nEND_FOR\n\n// If not found anything, create the first\nIF NOT FoundOne THEN\n    // No existing match found, create a new entry\n    AddAssertResult(ExpectedSize := ExpectedSize,\n                    ExpectedTypeClass := ExpectedTypeClass,\n                    ExpectedValue := ExpectedValue,\n                    ActualSize := ActualSize,\n                    ActualTypeClass := ActualTypeClass,\n                    ActualValue := ActualValue,\n                    Message := Message, TestInstancePath := TestInstancePath);\n\n    CreateAssertResultInstance(ExpectedSize := ExpectedSize,\n                               ExpectedTypeClass := ExpectedTypeClass,\n                               ExpectedValue := ExpectedValue,\n                               ActualSize := ActualSize,\n                               ActualTypeClass := ActualTypeClass,\n                               ActualValue := ActualValue,\n                               Message := Message, TestInstancePath := TestInstancePath);\n// An additional instance of this assert needs to be created\nELSIF AdditionalIdenticalAssert THEN\n    AddAssertResult(ExpectedSize := ExpectedSize,\n                    ExpectedTypeClass := ExpectedTypeClass,\n                    ExpectedValue := ExpectedValue,\n                    ActualSize := ActualSize,\n                    ActualTypeClass := ActualTypeClass,\n                    ActualValue := ActualValue,\n                    Message := Message, TestInstancePath := TestInstancePath);\n// In all other cases, this assert has already been reported, we don't need to do anything\nELSE\n    AlreadyReported := TRUE;\nEND_IF\n\n// Update the cycle count\nCycleCount := TwinCAT_SystemInfoVarList._TaskInfo[GetCurrentTaskIndex.index].CycleCount;\n</code></pre>"},{"location":"reference/tcunit/#ReportResult.ExpectedSize","title":"ExpectedSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#ReportResult.ExpectedTypeClass","title":"ExpectedTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#ReportResult.ExpectedValue","title":"ExpectedValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#ReportResult.ActualSize","title":"ActualSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#ReportResult.ActualTypeClass","title":"ActualTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#ReportResult.ActualValue","title":"ActualValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#ReportResult.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#ReportResult.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#ReportResult.AlreadyReported","title":"AlreadyReported  <code>BOOL</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertArrayResultStatic","title":"FB_AssertArrayResultStatic","text":"<p>Methods</p> <ul> <li> <code>AddAssertArrayResult</code> </li> <li> <code>CopyDetectionCountAndResetDetectionCountInThisCycle</code> </li> <li> <code>CreateAssertResultInstance</code> </li> <li> <code>GetDetectionCount</code> </li> <li> <code>GetDetectionCountThisCycle</code> </li> <li> <code>GetNumberOfArrayAssertsForTest</code> </li> <li> <code>ReportResult</code> </li> </ul> Source Code <pre><code>(*\n    This function block is responsible for keeping track of which array-asserts that have been made.\n    The reason we need to keep track of these is because if the user does the same assert twice\n    (because of running a test suite over several PLC-cycles) we want to know it so we don't print several times\n    (if the assert fails). An instance of an array-assert is keyed/identified with the following parameters as key:\n    - Array-size (in bytes) of the expecteds\n    - Datatype of the expecteds\n    - Array-size (in bytes) of the actuals\n    - Datatype of the actuals\n    - Message (string)\n    - Test instance path (string)\n*)\nFUNCTION_BLOCK FB_AssertArrayResultStatic\nVAR\n    // The total number of instances of each of the \"AssertArrayResults\"\n    AssertArrayResults : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite] OF ST_AssertArrayResult;\n\n    // The total number of unique asserts\n    TotalArrayAsserts : UINT := 0;\n\n    // Function block to get the current task cycle\n    GetCurrentTaskIndex : GETCURTASKINDEX;\n\n    // The total number of instances of each of the \"AssertArrayResults\"\n    AssertArrayResultInstances : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite] OF ST_AssertArrayResultInstances;\n\n    // The last PLC cycle count\n    CycleCount : UDINT;\n\n    // Only run first cycle\n    FirstCycleExecuted : BOOL;\nEND_VAR\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_AssertArrayResultStatic.AddAssertArrayResult","title":"AddAssertArrayResult  <code>PRIVATE</code>","text":"<p>Inputs</p> <ul> <li> <code>ExpectedsSize</code> </li> <li> <code>ExpectedsTypeClass</code> </li> <li> <code>ActualsSize</code> </li> <li> <code>ActualsTypeClass</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD PRIVATE AddAssertArrayResult\nVAR_INPUT\n    ExpectedsSize : UDINT;\n    ExpectedsTypeClass : IBaseLibrary.TypeClass;\n    ActualsSize : UDINT;\n    ActualsTypeClass : IBaseLibrary.TypeClass;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR_INST\n\tAssertResultOverflow : BOOL := FALSE;\nEND_VAR\nVAR\n    sErrorString : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>IF TotalArrayAsserts &lt; GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite THEN\n\tTotalArrayAsserts := TotalArrayAsserts + 1;\n\tAssertArrayResults[TotalArrayAsserts].ExpectedsSize := ExpectedsSize;\n\tAssertArrayResults[TotalArrayAsserts].ExpectedsTypeClass := ExpectedsTypeClass;\n\tAssertArrayResults[TotalArrayAsserts].ActualsSize := ActualsSize;\n\tAssertArrayResults[TotalArrayAsserts].ActualsTypeClass := ActualsTypeClass;\n\tAssertArrayResults[TotalArrayAsserts].Message := Message;\n\tAssertArrayResults[TotalArrayAsserts].TestInstancePath := TestInstancePath;\nELSE\n\tIF NOT AssertResultOverflow THEN\n        sErrorString := CONCAT(STR1 := F_GetTestSuiteNameFromTestInstancePath(TestInstancePath := TestInstancePath),\n                               STR2 := '. Max number of assertions exceeded. Check parameter MaxNumberOfAssertsForEachTestSuite.');\n\t\tGVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n\t\t\t\t\t\t\t\t\t\t\tMsgFmtStr := sErrorString,\n\t\t\t\t\t\t\t\t\t\t\tStrArg := '');\n\t\tAssertResultOverflow := TRUE;\n\tEND_IF\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AddAssertArrayResult.ExpectedsSize","title":"ExpectedsSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#AddAssertArrayResult.ExpectedsTypeClass","title":"ExpectedsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#AddAssertArrayResult.ActualsSize","title":"ActualsSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#AddAssertArrayResult.ActualsTypeClass","title":"ActualsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#AddAssertArrayResult.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#AddAssertArrayResult.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertArrayResultStatic.CopyDetectionCountAndResetDetectionCountInThisCycle","title":"CopyDetectionCountAndResetDetectionCountInThisCycle  <code>PRIVATE</code>","text":"Source Code <pre><code>METHOD PRIVATE CopyDetectionCountAndResetDetectionCountInThisCycle\nVAR\n    IteratorCounter : UINT;\nEND_VAR\n</code></pre> <pre><code>FOR IteratorCounter := 1 TO GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite BY 1 DO\n    AssertArrayResultInstances[IteratorCounter].DetectionCount := AssertArrayResultInstances[IteratorCounter].DetectionCountThisCycle;\n    AssertArrayResultInstances[IteratorCounter].DetectionCountThisCycle := 0;\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_AssertArrayResultStatic.CreateAssertResultInstance","title":"CreateAssertResultInstance  <code>PRIVATE</code>","text":"<p>Inputs</p> <ul> <li> <code>ExpectedsSize</code> </li> <li> <code>ExpectedsTypeClass</code> </li> <li> <code>ActualsSize</code> </li> <li> <code>ActualsTypeClass</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD PRIVATE CreateAssertResultInstance\nVAR_INPUT\n    ExpectedsSize : UDINT;\n    ExpectedsTypeClass : IBaseLibrary.TypeClass;\n    ActualsSize : UDINT;\n    ActualsTypeClass : IBaseLibrary.TypeClass;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    IteratorCounter : UINT;\nEND_VAR\n</code></pre> <pre><code>FOR IteratorCounter := 1 TO GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite BY 1 DO\n    IF AssertArrayResultInstances[IteratorCounter].DetectionCount = 0 AND\n        AssertArrayResultInstances[IteratorCounter].DetectionCountThisCycle = 0 THEN // Find first free spot\n        AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ExpectedsSize := ExpectedsSize;\n        AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ExpectedsTypeClass := ExpectedsTypeClass;\n        AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ActualsSize := ActualsSize;\n        AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ActualsTypeClass := ActualsTypeClass;\n        AssertArrayResultInstances[IteratorCounter].AssertArrayResult.Message := Message;\n        AssertArrayResultInstances[IteratorCounter].AssertArrayResult.TestInstancePath := TestInstancePath;\n        AssertArrayResultInstances[IteratorCounter].DetectionCountThisCycle := 1;\n        EXIT;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#CreateAssertResultInstance.ExpectedsSize","title":"ExpectedsSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.ExpectedsTypeClass","title":"ExpectedsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.ActualsSize","title":"ActualsSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.ActualsTypeClass","title":"ActualsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#CreateAssertResultInstance.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertArrayResultStatic.GetDetectionCount","title":"GetDetectionCount  <code>UINT</code> <code>PRIVATE</code>","text":"<p>Inputs</p> <ul> <li> <code>ExpectedsSize</code> </li> <li> <code>ExpectedsTypeClass</code> </li> <li> <code>ActualsSize</code> </li> <li> <code>ActualsTypeClass</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD PRIVATE GetDetectionCount : UINT\nVAR_INPUT\n    ExpectedsSize : UDINT;\n    ExpectedsTypeClass : IBaseLibrary.TypeClass;\n    ActualsSize : UDINT;\n    ActualsTypeClass : IBaseLibrary.TypeClass;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    IteratorCounter : UINT;\nEND_VAR\n</code></pre> <pre><code>FOR IteratorCounter := 1 TO GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite BY 1 DO\n    IF AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ExpectedsSize = ExpectedsSize AND\n       AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ExpectedsTypeClass = ExpectedsTypeClass AND\n       AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ActualsSize = ActualsSize AND\n       AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ActualsTypeClass = ActualsTypeClass AND\n       AssertArrayResultInstances[IteratorCounter].AssertArrayResult.Message = Message AND\n       AssertArrayResultInstances[IteratorCounter].AssertArrayResult.TestInstancePath = TestInstancePath THEN\n        GetDetectionCount := AssertArrayResultInstances[IteratorCounter].DetectionCount;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#GetDetectionCount.ExpectedsSize","title":"ExpectedsSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.ExpectedsTypeClass","title":"ExpectedsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.ActualsSize","title":"ActualsSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.ActualsTypeClass","title":"ActualsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#GetDetectionCount.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertArrayResultStatic.GetDetectionCountThisCycle","title":"GetDetectionCountThisCycle  <code>UINT</code> <code>PRIVATE</code>","text":"<p>Inputs</p> <ul> <li> <code>ExpectedsSize</code> </li> <li> <code>ExpectedsTypeClass</code> </li> <li> <code>ActualsSize</code> </li> <li> <code>ActualsTypeClass</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD PRIVATE GetDetectionCountThisCycle : UINT\nVAR_INPUT\n    ExpectedsSize : UDINT;\n    ExpectedsTypeClass : IBaseLibrary.TypeClass;\n    ActualsSize : UDINT;\n    ActualsTypeClass : IBaseLibrary.TypeClass;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    IteratorCounter : UINT;\nEND_VAR\n</code></pre> <pre><code>FOR IteratorCounter := 1 TO GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite BY 1 DO\n    IF AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ExpectedsSize = ExpectedsSize AND\n       AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ExpectedsTypeClass = ExpectedsTypeClass AND\n       AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ActualsSize = ActualsSize AND\n       AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ActualsTypeClass = ActualsTypeClass AND\n       AssertArrayResultInstances[IteratorCounter].AssertArrayResult.Message = Message AND\n       AssertArrayResultInstances[IteratorCounter].AssertArrayResult.TestInstancePath = TestInstancePath THEN\n\n        GetDetectionCountThisCycle := AssertArrayResultInstances[IteratorCounter].DetectionCountThisCycle;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#GetDetectionCountThisCycle.ExpectedsSize","title":"ExpectedsSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.ExpectedsTypeClass","title":"ExpectedsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.ActualsSize","title":"ActualsSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.ActualsTypeClass","title":"ActualsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#GetDetectionCountThisCycle.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertArrayResultStatic.GetNumberOfArrayAssertsForTest","title":"GetNumberOfArrayAssertsForTest  <code>UINT</code> <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>CompleteTestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD INTERNAL GetNumberOfArrayAssertsForTest : UINT\nVAR_INPUT\n    CompleteTestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    Counter : UINT;\n    NumberOfArrayAsserts : UINT := 0;\nEND_VAR\n</code></pre> <pre><code>IF TotalArrayAsserts &gt; 0 THEN\n    FOR Counter := 1 TO TotalArrayAsserts BY 1 DO\n        IF AssertArrayResults[Counter].TestInstancePath = CompleteTestInstancePath THEN\n            NumberOfArrayAsserts := NumberOfArrayAsserts + 1;\n        END_IF\n    END_FOR\nEND_IF\n\nGetNumberOfArrayAssertsForTest := NumberOfArrayAsserts;\n</code></pre>"},{"location":"reference/tcunit/#GetNumberOfArrayAssertsForTest.CompleteTestInstancePath","title":"CompleteTestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_AssertArrayResultStatic.ReportResult","title":"ReportResult","text":"<p>Inputs</p> <ul> <li> <code>ExpectedsSize</code> </li> <li> <code>ExpectedsTypeClass</code> </li> <li> <code>ActualsSize</code> </li> <li> <code>ActualsTypeClass</code> </li> <li> <code>Message</code> </li> <li> <code>TestInstancePath</code> </li> </ul> <p>Outputs</p> <ul> <li> <code>AlreadyReported</code> </li> </ul> Source Code <pre><code>(*\n    This method is called in every assert and returns whether this particular assert has already been called.\n    The reason one would like to know whether this assert has already been reported or not is to not report it several\n    times to any logging service. Because a test-suite can consist of several tests, and certain tests can require the\n    test to run over several cycles it means that certain asserts could be called several times and thus we need to\n    keep track of which asserts we've already reported. The user of the framework should not need to care for any of\n    this and he/she should be able to call the asserts in any way they find suitable.\n\n    To know what assert this is we need to check for the total combination of:\n    - Test message\n    - Test instance path\n    - Expecteds size (in bytes)\n    - Actuals size (in bytes)\n    - Expecteds datatype\n    - Actuals datatype\n    Theoretically we can have a situation where a test has three different asserts, each and one with the same test\n    message/test instance path/actuals size&amp;datatype/expecteds size&amp;datatype but called within the same or different\n    cycles. In order for us to handle all situations we need a simple algorithm that works according to:\n    - Keep track of how many instances the combination of test message/test instance path/expecteds size&amp;datatype/\n      actuals size&amp;datatype we have. So for example, if we have called\n      Assert(Exp := [5,4,3], Act := [5,4,3], 'Hello there', 'PRG.InstanceTestSuite.Test')\n      two times in one cycle, we have two instances of that combination. This is done according to:\n    - Iterate all existing reports.\n      - If we have a new PLC-cycle, set the current detection-count to zero.\n      - If new report does not match in any of the above fields, create it (together with current PLC-cycle).\n        Also store the information that we have one instance of this combination and +1 on the detection-count.\n      - If new report matches in all of the above, +1 in the detection-count. If this detection-count is larger than\n        the stored detection-count for this combination, create a new report and add +1 to the storage of\n        the detection-count.\n*)\nMETHOD INTERNAL ReportResult\nVAR_INPUT\n    ExpectedsSize : UDINT;\n    ExpectedsTypeClass : IBaseLibrary.TypeClass;\n    ActualsSize : UDINT;\n    ActualsTypeClass : IBaseLibrary.TypeClass;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR_OUTPUT\n    AlreadyReported : BOOL := FALSE;\nEND_VAR\nVAR\n    LocationIndex : UINT;\n    DataTypesNotEquals : BOOL;\n    DataSizeNotEquals : BOOL;\n    DataContentNotEquals : BOOL;\n    CurrentCycleCount : UDINT;\n    IteratorCounter : UINT;\n    DetectionCountTemp : UINT := 0;\n    FoundOne : BOOL;\n    AdditionalIdenticalAssert : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF NOT FirstCycleExecuted THEN\n    GetCurrentTaskIndex();\n    FirstCycleExecuted := TRUE;\nEND_IF\n\nCurrentCycleCount := TwinCAT_SystemInfoVarList._TaskInfo[GetCurrentTaskIndex.index].CycleCount;\n(* Is current cycle the same as the last call to this method?\n   If not, reset the detection count *)\nIF CurrentCycleCount &lt;&gt; CycleCount THEN\n    CopyDetectionCountAndResetDetectionCountInThisCycle();\nEND_IF\n\nFOR IteratorCounter := 1 TO TotalArrayAsserts BY 1 DO\n    IF AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ExpectedsSize = ExpectedsSize AND\n        AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ExpectedsTypeClass = ExpectedsTypeClass AND\n        AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ActualsSize = ActualsSize AND\n        AssertArrayResultInstances[IteratorCounter].AssertArrayResult.ActualsTypeClass = ActualsTypeClass AND\n        AssertArrayResultInstances[IteratorCounter].AssertArrayResult.Message = Message AND\n        AssertArrayResultInstances[IteratorCounter].AssertArrayResult.TestInstancePath = TestInstancePath THEN\n        AssertArrayResultInstances[IteratorCounter].DetectionCountThisCycle :=\n            AssertArrayResultInstances[IteratorCounter].DetectionCountThisCycle + 1;\n            FoundOne := TRUE;\n        IF AssertArrayResultInstances[IteratorCounter].DetectionCountThisCycle &gt;\n                AssertArrayResultInstances[IteratorCounter].DetectionCount THEN // This assert is new\n                AdditionalIdenticalAssert := TRUE;\n        END_IF\n        EXIT;\n    END_IF\nEND_FOR\n\n// If not found anything, create the first\nIF NOT FoundOne THEN\n    // No existing match found, create a new entry\n    AddAssertArrayResult(ExpectedsSize := ExpectedsSize,\n                         ExpectedsTypeClass := ExpectedsTypeClass,\n                         ActualsSize := ActualsSize,\n                         ActualsTypeClass := ActualsTypeClass,\n                         Message := Message,\n                         TestInstancePath := TestInstancePath);\n    CreateAssertResultInstance(ExpectedsSize := ExpectedsSize,\n                               ExpectedsTypeClass := ExpectedsTypeClass,\n                               ActualsSize := ActualsSize,\n                               ActualsTypeClass := ActualsTypeClass,\n                               Message := Message,\n                               TestInstancePath := TestInstancePath);\n// An additional instance of this assert needs to be created\nELSIF AdditionalIdenticalAssert THEN\n    AddAssertArrayResult(ExpectedsSize := ExpectedsSize,\n                         ExpectedsTypeClass := ExpectedsTypeClass,\n                         ActualsSize := ActualsSize,\n                         ActualsTypeClass := ActualsTypeClass,\n                         Message := Message,\n                         TestInstancePath := TestInstancePath);\n// In all other cases, this assert has already been reported, we don't need to do anything\nELSE\n    AlreadyReported := TRUE;\nEND_IF\n\n// Update the cycle count\nCycleCount := TwinCAT_SystemInfoVarList._TaskInfo[GetCurrentTaskIndex.index].CycleCount;\n</code></pre>"},{"location":"reference/tcunit/#ReportResult.ExpectedsSize","title":"ExpectedsSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#ReportResult.ExpectedsTypeClass","title":"ExpectedsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#ReportResult.ActualsSize","title":"ActualsSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#ReportResult.ActualsTypeClass","title":"ActualsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#ReportResult.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#ReportResult.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#ReportResult.AlreadyReported","title":"AlreadyReported  <code>BOOL</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_TcUnitRunner","title":"FB_TcUnitRunner","text":"<p>Methods</p> <ul> <li> <code>AbortRunningTestSuiteTests</code> </li> <li> <code>RunTestSuiteTests</code> </li> <li> <code>RunTestSuiteTestsInSequence</code> </li> </ul> Source Code <pre><code>// This function block is responsible for holding track of the tests and executing them.\nFUNCTION_BLOCK FB_TcUnitRunner\nVAR\n    // Indication of whether all test suites have reported that they are finished\n    AllTestSuitesFinished : BOOL := FALSE;\n    AllTestSuitesFinishedTrigger : R_TRIG;\n\n    //Test result information\n    TestResults : FB_TestResults;\n\n    (* Prints the results to ADS so that Visual Studio can display the results.\n       This test result formatter can be replaced with something else than ADS *)\n    AdsTestResultLogger : FB_AdsTestResultLogger(TestResults);\n    TestResultLogger : I_TestResultLogger := AdsTestResultLogger;\n\n    (* If this flag is set, it means that some external event triggered the\n       request to abort running the test suites *)\n    AbortRunningTestSuites : BOOL;\n\n    // Publishes a xUnit compatible XML file\n    xUnitXmlPublisher : FB_xUnitXmlPublisher(TestResults);\n    XmlTestResultPublisher : I_TestResultLogger := xUnitXmlPublisher;\nEND_VAR\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TcUnitRunner.AbortRunningTestSuiteTests","title":"AbortRunningTestSuiteTests","text":"Source Code <pre><code>(* This function sets a flag which makes the runner stop running the tests\n   in the test suites *)\nMETHOD INTERNAL AbortRunningTestSuiteTests\n</code></pre> <pre><code>AbortRunningTestSuites := TRUE;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TcUnitRunner.RunTestSuiteTests","title":"RunTestSuiteTests","text":"Source Code <pre><code>// This runs all the test suites in parallel\nMETHOD INTERNAL RunTestSuiteTests\nVAR\n    Counter : UINT := 0;\n    BusyPrinting : BOOL;\n    (* We need to hold a temporary state of the statistics \n       as we don't consider the tests to be completely finished until all test suites have executed completely.\n       The reason we want to do it this way is because a test suite can run over several cycles. Only once all tests\n       are finished (which might take many cycles), do we gather correct statistics *)\n    NumberOfTestSuitesFinished : UINT := 0;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.StartedAt = 0 THEN\n    GVL_TcUnit.StartedAt := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter);\nEND_IF\n\n// Run TcUnit test suites\nIF NOT AllTestSuitesFinished THEN\n    IF GVL_TcUnit.NumberOfInitializedTestSuites = 0 THEN\n        AllTestSuitesFinished := TRUE;\n    ELSIF GVL_TcUnit.NumberOfInitializedTestSuites &gt; 0 THEN\n        FOR Counter := 1 TO GVL_TcUnit.NumberOfInitializedTestSuites BY 1 DO\n            IF GVL_TcUnit.TestSuiteAddresses[Counter]^.AreAllTestsFinished() THEN\n                NumberOfTestSuitesFinished := NumberOfTestSuitesFinished + 1;\n            ELSE\n                GVL_TcUnit.CurrentTestSuiteBeingCalled := GVL_TcUnit.TestSuiteAddresses[Counter];\n\t\t\t\tGVL_TcUnit.CurrentTestSuiteBeingCalled^.SetStartedAtIfNotSet(Timestamp := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter));\n                GVL_TcUnit.CurrentTestSuiteBeingCalled^();\n\t\t\t\t// This is not an efficient way to set the duration\n\t\t\t\tIF GVL_TcUnit.TestSuiteAddresses[Counter]^.AreAllTestsFinished() THEN\n\t\t\t\t\tGVL_TcUnit.CurrentTestSuiteBeingCalled^.CalculateDuration(FinishedAt := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter));\n\t\t\t\tEND_IF\n            END_IF\n        END_FOR\n        (* Check if some event triggered an abortion of running the tests, in that case abort it now.\n           This can be accomplished by setting the result of the test suites run to finished. *)\n        IF AbortRunningTestSuites THEN\n            NumberOfTestSuitesFinished := GVL_TcUnit.NumberOfInitializedTestSuites;\n        END_IF\n\n        IF NumberOfTestSuitesFinished = GVL_TcUnit.NumberOfInitializedTestSuites THEN\n            AllTestSuitesFinished := TRUE;\n        END_IF\n    END_IF\nEND_IF\n\n// Store test suite results continuously\nTestResults();\n\n// Log test suite results continuously\nTestResultLogger.LogTestSuiteResults();\n\n// Publish the xUnit Xml file once if enabled\nXmlTestResultPublisher.LogTestSuiteResults();\n\n// Run the buffered ADS logger\nGVL_TcUnit.AdsMessageQueue();\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TcUnitRunner.RunTestSuiteTestsInSequence","title":"RunTestSuiteTestsInSequence","text":"<p>Inputs</p> <ul> <li> <code>TimeBetweenTestSuitesExecution</code>             \u2013              <p>Time delay between a test suite is finished and the next test suite starts</p> </li> </ul> Source Code <pre><code>// This runs all the test suites in sequence (one after the other)\nMETHOD INTERNAL RunTestSuiteTestsInSequence\nVAR_INPUT\n    TimeBetweenTestSuitesExecution : TIME; // Time delay between a test suite is finished and the next test suite starts\nEND_VAR\nVAR\n    BusyPrinting : BOOL;\n    (* We need to hold a temporary state of the statistics\n       as we don't consider the tests to be completely finished until all test suites have executed completely.\n       The reason we want to do it this way is because a test suite can run over several cycles. Only once all tests\n       are finished (which might take many cycles), do we gather correct statistics *)\n    NumberOfTestSuitesFinished : UINT := 0;\nEND_VAR\nVAR_INST\n    (* This variable holds which current test suite is being called, as we are running\n       each one in a sequence (one by one) *)\n     CurrentlyRunningTestSuite : UINT := 1;\n     TimerBetweenExecutionOfTestSuites : TOF;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.StartedAt = 0 THEN\n    GVL_TcUnit.StartedAt := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter);\nEND_IF\n\nTimerBetweenExecutionOfTestSuites(PT := TimeBetweenTestSuitesExecution);\n// Run TcUnit test suites\nIF NOT AllTestSuitesFinished THEN\n    IF GVL_TcUnit.NumberOfInitializedTestSuites = 0 THEN\n        AllTestSuitesFinished := TRUE;\n    ELSIF GVL_TcUnit.NumberOfInitializedTestSuites &gt; 0 THEN\n        IF TimerBetweenExecutionOfTestSuites.Q THEN\n            TimerBetweenExecutionOfTestSuites.IN := FALSE;\n        END_IF\n        IF GVL_TcUnit.TestSuiteAddresses[CurrentlyRunningTestSuite]^.AreAllTestsFinished() THEN\n            IF CurrentlyRunningTestSuite &lt;&gt; GVL_TcUnit.NumberOfInitializedTestSuites THEN\n                NumberOfTestSuitesFinished := NumberOfTestSuitesFinished + 1;\n                CurrentlyRunningTestSuite := CurrentlyRunningTestSuite + 1;\n                TimerBetweenExecutionOfTestSuites.IN := TRUE;\n\t\t\t\tGVL_TcUnit.CurrentTestSuiteBeingCalled^.CalculateDuration(FinishedAt := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter));\n            END_IF\n        ELSIF NOT TimerBetweenExecutionOfTestSuites.Q THEN\n            GVL_TcUnit.CurrentTestSuiteBeingCalled := GVL_TcUnit.TestSuiteAddresses[CurrentlyRunningTestSuite];\n\t\t\tGVL_TcUnit.CurrentTestSuiteBeingCalled^.SetStartedAtIfNotSet(Timestamp := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter));\n            GVL_TcUnit.CurrentTestSuiteBeingCalled^();\n\t\t\t// This is not an efficient way to set the duration\n\t\t\tIF GVL_TcUnit.TestSuiteAddresses[CurrentlyRunningTestSuite]^.AreAllTestsFinished() THEN\n\t\t\t\tGVL_TcUnit.CurrentTestSuiteBeingCalled^.CalculateDuration(FinishedAt := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter));\n\t\t\tEND_IF\n        END_IF\n        (* Check if some event triggered an abortion of running the tests, in that case abort it now.\n           This can be accomplished by setting the result of the test suites run to finished. *)\n        IF AbortRunningTestSuites THEN\n            NumberOfTestSuitesFinished := GVL_TcUnit.NumberOfInitializedTestSuites;\n        END_IF\n        IF NumberOfTestSuitesFinished = GVL_TcUnit.NumberOfInitializedTestSuites THEN\n            AllTestSuitesFinished := TRUE;\n        END_IF\n    END_IF\nEND_IF\n\n// Store test suite results continuously\nTestResults();\n\n// Log test suite results continuously\nTestResultLogger.LogTestSuiteResults();\n\n// Publish the xUnit Xml file once if enabled\nXmlTestResultPublisher.LogTestSuiteResults();\n\n// Run the buffered ADS logger\nGVL_TcUnit.AdsMessageQueue();\n</code></pre>"},{"location":"reference/tcunit/#RunTestSuiteTestsInSequence.TimeBetweenTestSuitesExecution","title":"TimeBetweenTestSuitesExecution  <code>TIME</code>","text":"<p>Time delay between a test suite is finished and the next test suite starts</p>"},{"location":"reference/tcunit/#TcUnit.FB_Test","title":"FB_Test","text":"<p>Methods</p> <ul> <li> <code>GetAssertionMessage</code> </li> <li> <code>GetAssertionType</code> </li> <li> <code>GetDuration</code> </li> <li> <code>GetName</code> </li> <li> <code>GetNumberOfAssertions</code> </li> <li> <code>GetTestOrder</code> </li> <li> <code>IsFailed</code> </li> <li> <code>IsFinished</code> </li> <li> <code>IsSkipped</code> </li> <li> <code>SetAssertionMessage</code> </li> <li> <code>SetAssertionType</code> </li> <li> <code>SetFailed</code> </li> <li> <code>SetFinishedAndDuration</code> </li> <li> <code>SetName</code> </li> <li> <code>SetNumberOfAssertions</code> </li> <li> <code>SetSkipped</code> </li> <li> <code>SetStartedAtIfNotSet</code> </li> <li> <code>SetTestOrder</code> </li> </ul> Source Code <pre><code>// This function block holds all data that defines a test.\nFUNCTION_BLOCK FB_Test\nVAR\n    TestName : T_MaxString;\n    TestIsFinished : BOOL;\n    TestIsSkipped : BOOL; // This is set to true, if test is disabled (by putting the string \"disabled_\" in front of the test name\n    NumberOfAssertions : UINT;\n\n    (* In which order/sequence relative to the order tests should this test be executed/evaluated.\n       A value of 0 means it is not defined by TEST_ORDERED() but by un-ordered test (TEST()).\n       A value &lt;&gt; 0 tells in which order this test will be executed/evaluated. The lower the number, the earlier it will execute. *)\n    TestOrderNumber : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite); \n\n    // Failure parameters. If TestIsFailed is TRUE, the other parameters will hold values as well\n    TestIsFailed : BOOL; // Indication of whether this test has at least one failed assert\n    AssertionMessage : T_MaxString; // Assertion message for the first assertion in this test\n    AssertionType : E_AssertionType; // Assertion type for the first assertion in this test\n\n    StartedAt : LWORD; // Temporary variable to calculate the actual duration of the test, the value holds the cpu cycle counter when a test is started in 100ns precision\n    Duration : LREAL; // Duration of the test in seconds\nEND_VAR\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.GetAssertionMessage","title":"GetAssertionMessage  <code>T_MaxString</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetAssertionMessage : T_MaxString\n</code></pre> <pre><code>GetAssertionMessage := AssertionMessage;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.GetAssertionType","title":"GetAssertionType  <code>E_AssertionType</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetAssertionType : E_AssertionType\n</code></pre> <pre><code>GetAssertionType := AssertionType;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.GetDuration","title":"GetDuration  <code>LREAL</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetDuration : LREAL\n</code></pre> <pre><code>GetDuration := Duration;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.GetName","title":"GetName  <code>T_MaxString</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetName : T_MaxString;\n</code></pre> <pre><code>GetName := TestName;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.GetNumberOfAssertions","title":"GetNumberOfAssertions  <code>UINT</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetNumberOfAssertions : UINT\n</code></pre> <pre><code>GetNumberOfAssertions := NumberOfAssertions;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.GetTestOrder","title":"GetTestOrder","text":"Source Code <pre><code>// Gets in which order/sequence relative to the order tests should this test be executed/evaluated.\nMETHOD INTERNAL GetTestOrder : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\n</code></pre> <pre><code>GetTestOrder := TestOrderNumber;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.IsFailed","title":"IsFailed  <code>BOOL</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL IsFailed : BOOL\n</code></pre> <pre><code>IsFailed := TestIsFailed;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.IsFinished","title":"IsFinished  <code>BOOL</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL IsFinished : BOOL\n</code></pre> <pre><code>IsFinished := TestIsFinished;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.IsSkipped","title":"IsSkipped  <code>BOOL</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL IsSkipped : BOOL\n</code></pre> <pre><code>IsSkipped := TestIsSkipped;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.SetAssertionMessage","title":"SetAssertionMessage","text":"<p>Inputs</p> <ul> <li> <code>AssertMessage</code> </li> </ul> Source Code <pre><code>// Sets the assertion message. If one already exists, it's not overwritten as we keep the first assertion in the test\nMETHOD INTERNAL SetAssertionMessage\nVAR_INPUT\n    AssertMessage : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>IF LEN(STR := AssertionMessage) = 0 THEN\n    AssertionMessage := AssertMessage;\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#SetAssertionMessage.AssertMessage","title":"AssertMessage  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_Test.SetAssertionType","title":"SetAssertionType","text":"<p>Inputs</p> <ul> <li> <code>AssertType</code> </li> </ul> Source Code <pre><code>// Sets the assertion type. If one already exists, it's not overwritten as we keep the first assertion in the test\nMETHOD INTERNAL SetAssertionType\nVAR_INPUT\n    AssertType : E_AssertionType;\nEND_VAR\n</code></pre> <pre><code>IF AssertionType = E_AssertionType.Type_UNDEFINED THEN\n    AssertionType := AssertType;\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#SetAssertionType.AssertType","title":"AssertType  <code>E_AssertionType</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_Test.SetFailed","title":"SetFailed  <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL SetFailed\n</code></pre> <pre><code>TestIsFailed := TRUE;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.SetFinishedAndDuration","title":"SetFinishedAndDuration  <code>BOOL</code> <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>FinishedAt</code>             \u2013              <p>CPU cycle counter with 100ns precision</p> </li> </ul> Source Code <pre><code>METHOD INTERNAL SetFinishedAndDuration : BOOL\nVAR_INPUT\n    FinishedAt : LWORD; // CPU cycle counter with 100ns precision\nEND_VAR\n</code></pre> <pre><code>TestIsFinished := TRUE;\nDuration := LWORD_TO_LREAL(FinishedAt - StartedAt) * GVL_TcUnit.HundredNanosecondToSecond; // Seconds\n</code></pre>"},{"location":"reference/tcunit/#SetFinishedAndDuration.FinishedAt","title":"FinishedAt  <code>LWORD</code>","text":"<p>CPU cycle counter with 100ns precision</p>"},{"location":"reference/tcunit/#TcUnit.FB_Test.SetName","title":"SetName  <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>Name</code> </li> </ul> Source Code <pre><code>METHOD INTERNAL SetName\nVAR_INPUT\n    Name : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>TestName := Name;\n</code></pre>"},{"location":"reference/tcunit/#SetName.Name","title":"Name  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_Test.SetNumberOfAssertions","title":"SetNumberOfAssertions  <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>NoOfAssertions</code> </li> </ul> Source Code <pre><code>METHOD INTERNAL SetNumberOfAssertions\nVAR_INPUT\n    NoOfAssertions : UINT;\nEND_VAR\n</code></pre> <pre><code>NumberOfAssertions := NoOfAssertions;\n</code></pre>"},{"location":"reference/tcunit/#SetNumberOfAssertions.NoOfAssertions","title":"NoOfAssertions  <code>UINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_Test.SetSkipped","title":"SetSkipped","text":"Source Code <pre><code>// Sets the test case to skipped\nMETHOD INTERNAL SetSkipped\n</code></pre> <pre><code>TestIsSkipped := TRUE;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_Test.SetStartedAtIfNotSet","title":"SetStartedAtIfNotSet  <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>Timestamp</code>             \u2013              <p>CPU cycle counter with 100ns precision</p> </li> </ul> Source Code <pre><code>METHOD INTERNAL SetStartedAtIfNotSet\nVAR_INPUT\n    Timestamp : LWORD; // CPU cycle counter with 100ns precision\nEND_VAR\n</code></pre> <pre><code>IF StartedAt = 0 THEN\n    StartedAt := Timestamp;\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#SetStartedAtIfNotSet.Timestamp","title":"Timestamp  <code>LWORD</code>","text":"<p>CPU cycle counter with 100ns precision</p>"},{"location":"reference/tcunit/#TcUnit.FB_Test.SetTestOrder","title":"SetTestOrder","text":"<p>Inputs</p> <ul> <li> <code>OrderNumber</code> </li> </ul> Source Code <pre><code>// Sets in which order/sequence relative to the order tests should this test be executed/evaluated.\nMETHOD INTERNAL SetTestOrder\nVAR_INPUT\n    OrderNumber : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\n</code></pre> <pre><code>TestOrderNumber := OrderNumber;\n</code></pre>"},{"location":"reference/tcunit/#SetTestOrder.OrderNumber","title":"OrderNumber  <code>UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite)</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_TestSuite","title":"FB_TestSuite","text":"<p>Methods</p> <ul> <li> <code>AddTest</code> </li> <li> <code>AddTestNameToInstancePath</code> </li> <li> <code>AreAllTestsFinished</code> </li> <li> <code>AssertArray2dEquals_LREAL</code> </li> <li> <code>AssertArray2dEquals_REAL</code> </li> <li> <code>AssertArray3dEquals_LREAL</code> </li> <li> <code>AssertArray3dEquals_REAL</code> </li> <li> <code>AssertArrayEquals_BOOL</code> </li> <li> <code>AssertArrayEquals_BYTE</code> </li> <li> <code>AssertArrayEquals_DINT</code> </li> <li> <code>AssertArrayEquals_DWORD</code> </li> <li> <code>AssertArrayEquals_INT</code> </li> <li> <code>AssertArrayEquals_LINT</code> </li> <li> <code>AssertArrayEquals_LREAL</code> </li> <li> <code>AssertArrayEquals_LWORD</code> </li> <li> <code>AssertArrayEquals_REAL</code> </li> <li> <code>AssertArrayEquals_SINT</code> </li> <li> <code>AssertArrayEquals_UDINT</code> </li> <li> <code>AssertArrayEquals_UINT</code> </li> <li> <code>AssertArrayEquals_ULINT</code> </li> <li> <code>AssertArrayEquals_USINT</code> </li> <li> <code>AssertArrayEquals_WORD</code> </li> <li> <code>AssertEquals</code> </li> <li> <code>AssertEquals_BOOL</code> </li> <li> <code>AssertEquals_BYTE</code> </li> <li> <code>AssertEquals_DATE</code> </li> <li> <code>AssertEquals_DATE_AND_TIME</code> </li> <li> <code>AssertEquals_DINT</code> </li> <li> <code>AssertEquals_DWORD</code> </li> <li> <code>AssertEquals_INT</code> </li> <li> <code>AssertEquals_LINT</code> </li> <li> <code>AssertEquals_LREAL</code> </li> <li> <code>AssertEquals_LTIME</code> </li> <li> <code>AssertEquals_LWORD</code> </li> <li> <code>AssertEquals_REAL</code> </li> <li> <code>AssertEquals_SINT</code> </li> <li> <code>AssertEquals_STRING</code> </li> <li> <code>AssertEquals_TIME</code> </li> <li> <code>AssertEquals_TIME_OF_DAY</code> </li> <li> <code>AssertEquals_UDINT</code> </li> <li> <code>AssertEquals_UINT</code> </li> <li> <code>AssertEquals_ULINT</code> </li> <li> <code>AssertEquals_USINT</code> </li> <li> <code>AssertEquals_WORD</code> </li> <li> <code>AssertEquals_WSTRING</code> </li> <li> <code>AssertFalse</code> </li> <li> <code>AssertTrue</code> </li> <li> <code>CalculateAndSetNumberOfAssertsForTest</code> </li> <li> <code>CalculateDuration</code> </li> <li> <code>FB_init</code> </li> <li> <code>FindTestSuiteInstancePath</code> </li> <li> <code>GetDuration</code> </li> <li> <code>GetHasStartedRunning</code> </li> <li> <code>GetInstancePath</code> </li> <li> <code>GetNumberOfFailedTests</code> </li> <li> <code>GetNumberOfSkippedTests</code> </li> <li> <code>GetNumberOfSuccessfulTests</code> </li> <li> <code>GetNumberOfTests</code> </li> <li> <code>GetNumberOfTestsToAnalyse</code> </li> <li> <code>GetTestByName</code> </li> <li> <code>GetTestByPosition</code> </li> <li> <code>GetTestOrderNumber</code> </li> <li> <code>IsTestFinished</code> </li> <li> <code>SetStartedAtIfNotSet</code> </li> <li> <code>SetStartedAtTimeBasedOnCpuCounter</code> </li> <li> <code>SetTestFailed</code> </li> <li> <code>SetTestFinished</code> </li> </ul> Source Code <pre><code>(* This function block is responsible for holding the internal state of the test suite.\n   Every test suite can have one or more tests, and every test can do one or more asserts.\n   It's also responsible for providing all the assert-methods for asserting different data types.\n   Only failed assertions are recorded.\n*)\n{attribute 'call_after_init'}\n{attribute 'reflection'}\nFUNCTION_BLOCK FB_TestSuite\nVAR\n    {attribute 'instance-path'}\n    {attribute 'noinit'}\n    InstancePath : T_MaxString;\n\n    (* We need to have access to specific information of the current task that this test suite\n       is executed in. This is for instance necessary when we need to know whether a test is\n       defined already. The definition of a test that is defined already is that we call on it\n       with the same name twice in the same cycle *)\n    GetCurrentTaskIndex : GETCURTASKINDEX;\n\n    NumberOfTests : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite) := 0;\n    Tests : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite] OF FB_Test;\n    (* Rising trigger of whether we have already notified the user of that the test name pointed to by the current\n       position is a duplicate *)\n    TestDuplicateNameTrigger : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite] OF R_TRIG;\n    (* Last cycle count index for a specific test. Used to detect whether this test has already been defined in the\n       current test suite *)\n    TestCycleCountIndex : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite] OF UDINT;\n\n    AssertResults : FB_AssertResultStatic;\n    AssertArrayResults : FB_AssertArrayResultStatic;\n\n    (* Prints the failed asserts to ADS so that Visual Studio can display the assert message.\n       This assert formatter can be replaced with something else than ADS *)\n    AdsAssertMessageFormatter : FB_AdsAssertMessageFormatter;\n    AssertMessageFormatter : I_AssertMessageFormatter := AdsAssertMessageFormatter;\n\n    (* Stores the CPU cycle count with 100ns precision. It also is an indication whether this \n       test suite has started running its tests (&gt; 0 means it has started) *)\n    StartedAt : LWORD;\n\n    (* Duration it took to run all tests in this testsuite - including the overhead from TcUnit\n       in seconds *)\n    Duration : LREAL;\n\n    // Number of ordered tests (created by TEST_ORDERED()) that this test suite contains\n    NumberOfOrderedTests : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AddTest","title":"AddTest  <code>REFERENCE TO FB_Test</code> <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>TestName</code> </li> <li> <code>IsTestOrdered</code> </li> </ul> Source Code <pre><code>METHOD INTERNAL AddTest : REFERENCE TO FB_Test\nVAR_INPUT\n    TestName : T_MaxString;\n    IsTestOrdered : BOOL;\nEND_VAR\nVAR\n    IteratorCounter : UINT;\n    ErrorMessage : T_MaxString;\n    TestInstancePath : T_MaxString;\n    FunctionCallResult : DINT;\n    CycleCount : UDINT;\n    TestWithThisNameAlreadyExists : BOOL := FALSE;\n    LowerCasedTestName : T_MaxString;\n    TrimmedTestName : T_MaxString;\n    IgnoreCurrentTestCase : BOOL;\n    NumberOfTestsToAnalyse : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\n</code></pre> <pre><code>GVL_TcUnit.IgnoreCurrentTest := FALSE; // Reset the ignore current test flag\n\nTrimmedTestName := F_LTrim(in := TestName);\nTrimmedTestName := F_RTrim(in := TrimmedTestName);\nLowerCasedTestName := F_ToLCase(in := TrimmedTestName);\n\n// If test should be disabled, make sure to remove the \"disabled_\"-part of it from the test name\nIF FIND(STR1 := LowerCasedTestName, STR2 := 'disabled_') = 1 THEN\n    IgnoreCurrentTestCase := TRUE;\n    TrimmedTestName := DELETE(STR := TrimmedTestName, LEN := LEN(STR := 'disabled_'), POS := 1);\nEND_IF\n\nGetCurrentTaskIndex(); // Gets the task index of where this function block instance is being run in\n\n(* Check if the test name already exists. Make sure there are no other tests with the same name already\n   added for this test suite *)\n\nCycleCount := TwinCAT_SystemInfoVarList._TaskInfo[GetCurrentTaskIndex.index].CycleCount;\n\n// Limit the test analyse to the max array limit of 'Tests[]'\nNumberOfTestsToAnalyse := GetNumberOfTestsToAnalyse();\n\n// Iterate all the test names that up to this point have been added for this test suite\nFOR IteratorCounter := 1 TO NumberOfTestsToAnalyse BY 1 DO\n    IF Tests[IteratorCounter].GetName() = TrimmedTestName THEN\n        TestWithThisNameAlreadyExists := TRUE;\n        // Check if a test with this name has already been called in this PLC cycle\n        IF TestCycleCountIndex[IteratorCounter] = CycleCount THEN\n            GVL_TcUnit.IgnoreCurrentTest := TRUE;\n            (* A test with this name already exists for this test suite and has already been called in this cycle.\n               Send a message notification, but only if we have not done so already. *)\n            TestDuplicateNameTrigger[IteratorCounter](CLK := TRUE);\n            IF TestDuplicateNameTrigger[IteratorCounter].Q THEN // Rising edge detected. We have not reported this before\n                TestInstancePath := F_RemoveInstancePathAndProjectNameFromTestInstancePath(TestInstancePath :=\n                                                                                           GVL_TcUnit.CurrentTestSuiteBeingCalled^.GetInstancePath());\n                ErrorMessage := 'Test with name $'%s$' already exists in test suite $'';\n                ErrorMessage := CONCAT(STR1 := ErrorMessage, STR2 := TestInstancePath);\n                ErrorMessage := CONCAT(STR1 := ErrorMessage, STR2 := '$'');\n                GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                                    MsgFmtStr := ErrorMessage,\n                                                    StrArg := TrimmedTestName);\n            END_IF\n        END_IF\n        TestCycleCountIndex[IteratorCounter] := CycleCount;\n    END_IF\nEND_FOR\n\nIF NOT TestWithThisNameAlreadyExists THEN\n    // Test has not been found. Add it.\n    Tests[IteratorCounter].SetName(Name := TrimmedTestName);\n    NumberOfTests := NumberOfTests + 1;\n    TestCycleCountIndex[NumberOfTests] := CycleCount;\n    IF IgnoreCurrentTestCase THEN\n        Tests[IteratorCounter].SetSkipped();\n    END_IF\n\n    // Extra information to be added if test is ordered (called by TEST_ORDERED())\n    IF IsTestOrdered THEN\n        NumberOfOrderedTests := NumberOfOrderedTests + 1;\n        Tests[IteratorCounter].SetTestOrder(OrderNumber := NumberOfOrderedTests);\n    END_IF\nEND_IF\n\n// Check if this test should be disabled\nIF IgnoreCurrentTestCase THEN\n    GVL_TcUnit.IgnoreCurrentTest := TRUE;\n    RETURN;\nEND_IF\n\nAddTest REF= GetTestByName(TrimmedTestName);\n</code></pre>"},{"location":"reference/tcunit/#AddTest.TestName","title":"TestName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#AddTest.IsTestOrdered","title":"IsTestOrdered  <code>BOOL</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AddTestNameToInstancePath","title":"AddTestNameToInstancePath  <code>T_MaxString</code> <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>METHOD INTERNAL AddTestNameToInstancePath : T_MaxString\nVAR_INPUT\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    CompleteTestInstancePath : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>CompleteTestInstancePath := CONCAT(STR1 := TestInstancePath, STR2 := '@');\nAddTestNameToInstancePath := CONCAT(STR1 := CompleteTestInstancePath, STR2 := GVL_TcUnit.CurrentTestNameBeingCalled);\n</code></pre>"},{"location":"reference/tcunit/#AddTestNameToInstancePath.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AreAllTestsFinished","title":"AreAllTestsFinished  <code>BOOL</code> <code>PUBLIC</code>","text":"Source Code <pre><code>METHOD PUBLIC AreAllTestsFinished : BOOL\nVAR\n    Counter : UINT;\n    GetCurTaskIndex : GETCURTASKINDEX;\n    NumberOfTestsToAnalyse : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\n</code></pre> <pre><code>AreAllTestsFinished := FALSE;\n\nIF NumberOfTests &gt; 0 THEN\n    AreAllTestsFinished := TRUE;\n    // Limit the test analyse to the max array limit of 'Tests[]'\n    NumberOfTestsToAnalyse := GetNumberOfTestsToAnalyse();\n    // A test is considered finished if it is finished running (i.e. set by TEST_FINISHED) or if it is skipped/disabled\n    FOR Counter := 1 TO NumberOfTestsToAnalyse BY 1 DO\n        AreAllTestsFinished := AreAllTestsFinished AND (Tests[Counter].IsFinished() OR Tests[Counter].IsSkipped());\n    END_FOR\nEND_IF\n\n(* If we have been running at least one cycle and no tests are registered, it means that this testsuite is empty\n   and doesn't contain any test cases. In that case, ignore this testsuite. *)\nGetCurTaskIndex();\nIF NumberOfTests = 0 AND NOT TwinCAT_SystemInfoVarList._TaskInfo[GetCurTaskIndex.index].FirstCycle AND StartedAt &gt; 0 THEN\n\tAreAllTestsFinished := TRUE;\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArray2dEquals_LREAL","title":"AssertArray2dEquals_LREAL","text":"<p>Inputs</p> <ul> <li> <code>Delta</code>             \u2013              <p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>LREAL 2d array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>LREAL 2d array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two LREAL 2D-arrays are equal to within a positive delta. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArray2dEquals_LREAL\nVAR_IN_OUT\n    Expecteds : ARRAY[*,*] OF LREAL; // LREAL 2d array with expected values\n    Actuals : ARRAY[*,*] OF LREAL; // LREAL 2d array with actual values\nEND_VAR\nVAR_INPUT\n    Delta : LREAL; // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    DimensionIndex : USINT; // Index when looping through Dimensions\n    LowerBoundExpecteds : ARRAY[1..2] OF DINT; // Lower bounds of Expecteds array in each dimension\n    UpperBoundExpecteds : ARRAY[1..2] OF DINT; // Upper bounds of Expecteds array in each dimension\n    LowerBoundActuals : ARRAY[1..2] OF DINT; // Lower bounds of Actuals array in each dimension\n    UpperBoundActuals : ARRAY[1..2] OF DINT; // Upper bounds of Actuals array in each dimension\n    SizeOfExpecteds : ARRAY[1..2] OF DINT; // Size of Expecteds array in each dimension\n    SizeOfActuals : ARRAY[1..2] OF DINT; // Size of Actuals array in each dimension\n    Offset : ARRAY[1..2] OF DINT; // Current Array index offsets from Lower Bound in each dimension\n    ExpectedArrayIndex : ARRAY[1..2] OF DINT; // Array of current Expected array indexes when looping through arrays\n    ActualArrayIndex : ARRAY[1..2] OF DINT; // Array of current Actual array indexes when looping through arrays\n    Expected : LREAL; // Single expected value\n    Actual : LREAL; // Single actual value\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\n(* UPPER_BOUND and LOWER_BOUND require literals for their second parameter,\n   so they can't be called in a dimension-based loop.\n   Thus we copy the array dimensions into arrays which accept variable indexes *)\nLowerBoundExpecteds[1] := LOWER_BOUND(Expecteds, 1);\nUpperBoundExpecteds[1] := UPPER_BOUND(Expecteds, 1);\nLowerBoundExpecteds[2] := LOWER_BOUND(Expecteds, 2);\nUpperBoundExpecteds[2] := UPPER_BOUND(Expecteds, 2);\nLowerBoundActuals[1] := LOWER_BOUND(Actuals, 1);\nUpperBoundActuals[1] := UPPER_BOUND(Actuals, 1);\nLowerBoundActuals[2] := LOWER_BOUND(Actuals, 2);\nUpperBoundActuals[2] := UPPER_BOUND(Actuals, 2);\n\nFOR DimensionIndex := 1 TO 2 DO\n    SizeOfExpecteds[DimensionIndex] := ABS(UpperBoundExpecteds[DimensionIndex] - LowerBoundExpecteds[DimensionIndex]) + 1;\n    SizeOfActuals[DimensionIndex] := ABS(UpperBoundActuals[DimensionIndex] - LowerBoundActuals[DimensionIndex]) + 1;\n\n    IF SizeOfExpecteds[DimensionIndex] &lt;&gt; SizeOfActuals[DimensionIndex] THEN\n        Equals := FALSE;\n        SizeEquals := FALSE;\n    END_IF\nEND_FOR\n\nIF SizeEquals THEN\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes in each dimension, which needs to be taken into account. *)\n    FOR Offset[1] := 0 TO SizeOfExpecteds[1] - 1 DO // Iterate Dimension 1\n        FOR Offset[2] := 0 TO SizeOfExpecteds[2] - 1 DO // Iterate Dimension 2\n            // Update index variables\n            FOR DimensionIndex := 1 TO 2 DO\n                ExpectedArrayIndex[DimensionIndex] := LowerBoundExpecteds[DimensionIndex] + Offset[DimensionIndex];\n                ActualArrayIndex[DimensionIndex] := LowerBoundActuals[DimensionIndex] + Offset[DimensionIndex];\n            END_FOR\n\n            // Get array element values\n            Expected := Expecteds[ExpectedArrayIndex[1], ExpectedArrayIndex[2]];\n            Actual := Actuals[ActualArrayIndex[1], ActualArrayIndex[2]]; \n\n            IF ABS(Expected - Actual) &gt; Delta THEN\n                Equals := FALSE;\n                EXIT;\n            END_IF\n        END_FOR\n\n        // Check for loop bailout\n        IF NOT Equals THEN\n            EXIT;\n        END_IF\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds[1] * SizeOfExpecteds[2]),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals[1] * SizeOfActuals[2]),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array2D_LREAL,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = [';\n        ExpectedString := CONCAT(STR1 := ExpectedString,STR2 := DINT_TO_STRING(LowerBoundExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] (');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ')');\n\n        ActualString := 'SIZE = [';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '..');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '..');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] (');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ')');\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := LREAL_TO_STRING(Expected));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := LREAL_TO_STRING(Actual));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArray2dEquals_LREAL.Delta","title":"Delta  <code>LREAL</code>","text":"<p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p>"},{"location":"reference/tcunit/#AssertArray2dEquals_LREAL.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArray2dEquals_LREAL.Expecteds","title":"Expecteds  <code>ARRAY[*,*] OF LREAL</code>","text":"<p>LREAL 2d array with expected values</p>"},{"location":"reference/tcunit/#AssertArray2dEquals_LREAL.Actuals","title":"Actuals  <code>ARRAY[*,*] OF LREAL</code>","text":"<p>LREAL 2d array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArray2dEquals_REAL","title":"AssertArray2dEquals_REAL","text":"<p>Inputs</p> <ul> <li> <code>Delta</code>             \u2013              <p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>REAL 2d array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>REAL 2d array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two REAL 2D-arrays are equal to within a positive delta. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArray2dEquals_REAL\nVAR_IN_OUT\n    Expecteds : ARRAY[*,*] OF REAL; // REAL 2d array with expected values\n    Actuals : ARRAY[*,*] OF REAL; // REAL 2d array with actual values\nEND_VAR\nVAR_INPUT\n    Delta : REAL; // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    DimensionIndex : USINT; // Index when looping through Dimensions\n    LowerBoundExpecteds : ARRAY[1..2] OF DINT; // Lower bounds of Expecteds array in each dimension\n    UpperBoundExpecteds : ARRAY[1..2] OF DINT; // Upper bounds of Expecteds array in each dimension\n    LowerBoundActuals : ARRAY[1..2] OF DINT; // Lower bounds of Actuals array in each dimension\n    UpperBoundActuals : ARRAY[1..2] OF DINT; // Upper bounds of Actuals array in each dimension\n    SizeOfExpecteds : ARRAY[1..2] OF DINT; // Size of Expecteds array in each dimension\n    SizeOfActuals : ARRAY[1..2] OF DINT; // Size of Actuals array in each dimension\n    Offset : ARRAY[1..2] OF DINT; // Current Array index offsets from Lower Bound in each dimension\n    ExpectedArrayIndex : ARRAY[1..2] OF DINT; // Array of current Expected array indexes when looping through arrays\n    ActualArrayIndex : ARRAY[1..2] OF DINT; // Array of current Actual array indexes when looping through arrays\n    Expected : REAL; // Single expected value\n    Actual : REAL; // Single actual value\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\n(* UPPER_BOUND and LOWER_BOUND require literals for their second parameter, \n   so they can't be called in a dimension-based loop.\n   Thus we copy the ARRAY dimensions into arrays which accept variable indexes *)\nLowerBoundExpecteds[1] := LOWER_BOUND(Expecteds, 1);\nUpperBoundExpecteds[1] := UPPER_BOUND(Expecteds, 1);\nLowerBoundExpecteds[2] := LOWER_BOUND(Expecteds, 2);\nUpperBoundExpecteds[2] := UPPER_BOUND(Expecteds, 2);\nLowerBoundActuals[1] := LOWER_BOUND(Actuals, 1);\nUpperBoundActuals[1] := UPPER_BOUND(Actuals, 1);\nLowerBoundActuals[2] := LOWER_BOUND(Actuals, 2);\nUpperBoundActuals[2] := UPPER_BOUND(Actuals, 2);\n\nFOR DimensionIndex := 1 TO 2 DO\n    SizeOfExpecteds[DimensionIndex] := ABS(UpperBoundExpecteds[DimensionIndex] - LowerBoundExpecteds[DimensionIndex]) + 1;\n    SizeOfActuals[DimensionIndex] := ABS(UpperBoundActuals[DimensionIndex] - LowerBoundActuals[DimensionIndex]) + 1;\n\n    IF SizeOfExpecteds[DimensionIndex] &lt;&gt; SizeOfActuals[DimensionIndex] THEN\n        Equals := FALSE;\n        SizeEquals := FALSE;\n    END_IF\nEND_FOR\n\nIF SizeEquals THEN\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes in each dimension, which needs to be taken into account. *)\n    FOR Offset[1] := 0 TO SizeOfExpecteds[1] - 1 DO // Iterate Dimension 1\n        FOR Offset[2] := 0 TO SizeOfExpecteds[2] - 1 DO // Iterate Dimension 2\n            // Update index variables\n            FOR DimensionIndex := 1 TO 2 DO\n                ExpectedArrayIndex[DimensionIndex] := LowerBoundExpecteds[DimensionIndex] + Offset[DimensionIndex];\n                ActualArrayIndex[DimensionIndex] := LowerBoundActuals[DimensionIndex] + Offset[DimensionIndex];\n            END_FOR\n\n            // Get array element values\n            Expected := Expecteds[ExpectedArrayIndex[1], ExpectedArrayIndex[2]];\n            Actual := Actuals[ActualArrayIndex[1], ActualArrayIndex[2]]; \n\n            IF ABS(Expected - Actual) &gt; Delta THEN\n                Equals := FALSE;\n                EXIT;\n            END_IF\n        END_FOR\n\n        // Check for loop bailout\n        IF NOT Equals THEN\n            EXIT;\n        END_IF\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds[1] * SizeOfExpecteds[2]),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals[1] * SizeOfActuals[2]),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array2D_REAL,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = [';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] (');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ')');\n\n        ActualString := 'SIZE = [';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '..');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '..');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] (');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ')');\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := REAL_TO_STRING(Expected));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := REAL_TO_STRING(Actual));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArray2dEquals_REAL.Delta","title":"Delta  <code>REAL</code>","text":"<p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p>"},{"location":"reference/tcunit/#AssertArray2dEquals_REAL.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArray2dEquals_REAL.Expecteds","title":"Expecteds  <code>ARRAY[*,*] OF REAL</code>","text":"<p>REAL 2d array with expected values</p>"},{"location":"reference/tcunit/#AssertArray2dEquals_REAL.Actuals","title":"Actuals  <code>ARRAY[*,*] OF REAL</code>","text":"<p>REAL 2d array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArray3dEquals_LREAL","title":"AssertArray3dEquals_LREAL","text":"<p>Inputs</p> <ul> <li> <code>Delta</code>             \u2013              <p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>LREAL 3d array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>LREAL 3d array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two LREAL 3D-arrays are equal to within a positive delta. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArray3dEquals_LREAL\nVAR_IN_OUT\n    Expecteds : ARRAY[*,*,*] OF LREAL; // LREAL 3d array with expected values\n    Actuals : ARRAY[*,*,*] OF LREAL; // LREAL 3d array with actual values\nEND_VAR\nVAR_INPUT\n    Delta : LREAL; // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    DimensionIndex : USINT;  // Index when looping through Dimensions\n    LowerBoundExpecteds : ARRAY[1..3] OF DINT; // Lower bounds of Expecteds array in each dimension\n    UpperBoundExpecteds : ARRAY[1..3] OF DINT; // Upper bounds of Expecteds array in each dimension\n    LowerBoundActuals : ARRAY[1..3] OF DINT; // Lower bounds of Actuals array in each dimension\n    UpperBoundActuals : ARRAY[1..3] OF DINT; // Upper bounds of Actuals array in each dimension\n    SizeOfExpecteds : ARRAY[1..3] OF DINT; // Size of Expecteds array in each dimension\n    SizeOfActuals : ARRAY[1..3] OF DINT; // Size of Actuals array in each dimension\n    Offset : ARRAY[1..3] OF DINT; // Current Array index offsets from Lower Bound in each dimension\n    ExpectedArrayIndex : ARRAY[1..3] OF DINT; // Array of current Expected array indexes when looping through arrays\n    ActualArrayIndex : ARRAY[1..3] OF DINT; // Array of current Actual array indexes when looping through arrays\n    Expected : LREAL; // Single expected value\n    Actual : LREAL; // Single actual value\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\n(* UPPER_BOUND and LOWER_BOUND require literals for their second parameter,\n   so they can't be called in a dimension-based loop.\n   Thus we copy the array dimensions into arrays which accept variable indexes *)\nLowerBoundExpecteds[1] := LOWER_BOUND(Expecteds, 1);\nUpperBoundExpecteds[1] := UPPER_BOUND(Expecteds, 1);\nLowerBoundExpecteds[2] := LOWER_BOUND(Expecteds, 2);\nUpperBoundExpecteds[2] := UPPER_BOUND(Expecteds, 2);\nLowerBoundExpecteds[3] := LOWER_BOUND(Expecteds, 3);\nUpperBoundExpecteds[3] := UPPER_BOUND(Expecteds, 3);\nLowerBoundActuals[1] := LOWER_BOUND(Actuals, 1);\nUpperBoundActuals[1] := UPPER_BOUND(Actuals, 1);\nLowerBoundActuals[2] := LOWER_BOUND(Actuals, 2);\nUpperBoundActuals[2] := UPPER_BOUND(Actuals, 2);\nLowerBoundActuals[3] := LOWER_BOUND(Actuals, 3);\nUpperBoundActuals[3] := UPPER_BOUND(Actuals, 3);\n\nFOR DimensionIndex := 1 TO 3 DO\n    SizeOfExpecteds[DimensionIndex] := ABS(UpperBoundExpecteds[DimensionIndex] - LowerBoundExpecteds[DimensionIndex]) + 1;\n    SizeOfActuals[DimensionIndex] := ABS(UpperBoundActuals[DimensionIndex] - LowerBoundActuals[DimensionIndex]) + 1;\n\n    IF SizeOfExpecteds[DimensionIndex] &lt;&gt; SizeOfActuals[DimensionIndex] THEN\n        Equals := FALSE;\n        SizeEquals := FALSE;\n    END_IF\nEND_FOR\n\nIF SizeEquals THEN\n    (* Even though we know that both arrays are equal in size, the three arrays can start at three completely different\n       indexes in each dimension, which needs to be taken into account. *)\n    FOR Offset[1] := 0 TO SizeOfExpecteds[1] - 1 DO // Iterate Dimension 1\n        FOR Offset[2] := 0 TO SizeOfExpecteds[2] - 1 DO // Iterate Dimension 2\n            FOR Offset[3] := 0 TO SizeOfExpecteds[3] - 1 DO // Iterate Dimension 3\n                // Update index variables\n                FOR DimensionIndex := 1 TO 3 DO\n                    ExpectedArrayIndex[DimensionIndex] := LowerBoundExpecteds[DimensionIndex] + Offset[DimensionIndex];\n                    ActualArrayIndex[DimensionIndex] := LowerBoundActuals[DimensionIndex] + Offset[DimensionIndex];\n                END_FOR\n\n                // Get array element values\n                Expected := Expecteds[ExpectedArrayIndex[1], ExpectedArrayIndex[2], ExpectedArrayIndex[3]];\n                Actual := Actuals[ActualArrayIndex[1], ActualArrayIndex[2], ActualArrayIndex[3]]; \n\n                IF ABS(Expected - Actual) &gt; Delta THEN\n                    Equals := FALSE;\n                    EXIT;\n                END_IF\n            END_FOR\n\n            // Check for loop bailout\n            IF NOT Equals THEN\n                EXIT;\n            END_IF\n        END_FOR\n\n        // Check for loop bailout\n        IF NOT Equals THEN\n            EXIT;\n        END_IF\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds[1] * SizeOfExpecteds[2] * SizeOfExpecteds[3]),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals[1] * SizeOfActuals[2] * SizeOfActuals[3]),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array3D_LREAL,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = [';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[3]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[3]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] (');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[3]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ')');\n\n        ActualString := 'SIZE = [';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '..');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '..');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[3]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '..');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[3]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] (');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[3]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ')');\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[3]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := LREAL_TO_STRING(Expected) );\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[3]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := LREAL_TO_STRING(Actual));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArray3dEquals_LREAL.Delta","title":"Delta  <code>LREAL</code>","text":"<p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p>"},{"location":"reference/tcunit/#AssertArray3dEquals_LREAL.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArray3dEquals_LREAL.Expecteds","title":"Expecteds  <code>ARRAY[*,*,*] OF LREAL</code>","text":"<p>LREAL 3d array with expected values</p>"},{"location":"reference/tcunit/#AssertArray3dEquals_LREAL.Actuals","title":"Actuals  <code>ARRAY[*,*,*] OF LREAL</code>","text":"<p>LREAL 3d array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArray3dEquals_REAL","title":"AssertArray3dEquals_REAL","text":"<p>Inputs</p> <ul> <li> <code>Delta</code>             \u2013              <p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>REAL 3d array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>REAL 3d array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two REAL 3D-arrays are equal to within a positive delta. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArray3dEquals_REAL\nVAR_IN_OUT\n    Expecteds : ARRAY[*,*,*] OF REAL; // REAL 3d array with expected values\n    Actuals : ARRAY[*,*,*] OF REAL; // REAL 3d array with actual values\nEND_VAR\nVAR_INPUT\n    Delta : REAL; // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    DimensionIndex : USINT;  // Index when looping through Dimensions\n    LowerBoundExpecteds : ARRAY[1..3] OF DINT; // Lower bounds of Expecteds array in each dimension\n    UpperBoundExpecteds : ARRAY[1..3] OF DINT; // Upper bounds of Expecteds array in each dimension\n    LowerBoundActuals : ARRAY[1..3] OF DINT; // Lower bounds of Actuals array in each dimension\n    UpperBoundActuals : ARRAY[1..3] OF DINT; // Upper bounds of Actuals array in each dimension\n    SizeOfExpecteds : ARRAY[1..3] OF DINT; // Size of Expecteds array in each dimension\n    SizeOfActuals : ARRAY[1..3] OF DINT; // Size of Actuals array in each dimension\n    Offset : ARRAY[1..3] OF DINT; // Current Array index offsets from Lower Bound in each dimension\n    ExpectedArrayIndex : ARRAY[1..3] OF DINT; // Array of current Expected array indexes when looping through arrays\n    ActualArrayIndex : ARRAY[1..3] OF DINT; // Array of current Actual array indexes when looping through arrays\n    Expected : REAL; // Single expected value\n    Actual : REAL; // Single actual value\n    ExpectedValueString : T_MaxString;\n    ActualValueString : T_MaxString;\n    FormatString : FB_FormatString; // String formatter for output messages\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\n(* UPPER_BOUND and LOWER_BOUND require literals for their second parameter,\n   so they can't be called in a dimension-based loop.\n   Thus we copy the array dimensions into arrays which accept variable indexes *)\nLowerBoundExpecteds[1] := LOWER_BOUND(Expecteds, 1);\nUpperBoundExpecteds[1] := UPPER_BOUND(Expecteds, 1);\nLowerBoundExpecteds[2] := LOWER_BOUND(Expecteds, 2);\nUpperBoundExpecteds[2] := UPPER_BOUND(Expecteds, 2);\nLowerBoundExpecteds[3] := LOWER_BOUND(Expecteds, 3);\nUpperBoundExpecteds[3] := UPPER_BOUND(Expecteds, 3);\nLowerBoundActuals[1] := LOWER_BOUND(Actuals, 1);\nUpperBoundActuals[1] := UPPER_BOUND(Actuals, 1);\nLowerBoundActuals[2] := LOWER_BOUND(Actuals, 2);\nUpperBoundActuals[2] := UPPER_BOUND(Actuals, 2);\nLowerBoundActuals[3] := LOWER_BOUND(Actuals, 3);\nUpperBoundActuals[3] := UPPER_BOUND(Actuals, 3);\n\nFOR DimensionIndex := 1 TO 3 DO\n    SizeOfExpecteds[DimensionIndex] := ABS(UpperBoundExpecteds[DimensionIndex] - LowerBoundExpecteds[DimensionIndex]) + 1;\n    SizeOfActuals[DimensionIndex] := ABS(UpperBoundActuals[DimensionIndex] - LowerBoundActuals[DimensionIndex]) + 1;\n\n    IF SizeOfExpecteds[DimensionIndex] &lt;&gt; SizeOfActuals[DimensionIndex] THEN\n        Equals := FALSE;\n        SizeEquals := FALSE;\n    END_IF\nEND_FOR\n\nIF SizeEquals THEN\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes in each dimension, which needs to be taken into account. *)\n    FOR Offset[1] := 0 TO SizeOfExpecteds[1] - 1 DO // Iterate Dimension 1\n        FOR Offset[2] := 0 TO SizeOfExpecteds[2] - 1 DO // Iterate Dimension 2\n            FOR Offset[3] := 0 TO SizeOfExpecteds[3] - 1 DO // Iterate Dimension 3\n                // Update index variables\n                FOR DimensionIndex := 1 TO 3 DO\n                    ExpectedArrayIndex[DimensionIndex] := LowerBoundExpecteds[DimensionIndex] + Offset[DimensionIndex];\n                    ActualArrayIndex[DimensionIndex] := LowerBoundActuals[DimensionIndex] + Offset[DimensionIndex];\n                END_FOR\n\n                // Get array element values\n                Expected := Expecteds[ExpectedArrayIndex[1], ExpectedArrayIndex[2], ExpectedArrayIndex[3]];\n                Actual := Actuals[ActualArrayIndex[1], ActualArrayIndex[2], ActualArrayIndex[3]]; \n\n                IF ABS(Expected - Actual) &gt; Delta THEN\n                    Equals := FALSE;\n                    EXIT;\n                END_IF\n            END_FOR\n\n            // Check for loop bailout\n            IF NOT Equals THEN\n                EXIT;\n            END_IF\n        END_FOR\n\n        // Check for loop bailout\n        IF NOT Equals THEN\n            EXIT;\n        END_IF\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds[1] * SizeOfExpecteds[2] * SizeOfExpecteds[3]),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals[1] * SizeOfActuals[2] * SizeOfActuals[3]),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array3D_REAL,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = [';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[3]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[3]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] (');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[3]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ')');\n\n        ActualString := 'SIZE = [';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '..');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '..');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[3]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '..');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[3]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] (');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[3]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ')');\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[1]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[2]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[3]));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := REAL_TO_STRING(Expected) );\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[1]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[2]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ',');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[3]));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := REAL_TO_STRING(Actual));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArray3dEquals_REAL.Delta","title":"Delta  <code>REAL</code>","text":"<p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p>"},{"location":"reference/tcunit/#AssertArray3dEquals_REAL.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArray3dEquals_REAL.Expecteds","title":"Expecteds  <code>ARRAY[*,*,*] OF REAL</code>","text":"<p>REAL 3d array with expected values</p>"},{"location":"reference/tcunit/#AssertArray3dEquals_REAL.Actuals","title":"Actuals  <code>ARRAY[*,*,*] OF REAL</code>","text":"<p>REAL 3d array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_BOOL","title":"AssertArrayEquals_BOOL","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>BOOL array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>BOOL array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two BOOL arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_BOOL\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF BOOL; // BOOL array with expected values\n    Actuals : ARRAY[*] OF BOOL; // BOOL array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_BOOL,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_BOOL,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_BOOL,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := BOOL_TO_STRING(Expecteds[ExpectedsIndex]));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := BOOL_TO_STRING(Actuals[ActualsIndex]));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_BOOL.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_BOOL.Expecteds","title":"Expecteds  <code>ARRAY[*] OF BOOL</code>","text":"<p>BOOL array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_BOOL.Actuals","title":"Actuals  <code>ARRAY[*] OF BOOL</code>","text":"<p>BOOL array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_BYTE","title":"AssertArrayEquals_BYTE","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>BYTE array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>BYTE array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two BYTE arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_BYTE\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF BYTE; // BYTE array with expected values\n    Actuals : ARRAY[*] OF BYTE; // BYTE array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedByteString : STRING;\n    ActualByteString : STRING;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_BYTE,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_BYTE,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_BYTE,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedByteString := CONCAT(STR1 := '0x',\n                                                  STR2 := BYTE_TO_HEXSTR(in := Expecteds[ExpectedsIndex],\n                                                                                       iPrecision := 2,\n                                                                                       bLoCase := FALSE));\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ExpectedByteString);\n\n        ActualByteString := CONCAT(STR1 := '0x',\n                                                STR2 := BYTE_TO_HEXSTR(in := Actuals[ActualsIndex],\n                                                                                     iPrecision := 2,\n                                                                                     bLoCase := FALSE));\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ActualByteString);\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_BYTE.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_BYTE.Expecteds","title":"Expecteds  <code>ARRAY[*] OF BYTE</code>","text":"<p>BYTE array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_BYTE.Actuals","title":"Actuals  <code>ARRAY[*] OF BYTE</code>","text":"<p>BYTE array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_DINT","title":"AssertArrayEquals_DINT","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>DINT array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>DINT array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two DINT arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_DINT\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF DINT; // DINT array with expected values\n    Actuals : ARRAY[*] OF DINT; // DINT array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_DINT,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_DINT,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_DINT,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(Expecteds[ExpectedsIndex]));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(Actuals[ActualsIndex]));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_DINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_DINT.Expecteds","title":"Expecteds  <code>ARRAY[*] OF DINT</code>","text":"<p>DINT array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_DINT.Actuals","title":"Actuals  <code>ARRAY[*] OF DINT</code>","text":"<p>DINT array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_DWORD","title":"AssertArrayEquals_DWORD","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>DWORD array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>DWORD array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two DWORD arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_DWORD\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF DWORD; // DWORD array with expected values\n    Actuals : ARRAY[*] OF DWORD; // DWORD array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedDWordString : STRING;\n    ActualDWordString : STRING;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_DWORD,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_DWORD,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_DWORD,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedDWordString := CONCAT(STR1 := '0x',\n                                                   STR2 := DWORD_TO_HEXSTR(in := Expecteds[ExpectedsIndex],\n                                                                                         iPrecision := 8,\n                                                                                         bLoCase := FALSE));\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ExpectedDWordString);\n\n        ActualDWordString := CONCAT(STR1 := '0x',\n                                                 STR2 := DWORD_TO_HEXSTR(in := Actuals[ActualsIndex],\n                                                                                       iPrecision := 8,\n                                                                                       bLoCase := FALSE));\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ActualDWordString);\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_DWORD.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_DWORD.Expecteds","title":"Expecteds  <code>ARRAY[*] OF DWORD</code>","text":"<p>DWORD array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_DWORD.Actuals","title":"Actuals  <code>ARRAY[*] OF DWORD</code>","text":"<p>DWORD array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_INT","title":"AssertArrayEquals_INT","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>INT array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>INT array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two INT arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_INT\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF INT; // INT array with expected values\n    Actuals : ARRAY[*] OF INT; // INT array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_INT,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_INT,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_INT,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := INT_TO_STRING(Expecteds[ExpectedsIndex]));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := INT_TO_STRING(Actuals[ActualsIndex]));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_INT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_INT.Expecteds","title":"Expecteds  <code>ARRAY[*] OF INT</code>","text":"<p>INT array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_INT.Actuals","title":"Actuals  <code>ARRAY[*] OF INT</code>","text":"<p>INT array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_LINT","title":"AssertArrayEquals_LINT","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>LINT array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>LINT array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two LINT arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_LINT\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF LINT; // LINT array with expected values\n    Actuals : ARRAY[*] OF LINT; // LINT array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_LINT,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_LINT,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_LINT,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := LINT_TO_STRING(Expecteds[ExpectedsIndex]));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := LINT_TO_STRING(Actuals[ActualsIndex]));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_LINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_LINT.Expecteds","title":"Expecteds  <code>ARRAY[*] OF LINT</code>","text":"<p>LINT array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_LINT.Actuals","title":"Actuals  <code>ARRAY[*] OF LINT</code>","text":"<p>LINT array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_LREAL","title":"AssertArrayEquals_LREAL","text":"<p>Inputs</p> <ul> <li> <code>Delta</code>             \u2013              <p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>LREAL array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>LREAL array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two LREAL arrays are equal to within a positive delta. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_LREAL\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF LREAL; // LREAL array with expected values\n    Actuals : ARRAY[*] OF LREAL; // LREAL array with actual values\nEND_VAR\nVAR_INPUT\n    Delta : LREAL; // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF ABS(Expecteds[ExpectedsIndex] - Actuals[ActualsIndex]) &gt; Delta THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_LREAL,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := LREAL_TO_STRING(Expecteds[ExpectedsIndex]));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := LREAL_TO_STRING(Actuals[ActualsIndex]));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_LREAL.Delta","title":"Delta  <code>LREAL</code>","text":"<p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p>"},{"location":"reference/tcunit/#AssertArrayEquals_LREAL.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_LREAL.Expecteds","title":"Expecteds  <code>ARRAY[*] OF LREAL</code>","text":"<p>LREAL array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_LREAL.Actuals","title":"Actuals  <code>ARRAY[*] OF LREAL</code>","text":"<p>LREAL array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_LWORD","title":"AssertArrayEquals_LWORD","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>LWORD array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>LWORD array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two LWORD arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_LWORD\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF LWORD; // LWORD array with expected values\n    Actuals : ARRAY[*] OF LWORD; // LWORD array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedLWordString : STRING;\n    ActualLWordString : STRING;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_LWORD,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_LWORD,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_LWORD,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedLWordString := CONCAT(STR1 := '0x',\n                                                  STR2 := LWORD_TO_HEXSTR(in := Expecteds[ExpectedsIndex],\n                                                                                        iPrecision := 16,\n                                                                                        bLoCase := FALSE));\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ExpectedLWordString);\n\n        ActualLWordString := CONCAT(STR1 := '0x',\n                                                 STR2 := LWORD_TO_HEXSTR(in := Actuals[ActualsIndex],\n                                                                                       iPrecision := 16,\n                                                                                       bLoCase := FALSE));\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ActualLWordString);\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_LWORD.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_LWORD.Expecteds","title":"Expecteds  <code>ARRAY[*] OF LWORD</code>","text":"<p>LWORD array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_LWORD.Actuals","title":"Actuals  <code>ARRAY[*] OF LWORD</code>","text":"<p>LWORD array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_REAL","title":"AssertArrayEquals_REAL","text":"<p>Inputs</p> <ul> <li> <code>Delta</code>             \u2013              <p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>REAL array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>REAL array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two REAL arrays are equal to within a positive delta. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_REAL\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF REAL; // REAL array with expected values\n    Actuals : ARRAY[*] OF REAL; // REAL array with actual values\nEND_VAR\nVAR_INPUT\n    Delta : REAL; // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF ABS(Expecteds[ExpectedsIndex] - Actuals[ActualsIndex]) &gt; Delta THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_REAL,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := REAL_TO_STRING(Expecteds[ExpectedsIndex]));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := REAL_TO_STRING(Actuals[ActualsIndex]));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_REAL.Delta","title":"Delta  <code>REAL</code>","text":"<p>The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the expected value in that array cell</p>"},{"location":"reference/tcunit/#AssertArrayEquals_REAL.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_REAL.Expecteds","title":"Expecteds  <code>ARRAY[*] OF REAL</code>","text":"<p>REAL array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_REAL.Actuals","title":"Actuals  <code>ARRAY[*] OF REAL</code>","text":"<p>REAL array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_SINT","title":"AssertArrayEquals_SINT","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>SINT array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>SINT array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two SINT arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_SINT\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF SINT; // SINT array with expected values\n    Actuals : ARRAY[*] OF SINT; // SINT array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_SINT,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_SINT,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_SINT,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := SINT_TO_STRING(Expecteds[ExpectedsIndex]));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := SINT_TO_STRING(Actuals[ActualsIndex]));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_SINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_SINT.Expecteds","title":"Expecteds  <code>ARRAY[*] OF SINT</code>","text":"<p>SINT array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_SINT.Actuals","title":"Actuals  <code>ARRAY[*] OF SINT</code>","text":"<p>SINT array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_UDINT","title":"AssertArrayEquals_UDINT","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>UDINT array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>UDINT array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two UDINT arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_UDINT\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF UDINT; // UDINT array with expected values\n    Actuals : ARRAY[*] OF UDINT; // UDINT array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_UDINT,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_UDINT,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_UDINT,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := UDINT_TO_STRING(Expecteds[ExpectedsIndex]));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := \nCONCAT(STR1 := ActualString, STR2 := UDINT_TO_STRING(Actuals[ActualsIndex]));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_UDINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_UDINT.Expecteds","title":"Expecteds  <code>ARRAY[*] OF UDINT</code>","text":"<p>UDINT array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_UDINT.Actuals","title":"Actuals  <code>ARRAY[*] OF UDINT</code>","text":"<p>UDINT array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_UINT","title":"AssertArrayEquals_UINT","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>UINT array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>UINT array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two UINT arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_UINT\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF UINT; // UINT array with expected values\n    Actuals : ARRAY[*] OF UINT; // UINT array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_UINT,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_UINT,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_UINT,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := UINT_TO_STRING(Expecteds[ExpectedsIndex]));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := UINT_TO_STRING(Actuals[ActualsIndex]));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_UINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_UINT.Expecteds","title":"Expecteds  <code>ARRAY[*] OF UINT</code>","text":"<p>UINT array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_UINT.Actuals","title":"Actuals  <code>ARRAY[*] OF UINT</code>","text":"<p>UINT array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_ULINT","title":"AssertArrayEquals_ULINT","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>ULINT array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>ULINT array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two ULINT arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_ULINT\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF ULINT; // ULINT array with expected values\n    Actuals : ARRAY[*] OF ULINT; // ULINT array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_ULINT,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_ULINT,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_ULINT,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ULINT_TO_STRING(Expecteds[ExpectedsIndex]));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ULINT_TO_STRING(Actuals[ActualsIndex]));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_ULINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_ULINT.Expecteds","title":"Expecteds  <code>ARRAY[*] OF ULINT</code>","text":"<p>ULINT array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_ULINT.Actuals","title":"Actuals  <code>ARRAY[*] OF ULINT</code>","text":"<p>ULINT array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_USINT","title":"AssertArrayEquals_USINT","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>USINT array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>USINT array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two USINT arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_USINT\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF USINT; // USINT array with expected values\n    Actuals : ARRAY[*] OF USINT; // USINT array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_USINT,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_USINT,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_USINT,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := USINT_TO_STRING(Expecteds[ExpectedsIndex]));\n\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := USINT_TO_STRING(Actuals[ActualsIndex]));\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_USINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_USINT.Expecteds","title":"Expecteds  <code>ARRAY[*] OF USINT</code>","text":"<p>USINT array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_USINT.Actuals","title":"Actuals  <code>ARRAY[*] OF USINT</code>","text":"<p>USINT array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertArrayEquals_WORD","title":"AssertArrayEquals_WORD","text":"<p>Inputs</p> <ul> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> <p>In/Outputs</p> <ul> <li> <code>Expecteds</code>             \u2013              <p>WORD array with expected values</p> </li> <li> <code>Actuals</code>             \u2013              <p>WORD array with actual values</p> </li> </ul> Source Code <pre><code>// Asserts that two WORD arrays are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertArrayEquals_WORD\nVAR_IN_OUT\n    Expecteds : ARRAY[*] OF WORD; // WORD array with expected values\n    Actuals : ARRAY[*] OF WORD; // WORD array with actual values\nEND_VAR\nVAR_INPUT\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Equals : BOOL := TRUE;\n    SizeEquals : BOOL := TRUE;\n    Index : DINT;\n    ExpectedString : T_MaxString;\n    ActualString : T_MaxString;\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\n    SizeOfExpecteds : DINT;\n    SizeOfActuals : DINT;\n    ExpectedDWordString : STRING;\n    ActualDWordString : STRING;\n    ExpectedsIndex : DINT;\n    ActualsIndex : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\n\nSizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;\nSizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;\n\nIF SizeOfExpecteds &lt;&gt; SizeOfActuals THEN\n    Equals := FALSE;\n    SizeEquals := FALSE;\nELSE\n    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different\n       indexes, which needs to be taken into account for. *)\n    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds\n    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals\n    FOR Index := 1 TO SizeOfExpecteds BY 1 DO\n        IF Expecteds[ExpectedsIndex] &lt;&gt; Actuals[ActualsIndex] THEN\n            Equals := FALSE;\n            EXIT;\n        END_IF\n        ExpectedsIndex := ExpectedsIndex + 1;\n        ActualsIndex := ActualsIndex + 1;\n    END_FOR\nEND_IF\n\nAssertArrayResults.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),\n                                ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_WORD,\n                                ActualsSize := DINT_TO_UDINT(SizeOfActuals),\n                                ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_WORD,\n                                Message := Message,\n                                TestInstancePath := TestInstancePath,\n                                AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND NOT Equals THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_Array_WORD,\n                  AssertionMessage := Message);\n\n    IF NOT SizeEquals THEN\n        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');\n        ExpectedString := 'SIZE = ';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));\n        ActualString := 'SIZE = ';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));\n    ELSE\n        ExpectedDWordString := CONCAT(STR1 := '0x',\n                                                  STR2 := WORD_TO_HEXSTR(in := Expecteds[ExpectedsIndex],\n                                                                                       iPrecision := 4,\n                                                                                       bLoCase := FALSE));\n        ExpectedString := 'ARRAY[';\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');\n        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ExpectedDWordString);\n\n        ActualDWordString := CONCAT(STR1 := '0x',\n                                                 STR2 := WORD_TO_HEXSTR(in := Actuals[ActualsIndex],\n                                                                                      iPrecision := 4,\n                                                                                      bLoCase := FALSE));\n        ActualString := 'ARRAY[';\n        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));\n        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');\n        ActualString := CONCAT(STR1 := ActualString, STR2 := ActualDWordString);\n    END_IF\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,\n                                            Actual := ActualString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertArrayEquals_WORD.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#AssertArrayEquals_WORD.Expecteds","title":"Expecteds  <code>ARRAY[*] OF WORD</code>","text":"<p>WORD array with expected values</p>"},{"location":"reference/tcunit/#AssertArrayEquals_WORD.Actuals","title":"Actuals  <code>ARRAY[*] OF WORD</code>","text":"<p>WORD array with actual values</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals","title":"AssertEquals","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>Expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>The value to check against expected</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>(*\n    Asserts that two objects (of any type) are equal. If they are not, an assertion error is created.\n    For REAL and LREAL it's recommended to use the AssertEquals_REAL or AssertEquals_LREAL respectively\n    as these give the possibility to specify a delta between the expected and actual value.\n*)\nMETHOD PUBLIC AssertEquals\nVAR_INPUT\n    Expected : ANY; // Expected value\n    Actual : ANY; // The value to check against expected\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    Count : DINT;\n    ExpectedDataString : T_MaxString;\n    ActualDataString : T_MaxString;\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\n\n    boolExpected : BOOL;\n    boolActual : BOOL;\n    byteExpected : BYTE;\n    byteActual : BYTE;\n    dateExpected : DATE;\n    dateActual : DATE;\n    dateAndTimeExpected : DATE_AND_TIME;\n    dateAndTimeActual : DATE_AND_TIME;\n    dintExpected : DINT;\n    dintActual : DINT;\n    dwordExpected : DWORD;\n    dwordActual : DWORD;\n    intExpected : INT;\n    intActual : INT;\n    lintExpected : LINT;\n    lintActual : LINT;\n    lrealExpected : LREAL;\n    lrealActual : LREAL;\n    ltimeExpected : LTIME;\n    ltimeActual : LTIME;\n    lwordExpected : LWORD;\n    lwordActual : LWORD;\n    realExpected : REAL;\n    realActual : REAL;\n    sintExpected : SINT;\n    sintActual : SINT;\n    stringExpected : T_MaxString;\n    stringActual : T_MaxString;\n    wstringExpected : WSTRING(255);\n    wstringActual : WSTRING(255);\n    timeExpected : TIME;\n    timeActual : TIME;\n    timeOfDayExpected : TIME_OF_DAY;\n    timeOfDayActual : TIME_OF_DAY;\n    udintExpected : UDINT;\n    udintActual : UDINT;\n    uintExpected : UINT;\n    uintActual : UINT;\n    ulintExpected : ULINT;\n    ulintActual : ULINT;\n    usintExpected : USINT;\n    usintActual : USINT;\n    wordExpected : WORD;\n    wordActual : WORD;\n\n    (* ANY comparison variables *)\n    DataTypesNotEquals : BOOL; // The data type of the two ANY input parameters are not equal\n    DataSizeNotEquals : BOOL; // The data size of the two ANY input parameters are not equal\n    DataContentNotEquals : BOOL; // The data content of the two ANY input parameters are not equal\n    IteratorCounter : DINT;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\n(*\n    This compares two instances of any object type and returns whether they\n    are the same type, size and value or not. This is necessary for two reasons:\n    1. So that we can know exactly what differs between the two input parameters\n    2. It's not possible to do a comparison (= or &lt;&gt;) between two instances of ANY. \n*)\n// Check whether the type of the inputs differs\nIF Expected.TypeClass &lt;&gt; Actual.TypeClass THEN\n    DataTypesNotEquals := TRUE;\nEND_IF\n\n// Check whether the size of the inputs differs\nIF NOT DataTypesNotEquals THEN\n    (* Take special care of STRING and WSTRING, as these can be declared with different sizes,\n       although their content might be the same *)\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_STRING THEN\n        MEMCPY(destAddr := ADR(stringExpected), srcAddr := Expected.pValue, n := DINT_TO_UDINT(Expected.diSize));\n        MEMCPY(destAddr := ADR(stringActual), srcAddr := Actual.pValue, n := DINT_TO_UDINT(Actual.diSize));\n        DataSizeNotEquals := LEN(STR := stringExpected) &lt;&gt; LEN(STR := stringActual);\n    ELSIF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_WSTRING THEN\n        MEMCPY(destAddr := ADR(wstringExpected), srcAddr := Expected.pValue, n := DINT_TO_UDINT(Expected.diSize));\n        MEMCPY(destAddr := ADR(wstringActual), srcAddr := Actual.pValue, n := DINT_TO_UDINT(Actual.diSize));\n        DataSizeNotEquals := WLEN(STR := wstringExpected) &lt;&gt; WLEN(STR := wstringActual);\n    ELSIF (Expected.diSize &lt;&gt; Actual.diSize) THEN\n        DataSizeNotEquals := TRUE;\n    END_IF\nEND_IF\n\n// Even though the data type and size are equals, the contents may still differ\nIF NOT DataTypesNotEquals AND NOT DataSizeNotEquals THEN\n    // Compare each byte in the ANY-types\n    FOR IteratorCounter := 0 TO Expected.diSize - 1 BY 1 DO\n        IF Expected.pValue[IteratorCounter] &lt;&gt; Actual.pValue[IteratorCounter] THEN\n            DataContentNotEquals := TRUE;\n            EXIT;\n        END_IF\n    END_FOR\nEND_IF\n\n(* First check whether the input data are any of the standard data types that are supported by TcUnit.\n   In this case call the standard Assert-methods for that data. But before doing that we need to make sure\n   that both the expected and actual:\n   - Have both the same data type\n   - Both have the same data size\n*)\nIF NOT DataTypesNotEquals AND NOT DataSizeNotEquals THEN\n\n    // BOOL\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_BOOL THEN\n        MEMCPY(destAddr := ADR(boolExpected), srcAddr := Expected.pValue, n := SIZEOF(BOOL));\n        MEMCPY(destAddr := ADR(boolActual), srcAddr := Actual.pValue, n := SIZEOF(BOOL));\n        AssertEquals_BOOL(Expected := boolExpected, Actual := boolActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // BYTE\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_BYTE THEN\n        MEMCPY(destAddr := ADR(byteExpected), srcAddr := Expected.pValue, n := SIZEOF(BYTE));\n        MEMCPY(destAddr := ADR(byteActual), srcAddr := Actual.pValue, n := SIZEOF(BYTE));\n        AssertEquals_BYTE(Expected := byteExpected, Actual := byteActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // DATE\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_DATE THEN\n        MEMCPY(destAddr := ADR(dateExpected), srcAddr := Expected.pValue, n := SIZEOF(DATE));\n        MEMCPY(destAddr := ADR(dateActual), srcAddr := Actual.pValue, n := SIZEOF(DATE));\n        AssertEquals_DATE(Expected := dateExpected, Actual := dateActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // DATE_AND_TIME\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_DATEANDTIME THEN\n        MEMCPY(destAddr := ADR(dateAndTimeExpected), srcAddr := Expected.pValue, n := SIZEOF(DATE_AND_TIME));\n        MEMCPY(destAddr := ADR(dateAndTimeActual), srcAddr := Actual.pValue, n := SIZEOF(DATE_AND_TIME));\n        AssertEquals_DATE_AND_TIME(Expected := dateAndTimeExpected, Actual := dateAndTimeActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // DINT\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_DINT THEN\n        MEMCPY(destAddr := ADR(dintExpected), srcAddr := Expected.pValue, n := SIZEOF(DINT));\n        MEMCPY(destAddr := ADR(dintActual), srcAddr := Actual.pValue, n := SIZEOF(DINT));\n        AssertEquals_DINT(Expected := dintExpected, Actual := dintActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // DWORD\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_DWORD THEN\n        MEMCPY(destAddr := ADR(dwordExpected), srcAddr := Expected.pValue, n := SIZEOF(DWORD));\n        MEMCPY(destAddr := ADR(dwordActual), srcAddr := Actual.pValue, n := SIZEOF(DWORD));\n        AssertEquals_DWORD(Expected := dwordExpected, Actual := dwordActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // INT\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_INT THEN\n        MEMCPY(destAddr := ADR(intExpected), srcAddr := Expected.pValue, n := SIZEOF(INT));\n        MEMCPY(destAddr := ADR(intActual), srcAddr := Actual.pValue, n := SIZEOF(INT));\n        AssertEquals_INT(Expected := intExpected, Actual := intActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // LINT\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_LINT THEN\n        MEMCPY(destAddr := ADR(lintExpected), srcAddr := Expected.pValue, n := SIZEOF(LINT));\n        MEMCPY(destAddr := ADR(lintActual), srcAddr := Actual.pValue, n := SIZEOF(LINT));\n        AssertEquals_LINT(Expected := lintExpected, Actual := lintActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // LREAL\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_LREAL THEN\n        MEMCPY(destAddr := ADR(lrealExpected), srcAddr := Expected.pValue, n := SIZEOF(LREAL));\n        MEMCPY(destAddr := ADR(lrealActual), srcAddr := Actual.pValue, n := SIZEOF(LREAL));\n        AssertEquals_LREAL(Expected := lrealExpected, Actual := lrealActual, Delta := 0.0, Message := Message);\n        RETURN;\n    END_IF\n\n    // LTIME\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_LTIME THEN\n        MEMCPY(destAddr := ADR(ltimeExpected), srcAddr := Expected.pValue, n := SIZEOF(LTIME));\n        MEMCPY(destAddr := ADR(ltimeActual), srcAddr := Actual.pValue, n := SIZEOF(LTIME));\n        AssertEquals_LTIME(Expected := ltimeExpected, Actual := ltimeActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // LWORD\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_LWORD THEN\n        MEMCPY(destAddr := ADR(lwordExpected), srcAddr := Expected.pValue, n := SIZEOF(LWORD));\n        MEMCPY(destAddr := ADR(lwordActual), srcAddr := Actual.pValue, n := SIZEOF(LWORD));\n        AssertEquals_LWORD(Expected := lwordExpected, Actual := lwordActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // REAL\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_REAL THEN\n        MEMCPY(destAddr := ADR(realExpected), srcAddr := Expected.pValue, n := SIZEOF(REAL));\n        MEMCPY(destAddr := ADR(realActual), srcAddr := Actual.pValue, n := SIZEOF(REAL));\n        AssertEquals_REAL(Expected := realExpected, Actual := realActual, Delta := 0.0, Message := Message);\n        RETURN;\n    END_IF\n\n    // SINT\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_SINT THEN\n        MEMCPY(destAddr := ADR(sintExpected), srcAddr := Expected.pValue, n := SIZEOF(SINT));\n        MEMCPY(destAddr := ADR(sintActual), srcAddr := Actual.pValue, n := SIZEOF(SINT));\n        AssertEquals_SINT(Expected := sintExpected, Actual := sintActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // STRING\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_STRING THEN\n        MEMCPY(destAddr := ADR(stringExpected), srcAddr := Expected.pValue, n := DINT_TO_UDINT(Expected.diSize));\n        MEMCPY(destAddr := ADR(stringActual), srcAddr := Actual.pValue, n := DINT_TO_UDINT(Actual.diSize));\n        AssertEquals_STRING(Expected := stringExpected, Actual := stringActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // WSTRING\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_WSTRING THEN\n        MEMCPY(destAddr := ADR(wstringExpected), srcAddr := Expected.pValue, n := DINT_TO_UDINT(Expected.diSize));\n        MEMCPY(destAddr := ADR(wstringActual), srcAddr := Actual.pValue, n := DINT_TO_UDINT(Actual.diSize));\n        AssertEquals_WSTRING(Expected := wstringExpected, Actual := wstringActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // TIME\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_TIME THEN\n        MEMCPY(destAddr := ADR(timeExpected), srcAddr := Expected.pValue, n := SIZEOF(TIME));\n        MEMCPY(destAddr := ADR(timeActual), srcAddr := Actual.pValue, n := SIZEOF(TIME));\n        AssertEquals_TIME(Expected := timeExpected, Actual := timeActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // TIME_OF_DAY\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_TIMEOFDAY THEN\n        MEMCPY(destAddr := ADR(timeOfDayExpected), srcAddr := Expected.pValue, n := SIZEOF(TIME_OF_DAY));\n        MEMCPY(destAddr := ADR(timeOfDayActual), srcAddr := Actual.pValue, n := SIZEOF(TIME_OF_DAY));\n        AssertEquals_TIME_OF_DAY(Expected := timeOfDayExpected, Actual := timeOfDayActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // UDINT\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_UDINT THEN\n        MEMCPY(destAddr := ADR(udintExpected), srcAddr := Expected.pValue, n := SIZEOF(UDINT));\n        MEMCPY(destAddr := ADR(udintActual), srcAddr := Actual.pValue, n := SIZEOF(UDINT));\n        AssertEquals_UDINT(Expected := udintExpected, Actual := udintActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // UINT\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_UINT THEN\n        MEMCPY(destAddr := ADR(uintExpected), srcAddr := Expected.pValue, n := SIZEOF(UINT));\n        MEMCPY(destAddr := ADR(uintActual), srcAddr := Actual.pValue, n := SIZEOF(UINT));\n        AssertEquals_UINT(Expected := uintExpected, Actual := uintActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // ULINT\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_ULINT THEN\n        MEMCPY(destAddr := ADR(ulintExpected), srcAddr := Expected.pValue, n := SIZEOF(ULINT));\n        MEMCPY(destAddr := ADR(ulintActual), srcAddr := Actual.pValue, n := SIZEOF(ULINT));\n        AssertEquals_ULINT(Expected := ulintExpected, Actual := ulintActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // USINT\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_USINT THEN\n        MEMCPY(destAddr := ADR(usintExpected), srcAddr := Expected.pValue, n := SIZEOF(USINT));\n        MEMCPY(destAddr := ADR(usintActual), srcAddr := Actual.pValue, n := SIZEOF(USINT));\n        AssertEquals_USINT(Expected := usintExpected, Actual := usintActual, Message := Message);\n        RETURN;\n    END_IF\n\n    // WORD\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_WORD THEN\n        MEMCPY(destAddr := ADR(wordExpected), srcAddr := Expected.pValue, n := SIZEOF(WORD));\n        MEMCPY(destAddr := ADR(wordActual), srcAddr := Actual.pValue, n := SIZEOF(WORD));\n        AssertEquals_WORD(Expected := wordExpected, Actual := wordActual, Message := Message);\n        RETURN;\n    END_IF\n\nEND_IF\n\n(* If we've come to this row, it means that the data input is not any of the standard primitive data types, and thus\n   we need to do special handling *)\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nIF DataTypesNotEquals THEN\n    ExpectedDataString := CONCAT(STR1 := '(Type class = ', STR2 := F_AnyTypeClassToString((Expected.TypeClass)));\n    ExpectedDataString := CONCAT(STR1 := ExpectedDataString, STR2 := ')');\n    ActualDataString := CONCAT(STR1 := '(Type class = ', STR2 := F_AnyTypeClassToString(Actual.TypeClass));\n    ActualDataString := CONCAT(STR1 := ActualDataString, STR2 := ')');\nELSIF DataSizeNotEquals THEN\n    (* Take special care of STRING and WSTRING, as these can be declared with different sizes,\n       although their content might be the same *)\n    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_STRING THEN\n        MEMCPY(destAddr := ADR(stringExpected), srcAddr := Expected.pValue, n := DINT_TO_UDINT(Expected.diSize));\n        MEMCPY(destAddr := ADR(stringActual), srcAddr := Actual.pValue, n := DINT_TO_UDINT(Actual.diSize));\n        ExpectedDataString := CONCAT(STR1 := '(Data size (LEN) = ', STR2 := INT_TO_STRING(LEN(STR := stringExpected)));\n        ActualDataString := CONCAT(STR1 := '(Data size (LEN) = ', STR2 := INT_TO_STRING(LEN(STR := stringActual)));\n    ELSIF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_WSTRING THEN\n        MEMCPY(destAddr := ADR(wstringExpected), srcAddr := Expected.pValue, n := DINT_TO_UDINT(Expected.diSize));\n        MEMCPY(destAddr := ADR(wstringActual), srcAddr := Actual.pValue, n := DINT_TO_UDINT(Actual.diSize));\n        ExpectedDataString := CONCAT(STR1 := '(Data size (WLEN) = ', STR2 := INT_TO_STRING(WLEN(STR := wstringExpected)));\n        ActualDataString := CONCAT(STR1 := '(Data size (WLEN) = ', STR2 := INT_TO_STRING(WLEN(STR := wstringActual)));\n    ELSE\n        ExpectedDataString := CONCAT(STR1 := '(Data size = ', STR2 := DINT_TO_STRING(Expected.diSize));\n        ActualDataString := CONCAT(STR1 := '(Data size = ', STR2 := DINT_TO_STRING(Actual.diSize));\n    END_IF\n    ExpectedDataString := CONCAT(STR1 := ExpectedDataString, STR2 := ')');\n    ActualDataString := CONCAT(STR1 := ActualDataString, STR2 := ')');\nELSIF DataContentNotEquals THEN\n    FOR Count := 0 TO MIN(Expected.diSize-1, 38) BY 1 DO // One byte will equal two characters (example: 255 = 0xff, 1 = 0x01)\n        ExpectedDataString := CONCAT(STR1 := ExpectedDataString,\n                                                  STR2 := BYTE_TO_HEXSTR(in := Expected.pValue[Count],\n                                                                                       iPrecision := 2,\n                                                                                       bLoCase := FALSE));\n    END_FOR\n    ExpectedDataString := CONCAT(STR1 := '0x', STR2 := ExpectedDataString);\n\n    FOR Count := 0 TO MIN(Actual.diSize-1, 38) BY 1 DO // One byte will equal two characters (example: 255 = 0xff, 1 = 0x01)\n        ActualDataString := CONCAT(STR1 := ActualDataString,\n                                                STR2 := BYTE_TO_HEXSTR(in := Actual.pValue[Count],\n                                                                                     iPrecision := 2,\n                                                                                     bLoCase := FALSE));\n    END_FOR\n    ActualDataString := CONCAT(STR1 := '0x', STR2 := ActualDataString);\nEND_IF\n\nAssertResults.ReportResult(ExpectedSize := DINT_TO_UDINT(Expected.diSize),\n                           ExpectedTypeClass := UDINT_TO_INT(Expected.TypeClass),\n                           ExpectedValue := Expected.pValue,\n                           ActualSize := DINT_TO_UDINT(Actual.diSize),\n                           ActualTypeClass := UDINT_TO_INT(Actual.TypeClass),\n                           ActualValue := Actual.pValue,\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND (DataTypesNotEquals OR DataSizeNotEquals OR DataContentNotEquals) THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_ANY,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedDataString,\n                                            Actual := ActualDataString,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals.Expected","title":"Expected  <code>ANY</code>","text":"<p>Expected value</p>"},{"location":"reference/tcunit/#AssertEquals.Actual","title":"Actual  <code>ANY</code>","text":"<p>The value to check against expected</p>"},{"location":"reference/tcunit/#AssertEquals.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_BOOL","title":"AssertEquals_BOOL","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>BOOL expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>BOOL actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two BOOLs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_BOOL\nVAR_INPUT\n    Expected : BOOL; // BOOL expected value\n    Actual : BOOL; // BOOL actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_BOOL,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_BOOL,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_BOOL,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := BOOL_TO_STRING(Expected),\n                                            Actual := BOOL_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_BOOL.Expected","title":"Expected  <code>BOOL</code>","text":"<p>BOOL expected value</p>"},{"location":"reference/tcunit/#AssertEquals_BOOL.Actual","title":"Actual  <code>BOOL</code>","text":"<p>BOOL actual value</p>"},{"location":"reference/tcunit/#AssertEquals_BOOL.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_BYTE","title":"AssertEquals_BYTE","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>BYTE expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>BYTE actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two BYTEs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_BYTE\nVAR_INPUT\n    Expected : BYTE; // BYTE expected value\n    Actual : BYTE; // BYTE actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_BYTE,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_BYTE,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_BYTE,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := CONCAT(\n                                                       STR1 := '0x',\n                                                       STR2 := BYTE_TO_HEXSTR(in := Expected,\n                                                                                            iPrecision := 2,\n                                                                                            bLoCase := FALSE)),\n                                            Actual := CONCAT(\n                                                       STR1 := '0x',\n                                                       STR2 := BYTE_TO_HEXSTR(in := Actual,\n                                                                                            iPrecision := 2,\n                                                                                            bLoCase := FALSE)),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_BYTE.Expected","title":"Expected  <code>BYTE</code>","text":"<p>BYTE expected value</p>"},{"location":"reference/tcunit/#AssertEquals_BYTE.Actual","title":"Actual  <code>BYTE</code>","text":"<p>BYTE actual value</p>"},{"location":"reference/tcunit/#AssertEquals_BYTE.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_DATE","title":"AssertEquals_DATE","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>DATE expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>DATE actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two DATEs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_DATE\nVAR_INPUT\n    Expected : DATE; // DATE expected value\n    Actual : DATE; // DATE actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_DATE,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_DATE,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_DATE,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := DATE_TO_STRING(Expected),\n                                            Actual := DATE_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_DATE.Expected","title":"Expected  <code>DATE</code>","text":"<p>DATE expected value</p>"},{"location":"reference/tcunit/#AssertEquals_DATE.Actual","title":"Actual  <code>DATE</code>","text":"<p>DATE actual value</p>"},{"location":"reference/tcunit/#AssertEquals_DATE.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_DATE_AND_TIME","title":"AssertEquals_DATE_AND_TIME","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>DATE_AND_TIME expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>DATE_AND_TIME actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two DATE_AND_TIMEs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_DATE_AND_TIME\nVAR_INPUT\n    Expected : DATE_AND_TIME; // DATE_AND_TIME expected value\n    Actual : DATE_AND_TIME; // DATE_AND_TIME actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_DATEANDTIME,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_DATEANDTIME,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_DATE_AND_TIME,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := DT_TO_STRING(Expected),\n                                            Actual := DT_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_DATE_AND_TIME.Expected","title":"Expected  <code>DATE_AND_TIME</code>","text":"<p>DATE_AND_TIME expected value</p>"},{"location":"reference/tcunit/#AssertEquals_DATE_AND_TIME.Actual","title":"Actual  <code>DATE_AND_TIME</code>","text":"<p>DATE_AND_TIME actual value</p>"},{"location":"reference/tcunit/#AssertEquals_DATE_AND_TIME.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_DINT","title":"AssertEquals_DINT","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>DINT expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>DINT actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two DINTs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_DINT\nVAR_INPUT\n    Expected : DINT; // DINT expected value\n    Actual : DINT; // DINT actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_DINT,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_DINT,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_DINT,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := DINT_TO_STRING(Expected),\n                                            Actual := DINT_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_DINT.Expected","title":"Expected  <code>DINT</code>","text":"<p>DINT expected value</p>"},{"location":"reference/tcunit/#AssertEquals_DINT.Actual","title":"Actual  <code>DINT</code>","text":"<p>DINT actual value</p>"},{"location":"reference/tcunit/#AssertEquals_DINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_DWORD","title":"AssertEquals_DWORD","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>DWORD expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>DWORD actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two DWORDs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_DWORD\nVAR_INPUT\n    Expected : DWORD; // DWORD expected value\n    Actual : DWORD; // DWORD actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_DWORD,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_DWORD,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_DWORD,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := CONCAT(\n                                                            STR1 := '0x',\n                                                            STR2 := DWORD_TO_HEXSTR(in := Expected,\n                                                                                                  iPrecision := 8,\n                                                                                                  bLoCase := FALSE)),\n                                            Actual := CONCAT(\n                                                           STR1 := '0x',\n                                                           STR2 := DWORD_TO_HEXSTR(in := Actual,\n                                                                                                 iPrecision := 8,\n                                                                                                 bLoCase := FALSE)),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_DWORD.Expected","title":"Expected  <code>DWORD</code>","text":"<p>DWORD expected value</p>"},{"location":"reference/tcunit/#AssertEquals_DWORD.Actual","title":"Actual  <code>DWORD</code>","text":"<p>DWORD actual value</p>"},{"location":"reference/tcunit/#AssertEquals_DWORD.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_INT","title":"AssertEquals_INT","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>INT expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>INT actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two INTs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_INT\nVAR_INPUT\n    Expected : INT; // INT expected value\n    Actual : INT; // INT actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_INT,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_INT,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_INT,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := INT_TO_STRING(Expected),\n                                            Actual := INT_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_INT.Expected","title":"Expected  <code>INT</code>","text":"<p>INT expected value</p>"},{"location":"reference/tcunit/#AssertEquals_INT.Actual","title":"Actual  <code>INT</code>","text":"<p>INT actual value</p>"},{"location":"reference/tcunit/#AssertEquals_INT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_LINT","title":"AssertEquals_LINT","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>LINT expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>LINT actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two LINTs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_LINT\nVAR_INPUT\n    Expected : LINT; // LINT expected value\n    Actual : LINT; // LINT actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_LINT,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_LINT,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_LINT,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := LINT_TO_STRING(Expected),\n                                            Actual := LINT_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_LINT.Expected","title":"Expected  <code>LINT</code>","text":"<p>LINT expected value</p>"},{"location":"reference/tcunit/#AssertEquals_LINT.Actual","title":"Actual  <code>LINT</code>","text":"<p>LINT actual value</p>"},{"location":"reference/tcunit/#AssertEquals_LINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_LREAL","title":"AssertEquals_LREAL","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>LREAL expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>LREAL actual value</p> </li> <li> <code>Delta</code>             \u2013              <p>The maximum delta between the absolute value of expected and actual for which both numbers are still considered equal</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two LREALs are equal to within a positive delta. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_LREAL\nVAR_INPUT\n    Expected : LREAL; // LREAL expected value\n    Actual : LREAL; // LREAL actual value\n    Delta : LREAL; // The maximum delta between the absolute value of expected and actual for which both numbers are still considered equal\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND ABS(Expected - Actual) &gt; Delta THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_LREAL,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := LREAL_TO_STRING(Expected),\n                                            Actual := LREAL_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_LREAL.Expected","title":"Expected  <code>LREAL</code>","text":"<p>LREAL expected value</p>"},{"location":"reference/tcunit/#AssertEquals_LREAL.Actual","title":"Actual  <code>LREAL</code>","text":"<p>LREAL actual value</p>"},{"location":"reference/tcunit/#AssertEquals_LREAL.Delta","title":"Delta  <code>LREAL</code>","text":"<p>The maximum delta between the absolute value of expected and actual for which both numbers are still considered equal</p>"},{"location":"reference/tcunit/#AssertEquals_LREAL.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_LTIME","title":"AssertEquals_LTIME","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>LTIME expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>LTIME actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two LTIMEs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_LTIME\nVAR_INPUT\n    Expected : LTIME; // LTIME expected value\n    Actual : LTIME; // LTIME actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_LTIME,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_LTIME,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_LTIME,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := LTIME_TO_STRING(Expected),\n                                            Actual := LTIME_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_LTIME.Expected","title":"Expected  <code>LTIME</code>","text":"<p>LTIME expected value</p>"},{"location":"reference/tcunit/#AssertEquals_LTIME.Actual","title":"Actual  <code>LTIME</code>","text":"<p>LTIME actual value</p>"},{"location":"reference/tcunit/#AssertEquals_LTIME.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_LWORD","title":"AssertEquals_LWORD","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>LWORD expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>LWORD actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two LWORDs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_LWORD\nVAR_INPUT\n    Expected : LWORD; // LWORD expected value\n    Actual : LWORD; // LWORD actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_LWORD,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_LWORD,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_LWORD,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := CONCAT(\n                                                            STR1 := '0x',\n                                                            STR2 := LWORD_TO_HEXSTR(in := Expected,\n                                                                                                  iPrecision := 16,\n                                                                                                  bLoCase := FALSE)),\n                                            Actual := CONCAT(\n                                                            STR1 := '0x',\n                                                            STR2 := LWORD_TO_HEXSTR(in := Actual,\n                                                                                                  iPrecision := 16,\n                                                                                                  bLoCase := FALSE)),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_LWORD.Expected","title":"Expected  <code>LWORD</code>","text":"<p>LWORD expected value</p>"},{"location":"reference/tcunit/#AssertEquals_LWORD.Actual","title":"Actual  <code>LWORD</code>","text":"<p>LWORD actual value</p>"},{"location":"reference/tcunit/#AssertEquals_LWORD.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_REAL","title":"AssertEquals_REAL","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>REAL expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>REAL actual value</p> </li> <li> <code>Delta</code>             \u2013              <p>The maximum delta between the absolute value of expected and actual for which both numbers are still considered equal</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two REALs are equal to within a positive delta. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_REAL\nVAR_INPUT\n    Expected : REAL; // REAL expected value\n    Actual : REAL; // REAL actual value\n    Delta : REAL;  // The maximum delta between the absolute value of expected and actual for which both numbers are still considered equal\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND ABS(Expected - Actual) &gt; Delta THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_REAL,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := REAL_TO_STRING(Expected),\n                                            Actual := REAL_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_REAL.Expected","title":"Expected  <code>REAL</code>","text":"<p>REAL expected value</p>"},{"location":"reference/tcunit/#AssertEquals_REAL.Actual","title":"Actual  <code>REAL</code>","text":"<p>REAL actual value</p>"},{"location":"reference/tcunit/#AssertEquals_REAL.Delta","title":"Delta  <code>REAL</code>","text":"<p>The maximum delta between the absolute value of expected and actual for which both numbers are still considered equal</p>"},{"location":"reference/tcunit/#AssertEquals_REAL.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_SINT","title":"AssertEquals_SINT","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>SINT expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>SINT actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two SINTs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_SINT\nVAR_INPUT\n    Expected : SINT; // SINT expected value\n    Actual : SINT; // SINT actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_SINT,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_SINT,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_SINT,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := SINT_TO_STRING(Expected),\n                                            Actual := SINT_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_SINT.Expected","title":"Expected  <code>SINT</code>","text":"<p>SINT expected value</p>"},{"location":"reference/tcunit/#AssertEquals_SINT.Actual","title":"Actual  <code>SINT</code>","text":"<p>SINT actual value</p>"},{"location":"reference/tcunit/#AssertEquals_SINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_STRING","title":"AssertEquals_STRING","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>STRING expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>STRING actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two STRINGs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_STRING\nVAR_INPUT\n    Expected : T_MaxString; // STRING expected value\n    Actual : T_MaxString; // STRING actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_STRING,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_STRING,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND (LEN(STR := Expected) &lt;&gt; LEN(STR := Actual) OR (Expected &lt;&gt; Actual)) THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_STRING,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := Expected,\n                                            Actual := Actual,\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_STRING.Expected","title":"Expected  <code>T_MaxString</code>","text":"<p>STRING expected value</p>"},{"location":"reference/tcunit/#AssertEquals_STRING.Actual","title":"Actual  <code>T_MaxString</code>","text":"<p>STRING actual value</p>"},{"location":"reference/tcunit/#AssertEquals_STRING.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_TIME","title":"AssertEquals_TIME","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>TIME expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>TIME actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two TIMEs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_TIME\nVAR_INPUT\n    Expected : TIME; // TIME expected value\n    Actual : TIME; // TIME actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_TIME,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_TIME,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_TIME,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := TIME_TO_STRING(Expected),\n                                            Actual := TIME_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_TIME.Expected","title":"Expected  <code>TIME</code>","text":"<p>TIME expected value</p>"},{"location":"reference/tcunit/#AssertEquals_TIME.Actual","title":"Actual  <code>TIME</code>","text":"<p>TIME actual value</p>"},{"location":"reference/tcunit/#AssertEquals_TIME.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_TIME_OF_DAY","title":"AssertEquals_TIME_OF_DAY","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>TIME_OF_DAY expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>TIME_OF_DAY actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two TIME_OF_DAYs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_TIME_OF_DAY\nVAR_INPUT\n    Expected : TIME_OF_DAY; // TIME_OF_DAY expected value\n    Actual : TIME_OF_DAY; // TIME_OF_DAY actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_TIMEOFDAY,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_TIMEOFDAY,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_TIME_OF_DAY,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := TOD_TO_STRING(Expected),\n                                            Actual := TOD_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_TIME_OF_DAY.Expected","title":"Expected  <code>TIME_OF_DAY</code>","text":"<p>TIME_OF_DAY expected value</p>"},{"location":"reference/tcunit/#AssertEquals_TIME_OF_DAY.Actual","title":"Actual  <code>TIME_OF_DAY</code>","text":"<p>TIME_OF_DAY actual value</p>"},{"location":"reference/tcunit/#AssertEquals_TIME_OF_DAY.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_UDINT","title":"AssertEquals_UDINT","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>UDINT expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>UDINT actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two UDINTs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_UDINT\nVAR_INPUT\n    Expected : UDINT; // UDINT expected value\n    Actual : UDINT; // UDINT actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_UDINT,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_UDINT,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_UDINT,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := UDINT_TO_STRING(Expected),\n                                            Actual := UDINT_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_UDINT.Expected","title":"Expected  <code>UDINT</code>","text":"<p>UDINT expected value</p>"},{"location":"reference/tcunit/#AssertEquals_UDINT.Actual","title":"Actual  <code>UDINT</code>","text":"<p>UDINT actual value</p>"},{"location":"reference/tcunit/#AssertEquals_UDINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_UINT","title":"AssertEquals_UINT","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>UINT expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>UINT actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two UINTs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_UINT\nVAR_INPUT\n    Expected : UINT; // UINT expected value\n    Actual : UINT; // UINT actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_UINT,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_UINT,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_UINT,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := UINT_TO_STRING(Expected),\n                                            Actual := UINT_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_UINT.Expected","title":"Expected  <code>UINT</code>","text":"<p>UINT expected value</p>"},{"location":"reference/tcunit/#AssertEquals_UINT.Actual","title":"Actual  <code>UINT</code>","text":"<p>UINT actual value</p>"},{"location":"reference/tcunit/#AssertEquals_UINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_ULINT","title":"AssertEquals_ULINT","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>ULINT expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>ULINT actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two ULINTs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_ULINT\nVAR_INPUT\n    Expected : ULINT; // ULINT expected value\n    Actual : ULINT; // ULINT actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_ULINT,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_ULINT,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_ULINT,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := ULINT_TO_STRING(Expected),\n                                            Actual := ULINT_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_ULINT.Expected","title":"Expected  <code>ULINT</code>","text":"<p>ULINT expected value</p>"},{"location":"reference/tcunit/#AssertEquals_ULINT.Actual","title":"Actual  <code>ULINT</code>","text":"<p>ULINT actual value</p>"},{"location":"reference/tcunit/#AssertEquals_ULINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_USINT","title":"AssertEquals_USINT","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>USINT expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>USINT actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two USINTs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_USINT\nVAR_INPUT\n    Expected : USINT; // USINT expected value\n    Actual : USINT; // USINT actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    AlreadyReported : BOOL;\n    TestInstancePath : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_USINT,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_USINT,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_USINT,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := USINT_TO_STRING(Expected),\n                                            Actual := USINT_TO_STRING(Actual),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_USINT.Expected","title":"Expected  <code>USINT</code>","text":"<p>USINT expected value</p>"},{"location":"reference/tcunit/#AssertEquals_USINT.Actual","title":"Actual  <code>USINT</code>","text":"<p>USINT actual value</p>"},{"location":"reference/tcunit/#AssertEquals_USINT.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_WORD","title":"AssertEquals_WORD","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>WORD expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>WORD actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two WORDs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_WORD\nVAR_INPUT\n    Expected : WORD; // WORD expected value\n    Actual : WORD; // WORD actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_WORD,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_WORD,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND Expected &lt;&gt; Actual THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_WORD,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := CONCAT(\n                                                            STR1 := '0x',\n                                                            STR2 := WORD_TO_HEXSTR(in := Expected,\n                                                                                                 iPrecision := 4,\n                                                                                                 bLoCase := FALSE)),\n                                            Actual := CONCAT(\n                                                            STR1 := '0x',\n                                                            STR2 := WORD_TO_HEXSTR(in := Actual,\n                                                                                                 iPrecision := 4,\n                                                                                                 bLoCase := FALSE)),\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_WORD.Expected","title":"Expected  <code>WORD</code>","text":"<p>WORD expected value</p>"},{"location":"reference/tcunit/#AssertEquals_WORD.Actual","title":"Actual  <code>WORD</code>","text":"<p>WORD actual value</p>"},{"location":"reference/tcunit/#AssertEquals_WORD.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertEquals_WSTRING","title":"AssertEquals_WSTRING","text":"<p>Inputs</p> <ul> <li> <code>Expected</code>             \u2013              <p>WSTRING expected value</p> </li> <li> <code>Actual</code>             \u2013              <p>WSTRING actual value</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that two WSTRINGs are equal. If they are not, an assertion error is created.\nMETHOD PUBLIC AssertEquals_WSTRING\nVAR_INPUT\n    Expected : WSTRING(255); // WSTRING expected value\n    Actual : WSTRING(255); // WSTRING actual value\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    AlreadyReported : BOOL;\nEND_VAR\n</code></pre> <pre><code>IF GVL_TcUnit.IgnoreCurrentTest OR GVL_TcUnit.CurrentTestIsFinished THEN\n    RETURN;\nEND_IF\n\nTestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());\n\nAssertResults.ReportResult(ExpectedSize := SIZEOF(Expected),\n                           ExpectedTypeClass := IBaseLibrary.TypeClass.TYPE_WSTRING,\n                           ExpectedValue := ADR(Expected),\n                           ActualSize := SIZEOF(Actual),\n                           ActualTypeClass := IBaseLibrary.TypeClass.TYPE_WSTRING,\n                           ActualValue := ADR(Actual),\n                           Message := Message,\n                           TestInstancePath := TestInstancePath,\n                           AlreadyReported =&gt; AlreadyReported);\n\nIF NOT AlreadyReported AND (WLEN(STR := Expected) &lt;&gt; WLEN(STR := Actual) OR (Expected &lt;&gt; Actual)) THEN\n    SetTestFailed(AssertionType := E_AssertionType.Type_WSTRING,\n                  AssertionMessage := Message);\n\n    AssertMessageFormatter.LogAssertFailure(Expected := 'Not possible to print EXP unicode WSTRING value',\n                                            Actual := 'Not possible to print ACT unicode WSTRING value',\n                                            Message := Message,\n                                            TestInstancePath := TestInstancePath);\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#AssertEquals_WSTRING.Expected","title":"Expected  <code>WSTRING(255)</code>","text":"<p>WSTRING expected value</p>"},{"location":"reference/tcunit/#AssertEquals_WSTRING.Actual","title":"Actual  <code>WSTRING(255)</code>","text":"<p>WSTRING actual value</p>"},{"location":"reference/tcunit/#AssertEquals_WSTRING.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertFalse","title":"AssertFalse","text":"<p>Inputs</p> <ul> <li> <code>Condition</code>             \u2013              <p>Condition to be checked</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that a condition is false. If it is not, an assertion error is created.\nMETHOD PUBLIC AssertFalse\nVAR_INPUT\n    Condition : BOOL; // Condition to be checked\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\n</code></pre> <pre><code>AssertEquals_BOOL(Expected := FALSE,\n                  Actual := Condition,\n                  Message := Message);\n</code></pre>"},{"location":"reference/tcunit/#AssertFalse.Condition","title":"Condition  <code>BOOL</code>","text":"<p>Condition to be checked</p>"},{"location":"reference/tcunit/#AssertFalse.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.AssertTrue","title":"AssertTrue","text":"<p>Inputs</p> <ul> <li> <code>Condition</code>             \u2013              <p>Condition to be checked</p> </li> <li> <code>Message</code>             \u2013              <p>The identifying message for the assertion error</p> </li> </ul> Source Code <pre><code>// Asserts that a condition is true. If it is not, an assertion error is created.\nMETHOD PUBLIC AssertTrue\nVAR_INPUT\n    Condition : BOOL; // Condition to be checked\n    Message : T_MaxString; // The identifying message for the assertion error\nEND_VAR\n</code></pre> <pre><code>AssertEquals_BOOL(Expected := TRUE,\n                  Actual := Condition,\n                  Message := Message);\n</code></pre>"},{"location":"reference/tcunit/#AssertTrue.Condition","title":"Condition  <code>BOOL</code>","text":"<p>Condition to be checked</p>"},{"location":"reference/tcunit/#AssertTrue.Message","title":"Message  <code>T_MaxString</code>","text":"<p>The identifying message for the assertion error</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.CalculateAndSetNumberOfAssertsForTest","title":"CalculateAndSetNumberOfAssertsForTest  <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>TestName</code> </li> </ul> Source Code <pre><code>METHOD INTERNAL CalculateAndSetNumberOfAssertsForTest\nVAR_INPUT\n    TestName : T_MaxString;\nEND_VAR\nVAR\n    TestInstancePath : T_MaxString;\n    TotalNumberOfAsserts : UINT;\n    NumberOfAsserts : UINT;\n    NumberOfArrayAsserts : UINT;\n\n    IteratorCounter : UINT;\nEND_VAR\n</code></pre> <pre><code>TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());\nNumberOfAsserts := AssertResults.GetNumberOfAssertsForTest(CompleteTestInstancePath := TestInstancePath);\nNumberOfArrayAsserts := AssertArrayResults.GetNumberOfArrayAssertsForTest(CompleteTestInstancePath := TestInstancePath);\nTotalNumberOfAsserts := NumberOfAsserts + NumberOfArrayAsserts;\n\nIF TotalNumberOfAsserts &gt; 0 THEN\n    IF NumberOfTests &gt; 0 THEN\n        FOR IteratorCounter := 1 TO NumberOfTests BY 1 DO\n            IF Tests[IteratorCounter].GetName() = TestName THEN\n                Tests[IteratorCounter].SetNumberOfAssertions(NoOfAssertions := TotalNumberOfAsserts);\n                RETURN;\n            END_IF\n        END_FOR\n    END_IF\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#CalculateAndSetNumberOfAssertsForTest.TestName","title":"TestName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.CalculateDuration","title":"CalculateDuration  <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>FinishedAt</code>             \u2013              <p>CPU cycle counter with 100ns precision</p> </li> </ul> Source Code <pre><code>METHOD INTERNAL CalculateDuration\nVAR_INPUT\n    FinishedAt : LWORD; // CPU cycle counter with 100ns precision\nEND_VAR\n</code></pre> <pre><code>IF Duration = 0.0 THEN\n\tDuration := LWORD_TO_LREAL(FinishedAt - StartedAt) * GVL_TcUnit.HundredNanosecondToSecond; // Seconds\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#CalculateDuration.FinishedAt","title":"FinishedAt  <code>LWORD</code>","text":"<p>CPU cycle counter with 100ns precision</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.FB_init","title":"FB_init  <code>BOOL</code>","text":"<p>Inputs</p> <ul> <li> <code>bInitRetains</code>             \u2013              <p>if TRUE, the retain variables are initialized (warm start / cold start)</p> </li> <li> <code>bInCopyCode</code>             \u2013              <p>if TRUE, the instance afterwards gets moved into the copy code (online change)</p> </li> </ul> Source Code <pre><code>METHOD FB_init : BOOL\nVAR_INPUT\n    bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)\n    bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)\nEND_VAR\n</code></pre> <pre><code>GVL_TcUnit.NumberOfInitializedTestSuites := GVL_TcUnit.NumberOfInitializedTestSuites + 1;\nGVL_TcUnit.TestSuiteAddresses[GVL_TcUnit.NumberOfInitializedTestSuites] := THIS;\n</code></pre>"},{"location":"reference/tcunit/#FB_init.bInitRetains","title":"bInitRetains  <code>BOOL</code>","text":"<p>if TRUE, the retain variables are initialized (warm start / cold start)</p>"},{"location":"reference/tcunit/#FB_init.bInCopyCode","title":"bInCopyCode  <code>BOOL</code>","text":"<p>if TRUE, the instance afterwards gets moved into the copy code (online change)</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.FindTestSuiteInstancePath","title":"FindTestSuiteInstancePath","text":"Source Code <pre><code>// Searches for the instance path of the calling function block\nMETHOD PRIVATE FindTestSuiteInstancePath : T_MaxString\n</code></pre> <pre><code>FindTestSuiteInstancePath := GetInstancePath();\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.GetDuration","title":"GetDuration  <code>LREAL</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetDuration : LREAL\n</code></pre> <pre><code>GetDuration := Duration;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.GetHasStartedRunning","title":"GetHasStartedRunning  <code>BOOL</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetHasStartedRunning : BOOL\n</code></pre> <pre><code>GetHasStartedRunning := StartedAt &gt; 0;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.GetInstancePath","title":"GetInstancePath  <code>T_MaxString</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetInstancePath : T_MaxString\n</code></pre> <pre><code>GetInstancePath := InstancePath;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.GetNumberOfFailedTests","title":"GetNumberOfFailedTests  <code>UINT</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetNumberOfFailedTests : UINT\nVAR\n    Counter : UINT;\n    FailedTestsCount : UINT;\n    NumberOfTestsToAnalyse : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\n    NumberOfTestOverArrayLimit : UINT;\nEND_VAR\n</code></pre> <pre><code>// Limit the test analyse to the max array limit of 'Tests[]'\nNumberOfTestsToAnalyse := GetNumberOfTestsToAnalyse();\nIF GetNumberOfTests() &gt; NumberOfTestsToAnalyse THEN\n    NumberOfTestOverArrayLimit := GetNumberOfTests()-NumberOfTestsToAnalyse;\nEND_IF\n\nFOR Counter := 1 TO NumberOfTestsToAnalyse BY 1 DO\n    IF Tests[Counter].IsFailed() THEN\n        FailedTestsCount := FailedTestsCount + 1;\n    END_IF\nEND_FOR\n\nGetNumberOfFailedTests := FailedTestsCount + NumberOfTestOverArrayLimit;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.GetNumberOfSkippedTests","title":"GetNumberOfSkippedTests  <code>UINT</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetNumberOfSkippedTests : UINT\nVAR\n    Counter : UINT;\n    SkippedTestsCount : UINT;\n    NumberOfTestsToAnalyse : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\n</code></pre> <pre><code>// Limit the test analyse to the max array limit of 'Tests[]'\nNumberOfTestsToAnalyse := GetNumberOfTestsToAnalyse();\n\nFOR Counter := 1 TO NumberOfTestsToAnalyse BY 1 DO\n    IF Tests[Counter].IsSkipped() THEN\n        SkippedTestsCount := SkippedTestsCount + 1;\n    END_IF\nEND_FOR\n\nGetNumberOfSkippedTests := SkippedTestsCount;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.GetNumberOfSuccessfulTests","title":"GetNumberOfSuccessfulTests  <code>UINT</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetNumberOfSuccessfulTests : UINT\n</code></pre> <pre><code>GetNumberOfSuccessfulTests := GetNumberOfTests() - GetNumberOfFailedTests() - GetNumberOfSkippedTests();\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.GetNumberOfTests","title":"GetNumberOfTests  <code>UINT</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetNumberOfTests : UINT\n</code></pre> <pre><code>GetNumberOfTests := NumberOfTests;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.GetNumberOfTestsToAnalyse","title":"GetNumberOfTestsToAnalyse  <code>UINT</code> <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL GetNumberOfTestsToAnalyse : UINT\n</code></pre> <pre><code>GetNumberOfTestsToAnalyse := MIN(GetNumberOfTests(), GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.GetTestByName","title":"GetTestByName  <code>REFERENCE TO FB_Test</code>","text":"<p>Inputs</p> <ul> <li> <code>TestName</code> </li> </ul> Source Code <pre><code>METHOD GetTestByName : REFERENCE TO FB_Test\nVAR_INPUT\n  TestName : T_MaxString;\nEND_VAR\nVAR\n  IteratorCounter : UINT;\n  NumberOfTestsToAnalyse : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestSuites);\nEND_VAR\n</code></pre> <pre><code>NumberOfTestsToAnalyse := GetNumberOfTestsToAnalyse();\nFOR IteratorCounter := 1 TO NumberOfTestsToAnalyse BY 1 DO\n  IF Tests[IteratorCounter].GetName() = TestName THEN\n    GetTestByName REF= Tests[IteratorCounter];\n    RETURN;\n\tEND_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#GetTestByName.TestName","title":"TestName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.GetTestByPosition","title":"GetTestByPosition","text":"<p>Inputs</p> <ul> <li> <code>Position</code> </li> </ul> Source Code <pre><code>// This method returns the test at the n'th position, ranging from 1.. NumberOfTests\nMETHOD INTERNAL GetTestByPosition : FB_Test\nVAR_INPUT\n    Position : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\n</code></pre> <pre><code>GetTestByPosition := Tests[Position];\n</code></pre>"},{"location":"reference/tcunit/#GetTestByPosition.Position","title":"Position  <code>UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite)</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.GetTestOrderNumber","title":"GetTestOrderNumber  <code>UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite)</code> <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>TestName</code> </li> </ul> Source Code <pre><code>METHOD INTERNAL GetTestOrderNumber : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nVAR_INPUT\n    TestName : T_MaxString;\nEND_VAR\nVAR\n    IteratorCounter : UINT;\n    NumberOfTestsToAnalyse : UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\n</code></pre> <pre><code>// Limit the test analyse to the max array limit of 'Tests[]'\nNumberOfTestsToAnalyse := GetNumberOfTestsToAnalyse();\n\nFOR IteratorCounter := 1 TO NumberOfTestsToAnalyse BY 1 DO\n    IF Tests[IteratorCounter].GetName() = TestName THEN\n        GetTestOrderNumber := Tests[IteratorCounter].GetTestOrder();\n        RETURN;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#GetTestOrderNumber.TestName","title":"TestName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.IsTestFinished","title":"IsTestFinished  <code>BOOL</code> <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>TestName</code> </li> </ul> Source Code <pre><code>METHOD INTERNAL IsTestFinished : BOOL\nVAR_INPUT\n    TestName : T_MaxString;\nEND_VAR\nVAR\n    IteratorCounter : UINT;\n    NumberOfTestsToAnalyse : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\n</code></pre> <pre><code>// Limit the test analyse to the max array limit of 'Tests[]'\nNumberOfTestsToAnalyse := GetNumberOfTestsToAnalyse();\n\nIsTestFinished := FALSE;\nFOR IteratorCounter := 1 TO NumberOfTestsToAnalyse BY 1 DO\n    IF Tests[IteratorCounter].GetName() = TestName THEN\n        IsTestFinished := Tests[IteratorCounter].IsFinished();\n        RETURN;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#IsTestFinished.TestName","title":"TestName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.SetStartedAtIfNotSet","title":"SetStartedAtIfNotSet  <code>INTERNAL</code>","text":"<p>Inputs</p> <ul> <li> <code>Timestamp</code>             \u2013              <p>CPU cycle counter with 100ns precision</p> </li> </ul> Source Code <pre><code>METHOD INTERNAL SetStartedAtIfNotSet\nVAR_INPUT\n    Timestamp : LWORD; // CPU cycle counter with 100ns precision\nEND_VAR\n</code></pre> <pre><code>IF StartedAt = 0 THEN\n    StartedAt := Timestamp;\nEND_IF\n</code></pre>"},{"location":"reference/tcunit/#SetStartedAtIfNotSet.Timestamp","title":"Timestamp  <code>LWORD</code>","text":"<p>CPU cycle counter with 100ns precision</p>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.SetStartedAtTimeBasedOnCpuCounter","title":"SetStartedAtTimeBasedOnCpuCounter  <code>INTERNAL</code>","text":"Source Code <pre><code>METHOD INTERNAL SetStartedAtTimeBasedOnCpuCounter\n</code></pre> <pre><code>StartedAt := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter);\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.SetTestFailed","title":"SetTestFailed  <code>PRIVATE</code>","text":"<p>Inputs</p> <ul> <li> <code>AssertionType</code> </li> <li> <code>AssertionMessage</code> </li> </ul> Source Code <pre><code>METHOD PRIVATE SetTestFailed\nVAR_INPUT\n    AssertionType : E_AssertionType;\n    AssertionMessage : T_MaxString;\nEND_VAR\nVAR\n    IteratorCounter : UINT;\n    NumberOfTestsToAnalyse : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\n</code></pre> <pre><code>// Limit the test analyse to the max array limit of 'Tests[]'\nNumberOfTestsToAnalyse := GetNumberOfTestsToAnalyse();\n\nFOR IteratorCounter := 1 TO NumberOfTestsToAnalyse BY 1 DO\n    IF Tests[IteratorCounter].GetName() = GVL_TcUnit.CurrentTestNameBeingCalled THEN\n        Tests[IteratorCounter].SetFailed();\n        Tests[IteratorCounter].SetAssertionType(AssertType := AssertionType);\n        Tests[IteratorCounter].SetAssertionMessage(AssertMessage := AssertionMessage);\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#SetTestFailed.AssertionType","title":"AssertionType  <code>E_AssertionType</code>","text":""},{"location":"reference/tcunit/#SetTestFailed.AssertionMessage","title":"AssertionMessage  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_TestSuite.SetTestFinished","title":"SetTestFinished","text":"<p>Inputs</p> <ul> <li> <code>TestName</code> </li> <li> <code>FinishedAt</code> </li> </ul> Source Code <pre><code>(* Marks the test as finished in this testsuite.\n   Returns TRUE if test was found, and FALSE if a test with this name was not found in this testsuite *)\nMETHOD INTERNAL SetTestFinished : BOOL;\nVAR_INPUT\n    TestName : T_MaxString;\n    FinishedAt : LWORD;\nEND_VAR\nVAR\n    IteratorCounter : UINT;\n    NumberOfTestsToAnalyse : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\nEND_VAR\n</code></pre> <pre><code>// Limit the test analyse to the max array limit of 'Tests[]'\nNumberOfTestsToAnalyse := GetNumberOfTestsToAnalyse();\nFOR IteratorCounter := 1 TO NumberOfTestsToAnalyse BY 1 DO\n    IF Tests[IteratorCounter].GetName() = TestName THEN\n\t\tIF NOT Tests[IteratorCounter].IsFinished() THEN\n        \tTests[IteratorCounter].SetFinishedAndDuration(FinishedAt := FinishedAt);\n\t\tEND_IF\n\t\tSetTestFinished := TRUE;\n        RETURN;\n    END_IF\nEND_FOR\nSetTestFinished := FALSE;\n</code></pre>"},{"location":"reference/tcunit/#SetTestFinished.TestName","title":"TestName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#SetTestFinished.FinishedAt","title":"FinishedAt  <code>LWORD</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_XmlControl","title":"FB_XmlControl","text":"<p>Methods</p> <ul> <li> <code>ClearBuffer</code> </li> <li> <code>CloseTag</code> </li> <li> <code>NewComment</code> </li> <li> <code>NewParameter</code> </li> <li> <code>NewTag</code> </li> <li> <code>NewTagData</code> </li> <li> <code>SetBuffer</code> </li> <li> <code>ToStartBuffer</code> </li> <li> <code>WriteDocumentHeader</code> </li> </ul> <p>Properties</p> <ul> <li> <code>Length</code> </li> </ul> Source Code <pre><code>(*\n    Organizes parsing and composing of XML data. Data can be treated as STRING or char array.\n    Buffer size of file can be set via GVL_Param_TcUnit (xUnitBufferSize)\n*)\nFUNCTION_BLOCK FB_XmlControl\nVAR\n    XmlBuffer : FB_StreamBuffer;\n    TagListBuffer : FB_StreamBuffer;\n    Tags : T_MaxString;\n    TagListSeekBuffer : FB_StreamBuffer;\n    TagsSeek : STRING;\n    TagBuffer : FB_StreamBuffer;\n    Tag : T_MaxString;\n    TagOpen: BOOL;\n    Select : UDINT;\n    SearchPosition : UDINT; \nEND_VAR\nVAR CONSTANT\n    TAG_OPEN : STRING(1) := '&lt;';\n    TAG_CLOSE : STRING(1) := '&gt;';\n    END_TAG_CLOSE : STRING(2) := '/&gt;';\n    SPACE : STRING(1) := ' ';\n    EQUALS : STRING(1) := '=';\n    QUOTE : STRING(1) := '\"';\n    BACK_SLASH : STRING(1) := '\\';\n    FORWARD_SLASH : STRING(1) := '/';\n    OPEN_COMMENT : STRING(5) := '&lt;!-- ';\n    CLOSE_COMMENT : STRING(4) := ' --&gt;';\n    TAB : STRING(2) := '$T';\n    CR_LF : STRING(4) := '$R$N';\n\n    // $OD : ASCII code for carriage return (CR)\n    // $$ : to add a $R\n    // $' : to add ' (apostrophe)\n    // $L or $l : line feed\n    // $N or $n : new line\n    // $P or $p : next page\n    // $R or $r : end of line\nEND_VAR\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_XmlControl.ClearBuffer","title":"ClearBuffer","text":"Source Code <pre><code>// Clears the contents of the entire buffer.\nMETHOD PUBLIC ClearBuffer\n</code></pre> <pre><code>SearchPosition := 0;\nTagListSeekBuffer.Length := 0;\nXmlBuffer.Length := 0;\nTagsSeek := '';\nTag := '';\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_XmlControl.CloseTag","title":"CloseTag","text":"Source Code <pre><code>(*\n    Closes a Tag:\n    XML: &lt;MyTag /&gt;'\n\n    Method: XML.CloseTag();\n*)\nMETHOD PUBLIC CloseTag : T_MaxString\nVAR\n    ClosedTag : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>IF TagOpen THEN\n    XmlBuffer.Append := END_TAG_CLOSE;\n    Select := TagListBuffer.FindBack(SearchString := FORWARD_SLASH);\n    ClosedTag := TagListBuffer.CutOff(StartPos := Select);\n    TagOpen := FALSE;\nELSE\n    Select := TagListBuffer.FindBack(SearchString := FORWARD_SLASH);\n    ClosedTag := TagListBuffer.CutOff(StartPos := Select);\n    XmlBuffer.Append := TAG_OPEN;\n    XmlBuffer.Append := ClosedTag;\n    XmlBuffer.Append := TAG_CLOSE;\nEND_IF\n\nCloseTag := ClosedTag;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_XmlControl.NewComment","title":"NewComment","text":"<p>Inputs</p> <ul> <li> <code>Comment</code> </li> </ul> Source Code <pre><code>(*\n    Adds a comment\n    XML: &lt;!-- MyComment --&gt;\n\n    XML.NewComment(Comment: = 'MyComment');\n*)\nMETHOD PUBLIC NewComment\nVAR_INPUT\n    Comment : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>IF TagOpen THEN\n    XmlBuffer.Append := TAG_CLOSE;\n    TagOpen := FALSE;\nEND_IF;\nXmlBuffer.Append := OPEN_COMMENT;\nXmlBuffer.Append := Comment;\nXmlBuffer.Append := CLOSE_COMMENT;\n</code></pre>"},{"location":"reference/tcunit/#NewComment.Comment","title":"Comment  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_XmlControl.NewParameter","title":"NewParameter","text":"<p>Inputs</p> <ul> <li> <code>Name</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>(*\n    Must be called after opening a new tag\n\n    XML.NewParameter(Name: = 'ParaName', Value: = 'Value');\n*)\nMETHOD PUBLIC NewParameter\nVAR_INPUT\n    Name : T_MaxString;\n    Value : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>XmlBuffer.Append := SPACE;\nXmlBuffer.Append := Name;\nXmlBuffer.Append := EQUALS;\nXmlBuffer.Append := QUOTE;\nXmlBuffer.Append := Value;\nXmlBuffer.Append := QUOTE;\n</code></pre>"},{"location":"reference/tcunit/#NewParameter.Name","title":"Name  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#NewParameter.Value","title":"Value  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_XmlControl.NewTag","title":"NewTag","text":"<p>Inputs</p> <ul> <li> <code>Name</code> </li> </ul> Source Code <pre><code>(*\n    Creates a new Tag:\n    XML: &lt;MyTag&gt;\n\n    XML.NewTag(Name: = 'MyTag');\n*)\nMETHOD PUBLIC NewTag\nVAR_INPUT\n    Name : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>IF TagOpen THEN\n    XmlBuffer.Append := TAG_CLOSE;\nEND_IF;\nXmlBuffer.Append := TAG_OPEN;\nXmlBuffer.Append := Name;\nTagOpen := TRUE;\nTagListBuffer.Append := FORWARD_SLASH;\nTagListBuffer.Append := Name;\n</code></pre>"},{"location":"reference/tcunit/#NewTag.Name","title":"Name  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_XmlControl.NewTagData","title":"NewTagData  <code>PUBLIC</code>","text":"<p>Inputs</p> <ul> <li> <code>Data</code> </li> </ul> Source Code <pre><code>METHOD PUBLIC NewTagData\nVAR_INPUT\n    Data : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>XmlBuffer.Append := TAG_CLOSE;\nXmlBuffer.Append := Data;\nTagOpen := FALSE;\n</code></pre>"},{"location":"reference/tcunit/#NewTagData.Data","title":"Data  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_XmlControl.SetBuffer","title":"SetBuffer  <code>PUBLIC</code>","text":"<p>Inputs</p> <ul> <li> <code>PointerToBuffer</code>             \u2013              <p>ADR(..)</p> </li> <li> <code>SizeOfBuffer</code>             \u2013              <p>SIZEOF(..)</p> </li> </ul> Source Code <pre><code>METHOD PUBLIC SetBuffer\nVAR_INPUT\n    PointerToBuffer : POINTER TO BYTE; // ADR(..)\n    SizeOfBuffer : UDINT; // SIZEOF(..)\nEND_VAR\n</code></pre> <pre><code>XmlBuffer.SetBuffer(PointerToBufferAddress:= PointerToBuffer, SizeOfBuffer := SizeOfBuffer);\nTagListBuffer.SetBuffer(PointerToBufferAddress := ADR(Tags), SizeOfBuffer := SIZEOF(Tags));\nTagListSeekBuffer.SetBuffer(PointerToBufferAddress := ADR(TagsSeek), SizeOfBuffer := SIZEOF(TagsSeek));\nTagBuffer.SetBuffer(PointerToBufferAddress := ADR(Tag), SizeOfBuffer := SIZEOF(Tag));\n</code></pre>"},{"location":"reference/tcunit/#SetBuffer.PointerToBuffer","title":"PointerToBuffer  <code>POINTER TO BYTE</code>","text":"<p>ADR(..)</p>"},{"location":"reference/tcunit/#SetBuffer.SizeOfBuffer","title":"SizeOfBuffer  <code>UDINT</code>","text":"<p>SIZEOF(..)</p>"},{"location":"reference/tcunit/#TcUnit.FB_XmlControl.ToStartBuffer","title":"ToStartBuffer","text":"Source Code <pre><code>(*\n    Jump to the beginning of the XML data\n    XML.ToStartBuffer();\n*)\nMETHOD PUBLIC ToStartBuffer\n</code></pre> <pre><code>SearchPosition := 0;\nTagListSeekBuffer.Length := 0;\nTagsSeek := '';\nTag := '';\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.FB_XmlControl.WriteDocumentHeader","title":"WriteDocumentHeader","text":"<p>Inputs</p> <ul> <li> <code>Header</code> </li> </ul> Source Code <pre><code>(*\n    Add your own preffered fileheader like:\n    XML: &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n    Start with calling this method before appending any other tags!\n\n    XML.WriteDocumentHeader('&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;');\n*)\nMETHOD PUBLIC WriteDocumentHeader\nVAR_INPUT\n    Header : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>XmlBuffer.Append := Header;\n</code></pre>"},{"location":"reference/tcunit/#WriteDocumentHeader.Header","title":"Header  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.FB_XmlControl.Length","title":"Length  <code>UDINT</code> <code>Get</code>","text":"Source Code <pre><code>Length := XmlBuffer.Length;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.F_AnyToUnionValue","title":"F_AnyToUnionValue","text":"<p>Inputs</p> <ul> <li> <code>AnySize</code> </li> <li> <code>AnyTypeClass</code> </li> <li> <code>AnyValue</code> </li> </ul> Source Code <pre><code>FUNCTION F_AnyToUnionValue : U_ExpectedOrActual\nVAR_INPUT\n    AnySize : UDINT;\n    AnyTypeClass : IBaseLibrary.TypeClass;\n    AnyValue : POINTER TO BYTE;\nEND_VAR\n</code></pre> <pre><code>CASE AnyTypeClass OF\n    IBaseLibrary.TypeClass.TYPE_BOOL :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.boolExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_BIT :\n        {warning disable C0355}\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.bitExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n        {warning enable C0355}\n\n    IBaseLibrary.TypeClass.TYPE_BYTE :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.byteExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_WORD :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.wordExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_DWORD :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.dwordExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_LWORD :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.lwordExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_SINT :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.sintExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_INT :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.intExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_DINT :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.dintExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_LINT :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.lintExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_USINT :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.usintExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_UINT :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.uintExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_UDINT :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.udintExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_ULINT :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.ulintExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_REAL :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.realExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_LREAL :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.lrealExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_STRING :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.stringExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_WSTRING :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.wstringExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_TIME :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.timeExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_DATE :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.dateExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_DATEANDTIME :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.dateandtimeExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_TIMEOFDAY :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.timeofdayExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_POINTER :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_REFERENCE :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_SUBRANGE :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_ENUM :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_ARRAY :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_PARAMS :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_USERDEF :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_NONE :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_ANY :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_ANYBIT :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_ANYDATE :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_ANYINT :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_ANYNUM :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_ANYREAL :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_LAZY :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_LTIME :\n        MEMCPY(destaddr := ADR(F_AnyToUnionValue.ltimeExpectedOrActual),\n               srcAddr := AnyValue,\n               n := AnySize);\n\n    IBaseLibrary.TypeClass.TYPE_BITCONST :\n        // None\n\n    IBaseLibrary.TypeClass.TYPE_INTERFACE :\n        // None\n\n    ELSE\n        // None\nEND_CASE\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.F_AnyToUnionValue.AnySize","title":"AnySize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.F_AnyToUnionValue.AnyTypeClass","title":"AnyTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#TcUnit.F_AnyToUnionValue.AnyValue","title":"AnyValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#TcUnit.F_AnyTypeClassToString","title":"F_AnyTypeClassToString","text":"<p>Inputs</p> <ul> <li> <code>AnyTypeClass</code> </li> </ul> Source Code <pre><code>// This function takes the type-class of a ANY-variable and returns the STRING representation of it.\nFUNCTION F_AnyTypeClassToString : STRING\nVAR_INPUT\n    AnyTypeClass : __SYSTEM.TYPE_CLASS;\nEND_VAR\n</code></pre> <pre><code>CASE UDINT_TO_INT(AnyTypeClass) OF\n    IBaseLibrary.TypeClass.TYPE_BOOL :\n        F_AnyTypeClassToString := 'BOOL';\n\n    IBaseLibrary.TypeClass.TYPE_BIT :\n        F_AnyTypeClassToString := 'BIT';\n\n    IBaseLibrary.TypeClass.TYPE_BYTE :\n        F_AnyTypeClassToString := 'BYTE';\n\n    IBaseLibrary.TypeClass.TYPE_WORD :\n        F_AnyTypeClassToString := 'WORD';\n\n    IBaseLibrary.TypeClass.TYPE_DWORD :\n        F_AnyTypeClassToString := 'DWORD';\n\n    IBaseLibrary.TypeClass.TYPE_LWORD :\n        F_AnyTypeClassToString := 'LWORD';\n\n    IBaseLibrary.TypeClass.TYPE_SINT :\n        F_AnyTypeClassToString := 'SINT';\n\n    IBaseLibrary.TypeClass.TYPE_INT :\n        F_AnyTypeClassToString := 'INT';\n\n    IBaseLibrary.TypeClass.TYPE_DINT :\n        F_AnyTypeClassToString := 'DINT';\n\n    IBaseLibrary.TypeClass.TYPE_LINT :\n        F_AnyTypeClassToString := 'LINT';\n\n    IBaseLibrary.TypeClass.TYPE_USINT :\n        F_AnyTypeClassToString := 'USINT';\n\n    IBaseLibrary.TypeClass.TYPE_UINT :\n        F_AnyTypeClassToString := 'UINT';\n\n    IBaseLibrary.TypeClass.TYPE_UDINT :\n        F_AnyTypeClassToString := 'UDINT';\n\n    IBaseLibrary.TypeClass.TYPE_ULINT :\n        F_AnyTypeClassToString := 'ULINT';\n\n    IBaseLibrary.TypeClass.TYPE_REAL :\n        F_AnyTypeClassToString := 'REAL';\n\n    IBaseLibrary.TypeClass.TYPE_LREAL :\n        F_AnyTypeClassToString := 'LREAL';\n\n    IBaseLibrary.TypeClass.TYPE_STRING :\n        F_AnyTypeClassToString := 'STRING';\n\n    IBaseLibrary.TypeClass.TYPE_WSTRING :\n        F_AnyTypeClassToString := 'WSTRING';\n\n    IBaseLibrary.TypeClass.TYPE_TIME :\n        F_AnyTypeClassToString := 'TIME';\n\n    IBaseLibrary.TypeClass.TYPE_DATE :\n        F_AnyTypeClassToString := 'DATE';\n\n    IBaseLibrary.TypeClass.TYPE_DATEANDTIME :\n        F_AnyTypeClassToString := 'DATEANDTIME';\n\n    IBaseLibrary.TypeClass.TYPE_TIMEOFDAY :\n        F_AnyTypeClassToString := 'TIMEOFDAY';\n\n    IBaseLibrary.TypeClass.TYPE_POINTER :\n        F_AnyTypeClassToString := 'POINTER';\n\n    IBaseLibrary.TypeClass.TYPE_REFERENCE :\n        F_AnyTypeClassToString := 'REFERENCE';\n\n    IBaseLibrary.TypeClass.TYPE_SUBRANGE :\n        F_AnyTypeClassToString := 'SUBRANGE';\n\n    IBaseLibrary.TypeClass.TYPE_ENUM :\n        F_AnyTypeClassToString := 'ENUM';\n\n    IBaseLibrary.TypeClass.TYPE_ARRAY :\n        F_AnyTypeClassToString := 'ARRAY';\n\n    IBaseLibrary.TypeClass.TYPE_PARAMS :\n        F_AnyTypeClassToString := 'PARAMS';\n\n    IBaseLibrary.TypeClass.TYPE_USERDEF :\n        F_AnyTypeClassToString := 'USERDEF';\n\n    IBaseLibrary.TypeClass.TYPE_NONE :\n        F_AnyTypeClassToString := 'NONE';\n\n    IBaseLibrary.TypeClass.TYPE_ANY :\n        F_AnyTypeClassToString := 'ANY';\n\n    IBaseLibrary.TypeClass.TYPE_ANYBIT :\n        F_AnyTypeClassToString := 'ANYBIT';\n\n    IBaseLibrary.TypeClass.TYPE_ANYDATE :\n        F_AnyTypeClassToString := 'ANYDATE';\n\n    IBaseLibrary.TypeClass.TYPE_ANYINT :\n        F_AnyTypeClassToString := 'ANYINT';\n\n    IBaseLibrary.TypeClass.TYPE_ANYNUM :\n        F_AnyTypeClassToString := 'ANYNUM';\n\n    IBaseLibrary.TypeClass.TYPE_ANYREAL :\n        F_AnyTypeClassToString := 'ANYREAL';\n\n    IBaseLibrary.TypeClass.TYPE_LAZY :\n        F_AnyTypeClassToString := 'LAZY';\n\n    IBaseLibrary.TypeClass.TYPE_LTIME :\n        F_AnyTypeClassToString := 'LTIME';\n\n    IBaseLibrary.TypeClass.TYPE_BITCONST :\n        F_AnyTypeClassToString := 'BITCONST';\n\n    IBaseLibrary.TypeClass.TYPE_INTERFACE :\n        F_AnyTypeClassToString := 'INTERFACE';\n\n    ELSE\n        F_AnyTypeClassToString := 'UNKNOWN';\n\nEND_CASE\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.F_AnyTypeClassToString.AnyTypeClass","title":"AnyTypeClass  <code>__SYSTEM.TYPE_CLASS</code>","text":""},{"location":"reference/tcunit/#TcUnit.F_AssertionTypeToString","title":"F_AssertionTypeToString","text":"<p>Inputs</p> <ul> <li> <code>AssertionType</code> </li> </ul> Source Code <pre><code>(* Since TwinCAT 3.1.4024.x it's possible to do TO_STRING on enumerations,\n   but for backward compability we need to do it manually *)\nFUNCTION F_AssertionTypeToString : T_MaxString\nVAR_INPUT\n    AssertionType : E_AssertionType;\nEND_VAR\n</code></pre> <pre><code>CASE AssertionType OF\n    E_AssertionType.Type_UNDEFINED :\n        F_AssertionTypeToString := 'UNDEFINED';\n\n    E_AssertionType.Type_ANY :\n        F_AssertionTypeToString := 'ANY';\n\n    (* Primitive types *)\n    E_AssertionType.Type_BOOL :\n        F_AssertionTypeToString := 'BOOL';\n\n    E_AssertionType.Type_BYTE :\n        F_AssertionTypeToString := 'BYTE';\n\n    E_AssertionType.Type_DATE :\n        F_AssertionTypeToString := 'DATE';\n\n    E_AssertionType.Type_DATE_AND_TIME :\n        F_AssertionTypeToString := 'DATE_AND_TIME';\n\n    E_AssertionType.Type_DINT :\n        F_AssertionTypeToString := 'DINT';\n\n    E_AssertionType.Type_DWORD :\n        F_AssertionTypeToString := 'DWORD';\n\n    E_AssertionType.Type_INT :\n        F_AssertionTypeToString := 'INT';\n\n    E_AssertionType.Type_LINT :\n        F_AssertionTypeToString := 'LINT';\n\n    E_AssertionType.Type_LREAL :\n        F_AssertionTypeToString := 'LREAL';\n\n    E_AssertionType.Type_LTIME :\n        F_AssertionTypeToString := 'LTIME';\n\n    E_AssertionType.Type_LWORD :\n        F_AssertionTypeToString := 'LWORD';\n\n    E_AssertionType.Type_REAL :\n        F_AssertionTypeToString := 'REAL';\n\n    E_AssertionType.Type_SINT :\n        F_AssertionTypeToString := 'SINT';\n\n    E_AssertionType.Type_STRING :\n        F_AssertionTypeToString := 'STRING';\n\n    E_AssertionType.Type_TIME :\n        F_AssertionTypeToString := 'TIME';\n\n    E_AssertionType.Type_TIME_OF_DAY :\n        F_AssertionTypeToString := 'TIME_OF_DAY';\n\n    E_AssertionType.Type_UDINT :\n        F_AssertionTypeToString := 'UDINT';\n\n    E_AssertionType.Type_UINT :\n        F_AssertionTypeToString := 'UINT';\n\n    E_AssertionType.Type_ULINT :\n        F_AssertionTypeToString := 'ULINT';\n\n    E_AssertionType.Type_USINT :\n        F_AssertionTypeToString := 'USINT';\n\n    E_AssertionType.Type_WORD :\n        F_AssertionTypeToString := 'WORD';\n\n    E_AssertionType.Type_WSTRING :\n        F_AssertionTypeToString := 'WSTRING';\n\n\n    (* Array types *)\n    E_AssertionType.Type_Array2D_LREAL :\n        F_AssertionTypeToString := 'Array2D_LREAL';\n\n    E_AssertionType.Type_Array2D_REAL :\n        F_AssertionTypeToString := 'Array2D_REAL';\n\n    E_AssertionType.Type_Array3D_LREAL :\n        F_AssertionTypeToString := 'Array3D_LREAL';\n\n    E_AssertionType.Type_Array3D_REAL :\n        F_AssertionTypeToString := 'Array3D_REAL';\n\n    E_AssertionType.Type_Array_BOOL :\n        F_AssertionTypeToString := 'Array_BOOL';\n\n    E_AssertionType.Type_Array_BYTE :\n        F_AssertionTypeToString := 'Array_BYTE';\n\n    E_AssertionType.Type_Array_DINT :\n        F_AssertionTypeToString := 'Array_DINT';\n\n    E_AssertionType.Type_Array_DWORD :\n        F_AssertionTypeToString := 'Array_DWORD';\n\n    E_AssertionType.Type_Array_INT :\n        F_AssertionTypeToString := 'Array_INT';\n\n    E_AssertionType.Type_Array_LINT :\n        F_AssertionTypeToString := 'Array_LINT';\n\n    E_AssertionType.Type_Array_LREAL :\n        F_AssertionTypeToString := 'Array_LREAL';\n\n    E_AssertionType.Type_Array_LWORD :\n        F_AssertionTypeToString := 'Array_LWORD';\n\n    E_AssertionType.Type_Array_REAL :\n        F_AssertionTypeToString := 'Array_REAL';\n\n    E_AssertionType.Type_Array_SINT :\n        F_AssertionTypeToString := 'Array_SINT';\n\n    E_AssertionType.Type_Array_UDINT :\n        F_AssertionTypeToString := 'Array_UDINT';\n\n    E_AssertionType.Type_Array_UINT :\n        F_AssertionTypeToString := 'Array_UINT';\n\n    E_AssertionType.Type_Array_ULINT :\n        F_AssertionTypeToString := 'Array_ULINT';\n\n    E_AssertionType.Type_Array_USINT :\n        F_AssertionTypeToString := 'Array_USINT';\n\n    E_AssertionType.Type_Array_WORD :\n        F_AssertionTypeToString := 'Array_WORD';\n\n    ELSE\n        F_AssertionTypeToString := 'UNDEFINED';\n\nEND_CASE\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.F_AssertionTypeToString.AssertionType","title":"AssertionType  <code>E_AssertionType</code>","text":""},{"location":"reference/tcunit/#TcUnit.F_GetCpuCounterAs64bit","title":"F_GetCpuCounterAs64bit","text":"<p>In/Outputs</p> <ul> <li> <code>CpuCounter</code> </li> </ul> Source Code <pre><code>(* Calls the passed GETCPUCOUNTER function block and\n   converts the output of the GETCPUCOUNTER function block from 2x32bit variables to a\n   single 64bit variable\n*)\nFUNCTION F_GetCpuCounterAs64bit : LWORD\nVAR_IN_OUT CONSTANT\n    CpuCounter : GETCPUCOUNTER;\nEND_VAR\n</code></pre> <pre><code>CpuCounter();\nF_GetCpuCounterAs64bit := SHL(DWORD_TO_LWORD(CpuCounter.cpuCntHiDW), 32) + DWORD_TO_LWORD(CpuCounter.cpuCntLoDW);\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.F_GetCpuCounterAs64bit.CpuCounter","title":"CpuCounter  <code>GETCPUCOUNTER</code>","text":""},{"location":"reference/tcunit/#TcUnit.F_GetTestSuiteNameFromTestInstancePath","title":"F_GetTestSuiteNameFromTestInstancePath","text":"<p>Inputs</p> <ul> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>FUNCTION F_GetTestSuiteNameFromTestInstancePath : T_MaxString\nVAR_INPUT\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    TestSuiteName : T_MaxString;\n    FindPosition : INT;\nEND_VAR\n</code></pre> <pre><code>TestSuiteName := F_RemoveInstancePathAndProjectNameFromTestInstancePath(TestInstancePath := TestInstancePath);\n// Remove everything except the test suite name\nFindPosition := FIND(STR1 := TestSuiteName, '.');\nTestSuiteName := RIGHT(STR := TestSuiteName, SIZE := LEN(STR := TestSuiteName) - FindPosition);\nF_GetTestSuiteNameFromTestInstancePath := TestSuiteName;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.F_GetTestSuiteNameFromTestInstancePath.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.F_IsAnyEqualToUnionValue","title":"F_IsAnyEqualToUnionValue","text":"<p>Inputs</p> <ul> <li> <code>ExpectedOrActual</code> </li> <li> <code>ExpectedOrActualSize</code> </li> <li> <code>ExpectedOrActualTypeClass</code> </li> <li> <code>ExpectedOrActualValue</code> </li> </ul> Source Code <pre><code>FUNCTION F_IsAnyEqualToUnionValue : BOOL\nVAR_INPUT\n    ExpectedOrActual : U_ExpectedOrActual;\n    ExpectedOrActualSize : UDINT;\n    ExpectedOrActualTypeClass : IBaseLibrary.TypeClass;\n    ExpectedOrActualValue : POINTER TO BYTE;\nEND_VAR\nVAR\n    AnyExpectedOrActual : U_ExpectedOrActual;\nEND_VAR\n</code></pre> <pre><code>AnyExpectedOrActual := F_AnyToUnionValue(AnySize := ExpectedOrActualSize,\n                                         AnyTypeClass := ExpectedOrActualTypeClass,\n                                         AnyValue := ExpectedOrActualValue);\n\nCASE ExpectedOrActualTypeClass OF\n\n    IBaseLibrary.TypeClass.TYPE_BOOL :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.boolExpectedOrActual = AnyExpectedOrActual.boolExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_BIT :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.bitExpectedOrActual = AnyExpectedOrActual.bitExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_BYTE :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.byteExpectedOrActual = AnyExpectedOrActual.byteExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_WORD :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.wordExpectedOrActual = AnyExpectedOrActual.wordExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_DWORD :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.dwordExpectedOrActual = AnyExpectedOrActual.dwordExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_LWORD :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.lwordExpectedOrActual = AnyExpectedOrActual.lwordExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_SINT :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.sintExpectedOrActual = AnyExpectedOrActual.sintExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_INT :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.intExpectedOrActual = AnyExpectedOrActual.intExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_DINT :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.dintExpectedOrActual = AnyExpectedOrActual.dintExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_LINT :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.lintExpectedOrActual = AnyExpectedOrActual.lintExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_USINT :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.usintExpectedOrActual = AnyExpectedOrActual.usintExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_UINT :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.uintExpectedOrActual = AnyExpectedOrActual.uintExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_UDINT :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.udintExpectedOrActual = AnyExpectedOrActual.udintExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_ULINT :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.ulintExpectedOrActual = AnyExpectedOrActual.ulintExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_REAL :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.realExpectedOrActual = AnyExpectedOrActual.realExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_LREAL :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.lrealExpectedOrActual = AnyExpectedOrActual.lrealExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_STRING :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.stringExpectedOrActual = AnyExpectedOrActual.stringExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_WSTRING :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.wstringExpectedOrActual = AnyExpectedOrActual.wstringExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_TIME :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.timeExpectedOrActual = AnyExpectedOrActual.timeExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_DATE :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.dateExpectedOrActual = AnyExpectedOrActual.dateExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_DATEANDTIME :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.dateandtimeExpectedOrActual = AnyExpectedOrActual.dateandtimeExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_TIMEOFDAY :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.timeofdayExpectedOrActual = AnyExpectedOrActual.timeofdayExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_POINTER :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_REFERENCE :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_SUBRANGE :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_ENUM :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_ARRAY :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_PARAMS :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_USERDEF :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_NONE :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_ANY :\n        (* Even though the data input of the ExpectedOrActual is ANY, this CASE-switch will never\n           enter this case, but instead the type-class that it is an instance of. So for instance,\n           if the ExpectedOrActual is an instance of INT, this case-switch will enter the \n           IBaseLibrary.TypeClass.TYPE_INT case. *)\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_ANYBIT :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_ANYDATE :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_ANYINT :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_ANYNUM :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_ANYREAL :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_LAZY :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_LTIME :\n        F_IsAnyEqualToUnionValue := ExpectedOrActual.ltimeExpectedOrActual = AnyExpectedOrActual.ltimeExpectedOrActual;\n\n    IBaseLibrary.TypeClass.TYPE_BITCONST :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    IBaseLibrary.TypeClass.TYPE_INTERFACE :\n        F_IsAnyEqualToUnionValue := FALSE;\n\n    ELSE\n        F_IsAnyEqualToUnionValue := FALSE;\nEND_CASE\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.F_IsAnyEqualToUnionValue.ExpectedOrActual","title":"ExpectedOrActual  <code>U_ExpectedOrActual</code>","text":""},{"location":"reference/tcunit/#TcUnit.F_IsAnyEqualToUnionValue.ExpectedOrActualSize","title":"ExpectedOrActualSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.F_IsAnyEqualToUnionValue.ExpectedOrActualTypeClass","title":"ExpectedOrActualTypeClass  <code>IBaseLibrary.TypeClass</code>","text":""},{"location":"reference/tcunit/#TcUnit.F_IsAnyEqualToUnionValue.ExpectedOrActualValue","title":"ExpectedOrActualValue  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#TcUnit.F_RemoveInstancePathAndProjectNameFromTestInstancePath","title":"F_RemoveInstancePathAndProjectNameFromTestInstancePath","text":"<p>Inputs</p> <ul> <li> <code>TestInstancePath</code> </li> </ul> Source Code <pre><code>FUNCTION F_RemoveInstancePathAndProjectNameFromTestInstancePath : T_MaxString\nVAR_INPUT\n    TestInstancePath : T_MaxString;\nEND_VAR\nVAR\n    CharacterPositionOfProjectName : INT;\n    ProjectNameWithDot : T_MaxString;\nEND_VAR\n</code></pre> <pre><code>// Add the '.' character to the project name for search\nProjectNameWithDot := CONCAT(STR1 := TwinCAT_SystemInfoVarList._AppInfo.ProjectName, STR2 := '.');\n\n// Find the character position of the beginning of the first occurence of the project name\nCharacterPositionOfProjectName := FIND(STR1 := TestInstancePath, STR2 := ProjectNameWithDot);\n\nIF CharacterPositionOfProjectName &gt; 0 THEN\n    TestInstancePath := DELETE(STR := TestInstancePath,\n                               LEN := CharacterPositionOfProjectName-1 + LEN(ProjectNameWithDot),\n                               POS := 1);\nEND_IF\n\n// Check if the project name happens to be the same as namespace, and in that case, remove that as well\nCharacterPositionOfProjectName := FIND(STR1 := TestInstancePath,\n                                                    STR2 := ProjectNameWithDot);\n\nIF CharacterPositionOfProjectName &gt; 0 THEN\n    TestInstancePath := DELETE(STR := TestInstancePath,\n                               LEN := CharacterPositionOfProjectName - 1 +  LEN(STR := ProjectNameWithDot),\n                               POS := 1);\nEND_IF\n\nF_RemoveInstancePathAndProjectNameFromTestInstancePath := TestInstancePath;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.F_RemoveInstancePathAndProjectNameFromTestInstancePath.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.IS_TEST_FINISHED","title":"IS_TEST_FINISHED","text":"<p>Inputs</p> <ul> <li> <code>TestName</code> </li> </ul> Source Code <pre><code>// Check if a certain test in the current suite is finished\nFUNCTION IS_TEST_FINISHED : BOOL\nVAR_INPUT\n    TestName : T_MaxString;\nEND_VAR\nVAR\n    Counter : UINT;\n    CurrentTest : FB_Test;\nEND_VAR\n</code></pre> <pre><code>TestName := F_LTrim(in := F_RTrim(in := TestName));\n\nIS_TEST_FINISHED := FALSE;\n\nFOR Counter := 1 TO GVL_TcUnit.CurrentTestSuiteBeingCalled^.GetNumberOfTests() BY 1 DO\n    CurrentTest := GVL_TcUnit.CurrentTestSuiteBeingCalled^.Tests[Counter];\n    IF CurrentTest.TestName = TestName THEN\n        IS_TEST_FINISHED := CurrentTest.IsFinished();\n        RETURN;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.IS_TEST_FINISHED.TestName","title":"TestName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.RUN","title":"RUN","text":"Source Code <pre><code>(*\n    This function runs all test suites that have been initialized.\n    The test suites are run in parallel (all at once).\n*)\nFUNCTION RUN\n</code></pre> <pre><code>GVL_TcUnit.TcUnitRunner.RunTestSuiteTests();\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.RUN_IN_SEQUENCE","title":"RUN_IN_SEQUENCE","text":"Source Code <pre><code>(*\n    This function runs all test suites that have been initialized.\n    The test suites are run in sequence (one after the other).\n*)\nFUNCTION RUN_IN_SEQUENCE\n</code></pre> <pre><code>GVL_TcUnit.TcUnitRunner.RunTestSuiteTestsInSequence(TimeBetweenTestSuitesExecution := GVL_Param_TcUnit.TimeBetweenTestSuitesExecution);\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.TCUNIT_ADSLOGSTR","title":"TCUNIT_ADSLOGSTR","text":"<p>Inputs</p> <ul> <li> <code>msgCtrlMask</code>             \u2013              <p>Message control mask</p> </li> <li> <code>msgFmtStr</code>             \u2013              <p>Message format string</p> </li> <li> <code>strArg</code>             \u2013              <p>STRING argument</p> </li> </ul> Source Code <pre><code>(* This function allows to put ADS strings into the TcUnit ADS message buffer. If ADSLOGSTR() is used directly,\n   the messages can come out of sequence in relation to the message created by TcUnit as TcUnit buffers the messages to\n   not overflow the ADS message router. By using this function, the ADS-messages are put in the same buffer as\n   TcUnit is using for its output and thus the sequence will be correct *)\nFUNCTION TCUNIT_ADSLOGSTR\nVAR_INPUT\n    msgCtrlMask : DWORD; // Message control mask\n    msgFmtStr : T_MaxString; // Message format string\n    strArg : T_MaxString; // STRING argument\nEND_VAR\n</code></pre> <pre><code>GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := msgCtrlMask,\n                                    MsgFmtStr := msgFmtStr,\n                                    StrArg := strArg);\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.TCUNIT_ADSLOGSTR.msgCtrlMask","title":"msgCtrlMask  <code>DWORD</code>","text":"<p>Message control mask</p>"},{"location":"reference/tcunit/#TcUnit.TCUNIT_ADSLOGSTR.msgFmtStr","title":"msgFmtStr  <code>T_MaxString</code>","text":"<p>Message format string</p>"},{"location":"reference/tcunit/#TcUnit.TCUNIT_ADSLOGSTR.strArg","title":"strArg  <code>T_MaxString</code>","text":"<p>STRING argument</p>"},{"location":"reference/tcunit/#TcUnit.TEST","title":"TEST","text":"<p>Inputs</p> <ul> <li> <code>TestName</code> </li> </ul> Source Code <pre><code>// This function declares a new test (if it has not been already declared in an earlier cycle)\nFUNCTION TEST\nVAR_INPUT\n    TestName : T_MaxString;\nEND_VAR\nVAR\n    CounterTestSuiteAddress : UINT;\n    Test : REFERENCE TO FB_Test;\nEND_VAR\n</code></pre> <pre><code>TestName := F_LTrim(in := F_RTrim(in := TestName));\n\n// Mark this test as the current one being executed\nGVL_TcUnit.CurrentTestNameBeingCalled := TestName;\n\n(* Check if combination of address for the test suite and test name already exists.\n   For every test suite the name of the test case needs to be unique.\n   If a test with this name already exists, don't add it to the available tests.\n   Otherwise, add it to the available tests *)\n\nFOR CounterTestSuiteAddress := 1 TO GVL_TcUnit.NumberOfInitializedTestSuites BY 1 DO\n    // Look for the test suite by comparing to the one that is currently running\n    IF GVL_TcUnit.TestSuiteAddresses[CounterTestSuiteAddress] = GVL_TcUnit.CurrentTestSuiteBeingCalled THEN\n        Test REF= GVL_TcUnit.TestSuiteAddresses[CounterTestSuiteAddress]^.AddTest(TestName := TestName, IsTestOrdered := FALSE);\n        GVL_TcUnit.CurrentTestIsFinished := GVL_TcUnit.TestSuiteAddresses[CounterTestSuiteAddress]^.IsTestFinished(TestName := TestName);\n        IF __ISVALIDREF(Test) THEN\n\t\t\tTest.SetStartedAtIfNotSet(Timestamp := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter));\n        END_IF\n        RETURN;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.TEST.TestName","title":"TestName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.TEST_FINISHED","title":"TEST_FINISHED","text":"Source Code <pre><code>// Sets the currently running test as finished\nFUNCTION TEST_FINISHED : BOOL\nVAR\n    TestName : T_MaxString;\n    Counter : UINT := 0;\n    FinishedAt : LWORD;\nEND_VAR\n</code></pre> <pre><code>// Get the timestamp directly when the test has finished\nFinishedAt := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter);\n\n// Grab the currently running test name\nTestName := GVL_TcUnit.CurrentTestNameBeingCalled;\n\nTEST_FINISHED := FALSE;\n(* Find the test suite and:\n   1. Set the test in that test suite as finished\n   2. Calculate and set the number of asserts made for that test\n*)\nFOR Counter := 1 TO GVL_TcUnit.NumberOfInitializedTestSuites BY 1 DO\n    IF GVL_TcUnit.TestSuiteAddresses[Counter] = GVL_TcUnit.CurrentTestSuiteBeingCalled THEN\n        GVL_TcUnit.TestSuiteAddresses[Counter]^.SetTestFinished(TestName := GVL_TcUnit.CurrentTestNameBeingCalled, FinishedAt := FinishedAt);\n        GVL_TcUnit.TestSuiteAddresses[Counter]^.CalculateAndSetNumberOfAssertsForTest(TestName := GVL_TcUnit.CurrentTestNameBeingCalled);\n        GVL_TcUnit.CurrentTestIsFinished := TRUE;\n        TEST_FINISHED := TRUE;\n        RETURN;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.TEST_FINISHED_NAMED","title":"TEST_FINISHED_NAMED","text":"<p>Inputs</p> <ul> <li> <code>TestName</code> </li> </ul> Source Code <pre><code>(* Sets a test defined by TestName as finished. Note that the TestName-input must match\n   a TestName that has been previously defined in this test suite. *)\nFUNCTION TEST_FINISHED_NAMED\nVAR_INPUT\n    TestName : T_MaxString;\nEND_VAR\nVAR\n    Counter : UINT := 0;\n    FoundTestName : BOOL := FALSE;\n    FinishedAt : LWORD; // cpu cycle counter in 100ns precision\nEND_VAR\nVAR_STAT\n    FailedLookupCounter : UINT := 0;\n    AlreadyPrintedFinalWarning : BOOL := FALSE;\nEND_VAR\nVAR CONSTANT\n    MaxNumberOfNonExistentTestNamesFailedLookups : UINT := 3;\nEND_VAR\n</code></pre> <pre><code>TestName := F_LTrim(in := F_RTrim(in := TestName));\nFinishedAt := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter);\n\n(* Find the test suite and:\n   1. Set the test in that test suite as finished\n   2. Calculate and set the number of asserts made for that test\n*)\nFOR Counter := 1 TO GVL_TcUnit.NumberOfInitializedTestSuites BY 1 DO\n    IF GVL_TcUnit.TestSuiteAddresses[Counter] = GVL_TcUnit.CurrentTestSuiteBeingCalled THEN\n        FoundTestName := GVL_TcUnit.TestSuiteAddresses[Counter]^.SetTestFinished(TestName := TestName, FinishedAt := FinishedAt);\n        IF NOT FoundTestName THEN\n            IF FailedLookupCounter &lt; MaxNumberOfNonExistentTestNamesFailedLookups THEN\n                GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                                    MsgFmtStr := 'Failed to find test $'%s$'',\n                                                    StrArg := TestName);\n                FailedLookupCounter := FailedLookupCounter + 1;\n                (* Abort TcUnit *)\n                GVL_TcUnit.TcUnitRunner.AbortRunningTestSuiteTests();\n            ELSIF NOT AlreadyPrintedFinalWarning THEN\n                GVL_TcUnit.AdsMessageQueue.WriteLog(MsgCtrlMask := ADSLOG_MSGTYPE_ERROR,\n                                                    MsgFmtStr := 'Excess failed attempts to mark test finished, failed. Further warnings will be suppressed',\n                                                    StrArg := TestName);\n                AlreadyPrintedFinalWarning := TRUE;\n            END_IF\n        ELSE\n            GVL_TcUnit.TestSuiteAddresses[Counter]^.CalculateAndSetNumberOfAssertsForTest(TestName := TestName);\n            GVL_TcUnit.CurrentTestIsFinished := TRUE;\n        END_IF\n        RETURN;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.TEST_FINISHED_NAMED.TestName","title":"TestName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.TEST_ORDERED","title":"TEST_ORDERED","text":"<p>Inputs</p> <ul> <li> <code>TestName</code> </li> </ul> Source Code <pre><code>(* This function declares a new ordered test (if it has not been already declared in an earlier cycle).\n   The test declared by this function will run in the order it is called, so if we have two tests:\n   TEST_ORDERED('Test_1')\n   TEST_ORDERED('Test_2')\n   All asserts of Test_2 will be ignored until Test_1 is declared with TEST_FINISHED().\n\n   The function returns TRUE if it's time to run this test (and thus asserts can be made)\n   The function returns FALSE if it's not time to run this test (because a previous test has not been finished)\n   If the function returns FALSE (and it's thus not time to run the test), any eventual asserts done for this \n   test will be ignored. It thus makes sense to call this function in a manner like:\n\n    IF TEST_ORDERED('Testname') THEN\n        fbFunctionBlockUnderTest();\n\n        AssertEquals(Expected := 'SomeValue',\n                     Actual := fbFunctionBlockUnderTest.Out,\n                     Message := 'Test failed');\n        TEST_FINISHED();\n    END_IF\n\n*)\nFUNCTION TEST_ORDERED : BOOL\nVAR_INPUT\n    TestName : T_MaxString;\nEND_VAR\nVAR\n    CounterTestSuiteAddress : UINT;\n    Test : REFERENCE TO FB_Test;\nEND_VAR\n</code></pre> <pre><code>TestName := F_LTrim(in := F_RTrim(in := TestName));\n\n// Mark this test as the current one being executed\nGVL_TcUnit.CurrentTestNameBeingCalled := TestName;\n\n(* Check if combination of address for the test suite and test name already exists.\n   For every test suite the name of the test case needs to be unique.\n   If a test with this name already exists, don't add it to the available tests.\n   Otherwise, add it to the available tests *)\n\nFOR CounterTestSuiteAddress := 1 TO GVL_TcUnit.NumberOfInitializedTestSuites BY 1 DO\n\n    // Look for the test suite by comparing to the one that is currently running\n    IF GVL_TcUnit.TestSuiteAddresses[CounterTestSuiteAddress] = GVL_TcUnit.CurrentTestSuiteBeingCalled THEN\n        Test REF= GVL_TcUnit.TestSuiteAddresses[CounterTestSuiteAddress]^.AddTest(TestName := TestName, IsTestOrdered := TRUE);\n        GVL_TcUnit.CurrentTestIsFinished := GVL_TcUnit.TestSuiteAddresses[CounterTestSuiteAddress]^.IsTestFinished(TestName := TestName);\n\n        // Check that no previous code has set the currently running test to ignored (for example by setting the test to DISABLED\n        IF NOT GVL_TcUnit.IgnoreCurrentTest THEN\n            (* If the current test is not the current in the sequence of tests, set it to ignored until it is its turn to run\n               If the current test is the one supposed to be run, check whether it has finished running or not *)\n            IF GVL_TcUnit.TestSuiteAddresses[CounterTestSuiteAddress]^.GetTestOrderNumber(TestName := TestName) =\n                GVL_TcUnit.CurrentlyRunningOrderedTestInTestSuite[CounterTestSuiteAddress] THEN\n                // Check if test if finished, if so, increase the order number of this test suite to the next test\n                IF GVL_TcUnit.CurrentTestIsFinished THEN\n                    GVL_TcUnit.CurrentlyRunningOrderedTestInTestSuite[CounterTestSuiteAddress] := GVL_TcUnit.CurrentlyRunningOrderedTestInTestSuite[CounterTestSuiteAddress] + 1;\n                    // No need to execute the test if it is already finished\n                    TEST_ORDERED := FALSE;\n                    GVL_TcUnit.IgnoreCurrentTest := TRUE;\n                ELSE\n                    // Start or continue executing test\n                    IF __ISVALIDREF(Test) THEN\n                        Test.SetStartedAtIfNotSet(Timestamp := F_GetCpuCounterAs64bit(GVL_TcUnit.GetCpuCounter));\n                    END_IF\n                    TEST_ORDERED := TRUE;\n                END_IF\n            ELSE\n                // If this is not the current test that we are supposed to run, ignore it until it is its turn\n                TEST_ORDERED := FALSE;\n                GVL_TcUnit.IgnoreCurrentTest := TRUE;\n\t\t\tEND_IF\n        // This test should be ignored\n        ELSE\n            TEST_ORDERED := FALSE;\n            GVL_TcUnit.IgnoreCurrentTest := TRUE;\n\t\tEND_IF\n        RETURN;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.TEST_ORDERED.TestName","title":"TestName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_BOOL","title":"WRITE_PROTECTED_BOOL","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_BOOL\nVAR_INPUT\n    Ptr : POINTER TO BOOL;\n    Value : BOOL;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_BOOL.Ptr","title":"Ptr  <code>POINTER TO BOOL</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_BOOL.Value","title":"Value  <code>BOOL</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_BYTE","title":"WRITE_PROTECTED_BYTE","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_BYTE\nVAR_INPUT\n    Ptr : POINTER TO BYTE;\n    Value : BYTE;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_BYTE.Ptr","title":"Ptr  <code>POINTER TO BYTE</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_BYTE.Value","title":"Value  <code>BYTE</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DATE","title":"WRITE_PROTECTED_DATE","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_DATE\nVAR_INPUT\n    Ptr : POINTER TO DATE;\n    Value : DATE;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DATE.Ptr","title":"Ptr  <code>POINTER TO DATE</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DATE.Value","title":"Value  <code>DATE</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DATE_AND_TIME","title":"WRITE_PROTECTED_DATE_AND_TIME","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_DATE_AND_TIME\nVAR_INPUT\n    Ptr : POINTER TO DATE_AND_TIME;\n    Value : DATE_AND_TIME;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DATE_AND_TIME.Ptr","title":"Ptr  <code>POINTER TO DATE_AND_TIME</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DATE_AND_TIME.Value","title":"Value  <code>DATE_AND_TIME</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DINT","title":"WRITE_PROTECTED_DINT","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_DINT\nVAR_INPUT\n    Ptr : POINTER TO DINT;\n    Value : DINT;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DINT.Ptr","title":"Ptr  <code>POINTER TO DINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DINT.Value","title":"Value  <code>DINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DWORD","title":"WRITE_PROTECTED_DWORD","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_DWORD\nVAR_INPUT\n    Ptr : POINTER TO DWORD;\n    Value : DWORD;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DWORD.Ptr","title":"Ptr  <code>POINTER TO DWORD</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_DWORD.Value","title":"Value  <code>DWORD</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_INT","title":"WRITE_PROTECTED_INT","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_INT\nVAR_INPUT\n    Ptr : POINTER TO INT;\n    Value : INT;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_INT.Ptr","title":"Ptr  <code>POINTER TO INT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_INT.Value","title":"Value  <code>INT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_LREAL","title":"WRITE_PROTECTED_LREAL","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_LREAL\nVAR_INPUT\n    Ptr : POINTER TO LREAL;\n    Value : LREAL;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_LREAL.Ptr","title":"Ptr  <code>POINTER TO LREAL</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_LREAL.Value","title":"Value  <code>LREAL</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_REAL","title":"WRITE_PROTECTED_REAL","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_REAL\nVAR_INPUT\n    Ptr : POINTER TO REAL;\n    Value : REAL;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_REAL.Ptr","title":"Ptr  <code>POINTER TO REAL</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_REAL.Value","title":"Value  <code>REAL</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_SINT","title":"WRITE_PROTECTED_SINT","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_SINT\nVAR_INPUT\n    Ptr : POINTER TO SINT;\n    Value : SINT;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_SINT.Ptr","title":"Ptr  <code>POINTER TO SINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_SINT.Value","title":"Value  <code>SINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_STRING","title":"WRITE_PROTECTED_STRING","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_STRING\nVAR_INPUT\n    Ptr : POINTER TO STRING;\n    Value : STRING;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_STRING.Ptr","title":"Ptr  <code>POINTER TO STRING</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_STRING.Value","title":"Value  <code>STRING</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_WSTRING","title":"WRITE_PROTECTED_WSTRING","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_WSTRING\nVAR_INPUT\n    Ptr : POINTER TO WSTRING;\n    Value : WSTRING;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_WSTRING.Ptr","title":"Ptr  <code>POINTER TO WSTRING</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_WSTRING.Value","title":"Value  <code>WSTRING</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_TIME","title":"WRITE_PROTECTED_TIME","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_TIME\nVAR_INPUT\n    Ptr : POINTER TO TIME;\n    Value : TIME;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_TIME.Ptr","title":"Ptr  <code>POINTER TO TIME</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_TIME.Value","title":"Value  <code>TIME</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_TIME_OF_DAY","title":"WRITE_PROTECTED_TIME_OF_DAY","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_TIME_OF_DAY\nVAR_INPUT\n    Ptr : POINTER TO TIME_OF_DAY;\n    Value : TIME_OF_DAY;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_TIME_OF_DAY.Ptr","title":"Ptr  <code>POINTER TO TIME_OF_DAY</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_TIME_OF_DAY.Value","title":"Value  <code>TIME_OF_DAY</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_UDINT","title":"WRITE_PROTECTED_UDINT","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_UDINT\nVAR_INPUT\n    Ptr : POINTER TO UDINT;\n    Value : UDINT;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_UDINT.Ptr","title":"Ptr  <code>POINTER TO UDINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_UDINT.Value","title":"Value  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_UINT","title":"WRITE_PROTECTED_UINT","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_UINT\nVAR_INPUT\n    Ptr : POINTER TO UINT;\n    Value : UINT;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_UINT.Ptr","title":"Ptr  <code>POINTER TO UINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_UINT.Value","title":"Value  <code>UINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_ULINT","title":"WRITE_PROTECTED_ULINT","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_ULINT\nVAR_INPUT\n    Ptr : POINTER TO ULINT;\n    Value : ULINT;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_ULINT.Ptr","title":"Ptr  <code>POINTER TO ULINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_ULINT.Value","title":"Value  <code>ULINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_LWORD","title":"WRITE_PROTECTED_LWORD","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_LWORD\nVAR_INPUT\n    Ptr : POINTER TO LWORD;\n    Value : LWORD;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_LWORD.Ptr","title":"Ptr  <code>POINTER TO LWORD</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_LWORD.Value","title":"Value  <code>LWORD</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_LINT","title":"WRITE_PROTECTED_LINT","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_LINT\nVAR_INPUT\n    Ptr : POINTER TO LINT;\n    Value : LINT;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_LINT.Ptr","title":"Ptr  <code>POINTER TO LINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_LINT.Value","title":"Value  <code>LINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_USINT","title":"WRITE_PROTECTED_USINT","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_USINT\nVAR_INPUT\n    Ptr : POINTER TO USINT;\n    Value : USINT;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_USINT.Ptr","title":"Ptr  <code>POINTER TO USINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_USINT.Value","title":"Value  <code>USINT</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_WORD","title":"WRITE_PROTECTED_WORD","text":"<p>Inputs</p> <ul> <li> <code>Ptr</code> </li> <li> <code>Value</code> </li> </ul> Source Code <pre><code>FUNCTION WRITE_PROTECTED_WORD\nVAR_INPUT\n    Ptr : POINTER TO WORD;\n    Value : WORD;\nEND_VAR\n</code></pre> <pre><code>Ptr^ := Value;\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_WORD.Ptr","title":"Ptr  <code>POINTER TO WORD</code>","text":""},{"location":"reference/tcunit/#TcUnit.WRITE_PROTECTED_WORD.Value","title":"Value  <code>WORD</code>","text":""},{"location":"reference/tcunit/#TcUnit.E_AssertionType","title":"E_AssertionType","text":"Source Code <pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_AssertionType :\n(\n    Type_UNDEFINED := 0,\n    Type_ANY,\n\n    // Primitive types\n    Type_BOOL,\n    Type_BYTE,\n    Type_DATE,\n    Type_DATE_AND_TIME,\n    Type_DINT,\n    Type_DWORD,\n    Type_INT,\n    Type_LINT,\n    Type_LREAL,\n    Type_LTIME,\n    Type_LWORD,\n    Type_REAL,\n    Type_SINT,\n    Type_STRING,\n    Type_TIME,\n    Type_TIME_OF_DAY,\n    Type_UDINT,\n    Type_UINT,\n    Type_ULINT,\n    Type_USINT,\n    Type_WORD,\n    Type_WSTRING,\n\n    // Array types\n    Type_Array2D_LREAL,\n    Type_Array2D_REAL,\n    Type_Array3D_LREAL,\n    Type_Array3D_REAL,\n    Type_Array_BOOL,\n    Type_Array_BYTE,\n    Type_Array_DINT,\n    Type_Array_DWORD,\n    Type_Array_INT,\n    Type_Array_LINT,\n    Type_Array_LREAL,\n    Type_Array_LWORD,\n    Type_Array_REAL,\n    Type_Array_SINT,\n    Type_Array_UDINT,\n    Type_Array_UINT,\n    Type_Array_ULINT,\n    Type_Array_USINT,\n    Type_Array_WORD\n) BYTE;\nEND_TYPE\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.E_XmlError","title":"E_XmlError","text":"Source Code <pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_XmlError :\n(\n    Ok := 0,\n    ErrorMaxBufferLen := 1,\n    ErrorStringLen := 2,\n    Error := 3\n) BYTE;\nEND_TYPE\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.ST_AdsLogStringMessage","title":"ST_AdsLogStringMessage","text":"Source Code <pre><code>{attribute 'pack_mode' := '1'}\nTYPE ST_AdsLogStringMessage :\nSTRUCT\n\tMsgCtrlMask : DWORD;\n    MsgFmtStr : T_MaxString;\n    StrArg : T_MaxString;\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"reference/tcunit/#ST_AdsLogStringMessage.MsgCtrlMask","title":"MsgCtrlMask  <code>DWORD</code>","text":""},{"location":"reference/tcunit/#ST_AdsLogStringMessage.MsgFmtStr","title":"MsgFmtStr  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#ST_AdsLogStringMessage.StrArg","title":"StrArg  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.ST_AssertResult","title":"ST_AssertResult","text":"Source Code <pre><code>TYPE ST_AssertResult :\nSTRUCT\n    Expected : U_ExpectedOrActual;\n    Actual : U_ExpectedOrActual;\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"reference/tcunit/#ST_AssertResult.Expected","title":"Expected  <code>U_ExpectedOrActual</code>","text":""},{"location":"reference/tcunit/#ST_AssertResult.Actual","title":"Actual  <code>U_ExpectedOrActual</code>","text":""},{"location":"reference/tcunit/#ST_AssertResult.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#ST_AssertResult.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.ST_AssertResultInstances","title":"ST_AssertResultInstances","text":"Source Code <pre><code>TYPE ST_AssertResultInstances :\nSTRUCT\n    AssertResult : ST_AssertResult;\n    DetectionCount : UINT; // Number of instances of the \"AssertResult\"\n    DetectionCountThisCycle : UINT; // Number of instance of the \"AssertResult\" in this specific PLC-cycle\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"reference/tcunit/#ST_AssertResultInstances.AssertResult","title":"AssertResult  <code>ST_AssertResult</code>","text":""},{"location":"reference/tcunit/#ST_AssertResultInstances.DetectionCount","title":"DetectionCount  <code>UINT</code>","text":"<p>Number of instances of the \"AssertResult\"</p>"},{"location":"reference/tcunit/#ST_AssertResultInstances.DetectionCountThisCycle","title":"DetectionCountThisCycle  <code>UINT</code>","text":"<p>Number of instance of the \"AssertResult\" in this specific PLC-cycle</p>"},{"location":"reference/tcunit/#TcUnit.ST_AssertArrayResult","title":"ST_AssertArrayResult","text":"Source Code <pre><code>TYPE ST_AssertArrayResult :\nSTRUCT\n    ExpectedsSize : UDINT; // Size in bytes of the expecteds-array\n    ExpectedsTypeClass : IBaseLibrary.TypeClass; // The data type of the expecteds-array\n    ActualsSize : UDINT; // Size in bytes of the actuals-array\n    ActualsTypeClass : IBaseLibrary.TypeClass; // The data type of the actuals-array\n    Message : T_MaxString;\n    TestInstancePath : T_MaxString;\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"reference/tcunit/#ST_AssertArrayResult.ExpectedsSize","title":"ExpectedsSize  <code>UDINT</code>","text":"<p>Size in bytes of the expecteds-array</p>"},{"location":"reference/tcunit/#ST_AssertArrayResult.ExpectedsTypeClass","title":"ExpectedsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":"<p>The data type of the expecteds-array</p>"},{"location":"reference/tcunit/#ST_AssertArrayResult.ActualsSize","title":"ActualsSize  <code>UDINT</code>","text":"<p>Size in bytes of the actuals-array</p>"},{"location":"reference/tcunit/#ST_AssertArrayResult.ActualsTypeClass","title":"ActualsTypeClass  <code>IBaseLibrary.TypeClass</code>","text":"<p>The data type of the actuals-array</p>"},{"location":"reference/tcunit/#ST_AssertArrayResult.Message","title":"Message  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#ST_AssertArrayResult.TestInstancePath","title":"TestInstancePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#TcUnit.ST_AssertArrayResultInstances","title":"ST_AssertArrayResultInstances","text":"Source Code <pre><code>TYPE ST_AssertArrayResultInstances :\nSTRUCT\n    AssertArrayResult : ST_AssertArrayResult;\n    DetectionCount : UINT; // Number of instances of the \"AssertArrayResult\"\n    DetectionCountThisCycle : UINT; // Number of instance of the \"AssertArrayResult\" in this specific PLC-cycle\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"reference/tcunit/#ST_AssertArrayResultInstances.AssertArrayResult","title":"AssertArrayResult  <code>ST_AssertArrayResult</code>","text":""},{"location":"reference/tcunit/#ST_AssertArrayResultInstances.DetectionCount","title":"DetectionCount  <code>UINT</code>","text":"<p>Number of instances of the \"AssertArrayResult\"</p>"},{"location":"reference/tcunit/#ST_AssertArrayResultInstances.DetectionCountThisCycle","title":"DetectionCountThisCycle  <code>UINT</code>","text":"<p>Number of instance of the \"AssertArrayResult\" in this specific PLC-cycle</p>"},{"location":"reference/tcunit/#TcUnit.ST_TestCaseResult","title":"ST_TestCaseResult","text":"Source Code <pre><code>TYPE ST_TestCaseResult :\nSTRUCT\n    TestName : T_MaxString;\n    TestClassName : T_MaxString;\n    TestIsFailed : BOOL;\n    TestIsSkipped : BOOL;\n    FailureMessage : T_MaxString;\n    FailureType : E_AssertionType;\n    NumberOfAsserts : UINT;\n    Duration : LREAL; // in seconds\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"reference/tcunit/#ST_TestCaseResult.TestName","title":"TestName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#ST_TestCaseResult.TestClassName","title":"TestClassName  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#ST_TestCaseResult.TestIsFailed","title":"TestIsFailed  <code>BOOL</code>","text":""},{"location":"reference/tcunit/#ST_TestCaseResult.TestIsSkipped","title":"TestIsSkipped  <code>BOOL</code>","text":""},{"location":"reference/tcunit/#ST_TestCaseResult.FailureMessage","title":"FailureMessage  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#ST_TestCaseResult.FailureType","title":"FailureType  <code>E_AssertionType</code>","text":""},{"location":"reference/tcunit/#ST_TestCaseResult.NumberOfAsserts","title":"NumberOfAsserts  <code>UINT</code>","text":""},{"location":"reference/tcunit/#ST_TestCaseResult.Duration","title":"Duration  <code>LREAL</code>","text":"<p>in seconds</p>"},{"location":"reference/tcunit/#TcUnit.ST_TestSuiteResult","title":"ST_TestSuiteResult","text":"Source Code <pre><code>TYPE ST_TestSuiteResult :\nSTRUCT\n    Name : T_MaxString; // Full class name\n    Identity : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestSuites); // Should be 0..GVL_Param_TcUnit.MaxNumberOfTestSuites-1 but gives unknown compiler error\n    NumberOfTests : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\n    NumberOfFailedTests : UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\n    Duration : LREAL; // In seconds\n    TestCaseResults : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite] OF ST_TestCaseResult;\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"reference/tcunit/#ST_TestSuiteResult.Name","title":"Name  <code>T_MaxString</code>","text":"<p>Full class name</p>"},{"location":"reference/tcunit/#ST_TestSuiteResult.Identity","title":"Identity  <code>UINT(0..GVL_Param_TcUnit.MaxNumberOfTestSuites)</code>","text":"<p>Should be 0..GVL_Param_TcUnit.MaxNumberOfTestSuites-1 but gives unknown compiler error</p>"},{"location":"reference/tcunit/#ST_TestSuiteResult.NumberOfTests","title":"NumberOfTests  <code>UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite)</code>","text":""},{"location":"reference/tcunit/#ST_TestSuiteResult.NumberOfFailedTests","title":"NumberOfFailedTests  <code>UINT(0..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite)</code>","text":""},{"location":"reference/tcunit/#ST_TestSuiteResult.Duration","title":"Duration  <code>LREAL</code>","text":"<p>In seconds</p>"},{"location":"reference/tcunit/#ST_TestSuiteResult.TestCaseResults","title":"TestCaseResults  <code>ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite] OF ST_TestCaseResult</code>","text":""},{"location":"reference/tcunit/#TcUnit.ST_TestSuiteResults","title":"ST_TestSuiteResults","text":"Source Code <pre><code>TYPE ST_TestSuiteResults :\nSTRUCT\n    // General test results\n    NumberOfTestSuites : UINT; // The total number of test suites\n    NumberOfTestCases : UINT; // The total number of test cases (for all test suites)\n    NumberOfSuccessfulTestCases : UINT; // The total number of test cases that had all ASSERTS successful\n    NumberOfFailedTestCases : UINT; // The total number of test cases that had at least one ASSERT failed\n    Duration : LREAL; // Duration it took for all test suites to finish, in seconds\n\n    // Test results for each individiual test suite\n    TestSuiteResults : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestSuites] OF ST_TestSuiteResult;\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"reference/tcunit/#ST_TestSuiteResults.NumberOfTestSuites","title":"NumberOfTestSuites  <code>UINT</code>","text":"<p>The total number of test suites</p>"},{"location":"reference/tcunit/#ST_TestSuiteResults.NumberOfTestCases","title":"NumberOfTestCases  <code>UINT</code>","text":"<p>The total number of test cases (for all test suites)</p>"},{"location":"reference/tcunit/#ST_TestSuiteResults.NumberOfSuccessfulTestCases","title":"NumberOfSuccessfulTestCases  <code>UINT</code>","text":"<p>The total number of test cases that had all ASSERTS successful</p>"},{"location":"reference/tcunit/#ST_TestSuiteResults.NumberOfFailedTestCases","title":"NumberOfFailedTestCases  <code>UINT</code>","text":"<p>The total number of test cases that had at least one ASSERT failed</p>"},{"location":"reference/tcunit/#ST_TestSuiteResults.Duration","title":"Duration  <code>LREAL</code>","text":"<p>Duration it took for all test suites to finish, in seconds</p>"},{"location":"reference/tcunit/#ST_TestSuiteResults.TestSuiteResults","title":"TestSuiteResults  <code>ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestSuites] OF ST_TestSuiteResult</code>","text":""},{"location":"reference/tcunit/#TcUnit.U_ExpectedOrActual","title":"U_ExpectedOrActual","text":"Source Code <pre><code>TYPE U_ExpectedOrActual :\nUNION\n    boolExpectedOrActual : BOOL;\n    bitExpectedOrActual : BIT;\n    byteExpectedOrActual : BYTE;\n    dwordExpectedOrActual : DWORD;\n    lwordExpectedOrActual : LWORD;\n    stringExpectedOrActual : T_MaxString;\n    udintExpectedOrActual : UDINT;\n    uintExpectedOrActual : UINT;\n    usintExpectedOrActual : USINT;\n    sintExpectedOrActual : SINT;\n    intExpectedOrActual : INT;\n    wordExpectedOrActual : WORD;\n    dintExpectedOrActual : DINT;\n    lintExpectedOrActual : LINT;\n    ulintExpectedOrActual : ULINT;\n    realExpectedOrActual : REAL;\n    lrealExpectedOrActual : LREAL;\n    wstringExpectedOrActual : WSTRING(255);\n    timeExpectedOrActual : TIME;\n    ltimeExpectedOrActual : LTIME;\n    dateExpectedOrActual : DATE;\n    dateandtimeExpectedOrActual : DATE_AND_TIME;\n    timeofdayExpectedOrActual : TIME_OF_DAY;\nEND_UNION\nEND_TYPE\n</code></pre>"},{"location":"reference/tcunit/#TcUnit.GVL_Param_TcUnit","title":"GVL_Param_TcUnit","text":"Source Code <pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n    MaxNumberOfTestSuites : UINT := 1000;\n    MaxNumberOfTestsForEachTestSuite : UINT := 100;\n    MaxNumberOfAssertsForEachTestSuite : UINT := 1000;\n\n    (* TcUnit logs complete test results. These include:\n         - Number of test suites\n         - Number of tests\n         - Number of successful tests\n         - Number of failed tests\n         - Any eventual failed assertion (with the expected &amp; actual value plus an user defined message)\n       These are all printed to the ADS logger (Visual Studio error list) marked with ERROR criticality\n\n       On top of this TcUnit also reports some statistics/extended information with HINT/INFO criticality.\n       These statistics are more detailed results of the tests. This information is used when results are\n       being collected by an external software (such as TcUnit-Runner) to do for example Jenkins integration.\n       This extra information however takes time to print, so by setting the following parameter to FALSE\n       it will speed up TcUnit finishing. *)\n    LogExtendedResults : BOOL := TRUE;\n\n    (* Enable (TRUE) or disable (FALSE) publishing of the xUnit Xml report *)\n    xUnitEnablePublish : BOOL := FALSE;\n\n    (* Default reserved PLC memory buffer used for composition of the xUnit xml file (64 kb default) *)\n    xUnitBufferSize : UDINT := 65535;\n\n    (* Default path and filename for the xunit testresults e.g.: for use with jenkins \n\n\t   Use environment variables for a OS independent file path\n\t   - %TC_BOOTPRJPATH% -&gt; 'C:\\TwinCAT\\3.1\\Boot\\' (Windows), '/usr/local/etc/TwinCAT/3.1/Boot/' (TC/BSD), '\\Hard Disk\\TwinCAT\\3.1\\Boot\\' (Windows CE)\n      - %TC_INSTALLPATH% -&gt; 'C:\\TwinCAT\\3.1\\' (Windows), '/usr/local/etc/TwinCAT/3.1/' (TC/BSD), '\\Hard Disk\\TwinCAT\\3.1\\' (Windows CE) *)\n    xUnitFilePath : T_MaxString := '%TC_BOOTPRJPATH%tcunit_xunit_testresults.xml';\n\n    (* This is the maximum number of ADS-messages that can be stored for reporting at the same time.\n       Having a size of 2000 means that it's possible to report up to ~400 test cases in one single\n       PLC cycle. Each entry consumes around 500 bytes, so with an example of a ring buffer size of\n       2000 it means that TcUnit will consume around 1 MB of router memory. *) \n    AdsLogMessageFifoRingBufferSize : UINT := 2000;\n\n    (* Time delay between a test suite is finished and the execution of the next test suite starts\n       if using RUN_IN_SEQUENCE() *)\n    TimeBetweenTestSuitesExecution : TIME := T#0MS;\nEND_VAR\n</code></pre>"},{"location":"reference/tcunit/#GVL_Param_TcUnit.MaxNumberOfTestSuites","title":"MaxNumberOfTestSuites  <code>UINT</code>","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite","title":"MaxNumberOfTestsForEachTestSuite  <code>UINT</code>","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.MaxNumberOfAssertsForEachTestSuite","title":"MaxNumberOfAssertsForEachTestSuite  <code>UINT</code>","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.(* TcUnit logs complete test results. These include","title":"(* TcUnit logs complete test results. These include","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.LogExtendedResults","title":"LogExtendedResults  <code>BOOL</code>","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.xUnitEnablePublish","title":"xUnitEnablePublish  <code>BOOL</code>","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.xUnitBufferSize","title":"xUnitBufferSize  <code>UDINT</code>","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.(* Default path and filename for the xunit testresults e.g.","title":"(* Default path and filename for the xunit testresults e.g.  <code>for use with jenkins</code>","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.- %TC_BOOTPRJPATH% -> 'C","title":"- %TC_BOOTPRJPATH% -&gt; 'C  <code>\\TwinCAT\\3.1\\Boot\\' (Windows), '/usr/local/etc/TwinCAT/3.1/Boot/' (TC/BSD), '\\Hard Disk\\TwinCAT\\3.1\\Boot\\' (Windows CE)</code>","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.- %TC_INSTALLPATH% -> 'C","title":"- %TC_INSTALLPATH% -&gt; 'C  <code>\\TwinCAT\\3.1\\' (Windows), '/usr/local/etc/TwinCAT/3.1/' (TC/BSD), '\\Hard Disk\\TwinCAT\\3.1\\' (Windows CE) *)</code>","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.xUnitFilePath","title":"xUnitFilePath  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.AdsLogMessageFifoRingBufferSize","title":"AdsLogMessageFifoRingBufferSize  <code>UINT</code>","text":""},{"location":"reference/tcunit/#GVL_Param_TcUnit.TimeBetweenTestSuitesExecution","title":"TimeBetweenTestSuitesExecution  <code>TIME</code>","text":""},{"location":"reference/tcunit/#TcUnit.GVL_TcUnit","title":"GVL_TcUnit","text":"Source Code <pre><code>{attribute 'no_assign'}\n{attribute 'qualified_only'}\nVAR_GLOBAL\n    TcUnitRunner : FB_TcUnitRunner;\n\n    (* Indication of whether the last instantiated test suite has an assert instance created *)\n    TestSuiteIsRegistered : BOOL;\n\n    (* Pointer to current test suite being called *)\n    CurrentTestSuiteBeingCalled : POINTER TO FB_TestSuite;\n\n    (* Current name of test being called *)\n    CurrentTestNameBeingCalled : T_MaxString;\n\n    (* Used to get the current cpu cycle counter to calculate the duration of tests and test suits, respectively *)\n    GetCpuCounter : GETCPUCOUNTER;\n\n    (* Stores the CPU cycle count with 100ns precision since the first entry into one of the Run methods (RUN, RUN_IN_SEQUENCE) *)\n    StartedAt : LWORD;\n\n    (* Duration it took for a complete run, in seconds *)\n    Duration : LREAL;\n\n    (* Whether or not the current test being called has finished running *)\n    CurrentTestIsFinished : BOOL;\n\n    (* This is a flag that indicates that the current test should be ignored, and\n       thus that all assertions under it should be ignored as well. A test can be ignored either\n       because the user has requested so, or because the test is a duplicate name *)\n    IgnoreCurrentTest : BOOL;\n\n    (* The assert function block instance should be 1:1 mapped to\n       the test suite instance path. *)\n    NumberOfInitializedTestSuites : UINT := 0;\n    TestSuiteAddresses : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestSuites] OF POINTER TO FB_TestSuite;\n\n    (* If the user is utilizing the TEST_ORDERED(), we need to keep track of which ordered test is currently running.\n       We do this by defining an array, in where we can see which current TEST_ORDERED() is the one to be handled right now.\n       The below array is only used for TEST_ORDERED()-tests.  *)\n    CurrentlyRunningOrderedTestInTestSuite : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestSuites] OF UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite);\n\n    (* Buffered ADS message queue for output to the error list *)\n    AdsMessageQueue : FB_AdsLogStringMessageFifoQueue;\nEND_VAR\nVAR_GLOBAL CONSTANT\n  (* Multiply a value that is given in 100ns units by this value to\n     convert the value to seconds *)\n  HundredNanosecondToSecond : LREAL := 1.0 / 10000000.0;\nEND_VAR\n</code></pre>"},{"location":"reference/tcunit/#GVL_TcUnit.TcUnitRunner","title":"TcUnitRunner  <code>FB_TcUnitRunner</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.TestSuiteIsRegistered","title":"TestSuiteIsRegistered  <code>BOOL</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.CurrentTestSuiteBeingCalled","title":"CurrentTestSuiteBeingCalled  <code>POINTER TO FB_TestSuite</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.CurrentTestNameBeingCalled","title":"CurrentTestNameBeingCalled  <code>T_MaxString</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.GetCpuCounter","title":"GetCpuCounter  <code>GETCPUCOUNTER</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.StartedAt","title":"StartedAt  <code>LWORD</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.Duration","title":"Duration  <code>LREAL</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.CurrentTestIsFinished","title":"CurrentTestIsFinished  <code>BOOL</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.IgnoreCurrentTest","title":"IgnoreCurrentTest  <code>BOOL</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.(* The assert function block instance should be 1","title":"(* The assert function block instance should be 1  <code>1 mapped to</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.NumberOfInitializedTestSuites","title":"NumberOfInitializedTestSuites  <code>UINT</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.TestSuiteAddresses","title":"TestSuiteAddresses  <code>ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestSuites] OF POINTER TO FB_TestSuite</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.CurrentlyRunningOrderedTestInTestSuite","title":"CurrentlyRunningOrderedTestInTestSuite  <code>ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestSuites] OF UINT(1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite)</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.AdsMessageQueue","title":"AdsMessageQueue  <code>FB_AdsLogStringMessageFifoQueue</code>","text":""},{"location":"reference/tcunit/#GVL_TcUnit.HundredNanosecondToSecond","title":"HundredNanosecondToSecond  <code>LREAL</code>","text":""},{"location":"reference/tcunit/#TcUnit.Global_Version","title":"Global_Version","text":"Source Code <pre><code>{attribute 'TcGenerated'}\n{attribute 'no-analysis'}\n{attribute 'linkalways'}\n// This function has been automatically generated from the project information.\nVAR_GLOBAL CONSTANT\n\t{attribute 'const_non_replaced'}\n\tstLibVersion_TcUnit : ST_LibVersion := (iMajor := 1, iMinor := 3, iBuild := 2, iRevision := 0, nFlags := 0, sVersion := '1.3.2');\nEND_VAR\n</code></pre>"},{"location":"reference/tcunit/#Global_Version.stLibVersion_TcUnit","title":"stLibVersion_TcUnit  <code>ST_LibVersion</code>","text":""},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#installation","title":"Installation","text":"pyproject.toml<pre><code># PEP 621 dependencies declaration\n# adapt to your dependencies manager\n[project]\ndependencies = [\n    \"mkdocstrings-twincat\",\n]\n</code></pre> <p>If you just use the twincat handler you can set it to default</p> mkdocs.yml<pre><code>plugins:\n- mkdocstrings:\n    default_handler: twincat\n</code></pre>"},{"location":"usage/#injecting-documentation","title":"Injecting documentation","text":"<p>With the Twincat handler installed and configured as default handler, you can inject documentation for a plc project, functionblock, gvl, itf,...</p> <pre><code>::: path.to.object\n</code></pre> <p>If another handler was defined as default handler, you can explicitely ask for the Twincat handler to be used when injecting documentation with the <code>handler</code> option:</p> <pre><code>::: path.to.object\n    handler: twincat\n</code></pre>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>You can configure the twincat handler in <code>mkdocs.yml</code>:</p> mkdocs.yml<pre><code>plugins:\n- mkdocstrings:\n    handlers:\n      twincat:\n        ...  # the twincat handler configuration\n</code></pre>"},{"location":"usage/#global-only-options","title":"Global-only options","text":"<p>Some options are global only, and go directly under the handler's name.</p> <p></p>"},{"location":"usage/#paths","title":"<code>paths</code>","text":"<p>This option is used to provide filesystem paths in which to search for a twincat file. it is important that you specify a file, not a folder. It is currently not supported to load a whole folder. </p> mkdocs.yml<pre><code>plugins:\n- mkdocstrings:\n    handlers:\n      twincat:\n        paths: [twincatproject\\TcUnit.plcproj]\n</code></pre> <p></p>"},{"location":"usage/#globallocal-options","title":"Global/local options","text":"<p>The other options can be used both globally and locally, under the <code>options</code> key. For example, globally:</p> mkdocs.yml<pre><code>plugins:\n- mkdocstrings:\n    handlers:\n      twincat:\n        options:\n          do_something: true\n</code></pre> <p>...and locally, overriding the global configuration:</p> docs/some_page.md<pre><code>::: package.module.class\n    options:\n      do_something: false\n</code></pre> <p>These options affect how the documentation is collected from sources and rendered. See the following tables summarizing the options, and get more details for each option in the following pages:</p> <ul> <li>General options: various options that do not fit in the other categories</li> <li>Headings options: options related to headings and the table of contents     (or sidebar, depending on the theme used)</li> <li>Documentation options: options related to documentation</li> </ul>"},{"location":"usage/customization/","title":"Customization","text":"<p>It is possible to customize the output of the generated documentation with CSS and/or by overriding templates.</p>"},{"location":"usage/customization/#css-classes","title":"CSS classes","text":"<p>Our templates add CSS classes to many HTML elements to make it possible for users to customize the resulting look and feel.</p> <p>To add CSS rules and style mkdocstrings' output, put them in a CSS file in your docs folder, for example in <code>docs/css/mkdocstrings.css</code>, and reference this file in MkDocs' <code>extra_css</code> configuration option:</p> mkdocs.yml<pre><code>extra_css:\n- css/mkdocstrings.css\n</code></pre> <p>Example:</p> docs/css/mkdocstrings.css<pre><code>.doc-section-title {\n  font-weight: bold;\n}\n</code></pre>"},{"location":"usage/customization/#symbol-types","title":"Symbol types","text":""},{"location":"usage/customization/#colors","title":"Colors","text":"<p>You can customize the colors of the symbol types (see <code>show_symbol_type_heading</code> and <code>show_symbol_type_toc</code>) by overriding the values of our CSS variables, for example:</p> docs/css/mkdocstrings.css<pre><code>[data-md-color-scheme=\"default\"] {\n  --doc-symbol-data-fg-color: #d1b619;\n\n  --doc-symbol-data-bg-color: #d1b6191a;\n}\n\n[data-md-color-scheme=\"slate\"] {\n  --doc-symbol-data-fg-color: #46c2cb;\n\n  --doc-symbol-data-bg-color: #46c2cb1a;\n}\n</code></pre> <p>The <code>[data-md-color-scheme=\"*\"]</code> selectors work with the [Material for MkDocs] theme. If you are using another theme, adapt the selectors to this theme if it supports light and dark themes, otherwise just override the variables at root level:</p> docs/css/mkdocstrings.css<pre><code>:root {\n  --doc-symbol-data-fg-color: #d1b619;\n\n  --doc-symbol-data-bg-color: #d1b6191a;\n}\n</code></pre> <p>Preview</p> <p>     Try cycling through the themes to see the colors for each theme:     <code></code>"},{"location":"usage/customization/#names","title":"Names","text":"<p>You can also change the actual symbol names. For example, to use single letters instead of truncated types:</p> docs/css/mkdocstrings.css<pre><code>.doc-symbol-data::after {\n  content: \"D\";\n}\n</code></pre> <p>Preview</p> <ul> <li>Data: <code></code></li> </ul>"},{"location":"usage/customization/#templates","title":"Templates","text":"<p>Templates are organized into the following tree:</p> <pre><code>\ud83d\udcc1 theme/\n\u251c\u2500\u2500 \ud83d\udcc4 children.html.jinja\n\u251c\u2500\u2500 \ud83d\udcc4 documentation.html.jinja\n\u251c\u2500\u2500 \ud83d\udcc4 dut.html.jinja\n\u251c\u2500\u2500 \ud83d\udcc4 gvl.html.jinja\n\u251c\u2500\u2500 \ud83d\udcc4 itf.html.jinja\n\u251c\u2500\u2500 \ud83d\udcc4 labels.html.jinja\n\u251c\u2500\u2500 \ud83d\udcc4 method.html.jinja\n\u251c\u2500\u2500 \ud83d\udcc4 plcproject.html.jinja\n\u251c\u2500\u2500 \ud83d\udcc4 pou.html.jinja\n\u251c\u2500\u2500 \ud83d\udcc4 property.html.jinja\n\u251c\u2500\u2500 \ud83d\udcc1 summary/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 duts.html.jinja\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 gvls.html.jinja\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 itfs.html.jinja\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 methods.html.jinja\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 pous.html.jinja\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 properties.html.jinja\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 variables.html.jinja\n\u251c\u2500\u2500 \ud83d\udcc4 summary.html.jinja\n\u2514\u2500\u2500 \ud83d\udcc4 variable.html.jinja\n</code></pre> <p>See them in the repository. See the general mkdocstrings documentation to learn how to override them: https://mkdocstrings.github.io/theming/#templates.</p> <p>Each one of these templates extends a base version in <code>theme/_base</code>. Example:</p> theme/data.html.jinja<pre><code>{% extends \"_base/data.html.jinja\" %}\n</code></pre> <p>Some of these templates define Jinja blocks. allowing to customize only parts of a template without having to fully copy-paste it into your project:</p> templates/theme/data.html<pre><code>{% extends \"_base/data.html\" %}\n{% block contents scoped %}\n  {{ block.super }}\n  Additional contents\n{% endblock contents %}\n</code></pre>"},{"location":"usage/configuration/","title":"Configuration","text":""},{"location":"usage/configuration/#globallocal-options","title":"Global/local options","text":"<p>The other options can be used both globally and locally, under the <code>options</code> key. For example, globally:</p> mkdocs.yml<pre><code>plugins:\n- mkdocstrings:\n    handlers:\n      python:\n        options:\n          do_something: true\n</code></pre> <p>...and locally, overriding the global configuration:</p> docs/some_page.md<pre><code>::: package.module.class\n    options:\n      do_something: false\n</code></pre> <p>These options affect how the documentation is collected from sources and rendered. See the following tables summarizing the options, and get more details for each option in the following pages:</p> <ul> <li>General options: various options that do not fit in the other categories</li> <li>Headings options: options related to headings and the table of contents     (or sidebar, depending on the theme used)</li> </ul>"},{"location":"usage/configuration/documentation/","title":"Documentation","text":""},{"location":"usage/configuration/documentation/#guidelines-in-a-twincatproject","title":"Guidelines in a Twincatproject","text":"<p>Only tags between the fb name and the first var block are parsed Multiline is possible Usage can be rendered to show as code</p> <p>Only in, out, and in/out variable blocks are rendered. internal blocks are not rendered.</p> <pre><code>    FUNCTION_BLOCK FB_AdjustAssertFailureMessageToMax253CharLength\n    //\n    //@details This FunctionBlock does this and that.\n    //@usage use the functionblock like that. here is an example: FB_AdjustAssert.....\n    //@returns makes no sense at a fb. can be used at a method\n    //\n    //@tag1 there can be custom tags written. they will be rendered after the standard tags above\n    //@tag3 another tag\n    //\n    //\n    VAR_INPUT\n        TestInstancePath : T_MaxString; // everything that goes behind here is parsed as a detail of the variable\n        TestMessage : T_MaxString; // another detail\n    END_VAR\n    VAR_OUTPUT\n        TestInstancePathProcessed : T_MaxString;\n        TestMessageProcessed : T_MaxString;\n    END_VAR\n    VAR_TEMP\n        TestInstancePathTemporary : T_MaxString;\n    END_VAR\n    VAR CONSTANT\n        MESSAGE_FORMATTED_STRING_MAX_NUMBER_OF_CHARACTERS : INT := 253; // This is actually 254, but if StrArg-argument is used (which it is in TcUnit) it is 253.\n        TEST_NAME_TOO_LONG : STRING := '...TestName too long';\n        TEST_MESSAGE_TOO_LONG : STRING := '...TestMsg too long';\n    END_VAR\n</code></pre>"},{"location":"usage/configuration/general/","title":"General options","text":""},{"location":"usage/configuration/general/#extra","title":"<code>extra</code>","text":"<ul> <li> Type <code>dict</code> <code>{}</code></li> </ul> <p>The <code>extra</code> option lets you inject additional variables into the Jinja context used when rendering templates. You can then use this extra context in your overridden templates.</p> <p>Local <code>extra</code> options will be merged into the global <code>extra</code> option:</p> in mkdocs.yml (global configuration)<pre><code>plugins:\n- mkdocstrings:\n    handlers:\n      twincat:\n        options:\n          extra:\n            hello: world\n</code></pre> in docs/some_page.md (local configuration)<pre><code>::: your_package.your_module.your_func\n    options:\n      extra:\n        foo: bar\n</code></pre> <p>...will inject both <code>hello</code> and <code>foo</code> into the Jinja context when rendering <code>your_package.your_module.your_func</code>.</p>"},{"location":"usage/configuration/headings/","title":"Headings options","text":""},{"location":"usage/configuration/headings/#heading","title":"<code>heading</code>","text":"<ul> <li> Type <code>str</code> <code>\"\"</code></li> </ul> <p>A custom string to use as the heading of the root object (i.e. the object specified directly after the identifier <code>:::</code>). This will override the default heading generated by the plugin. See also the <code>toc_label</code> option.</p> <p>Not advised to be used as a global configuration option</p> <p> This option is not advised to be used as a global configuration option, as it will override the default heading for all objects. It is recommended to use it only in specific cases where you want to override the heading for a specific object.</p> in docs/some_page.md (local configuration)<pre><code>::: path.to.module\n    options:\n      heading: \"My fancy module\"\n</code></pre> <p></p>"},{"location":"usage/configuration/headings/#heading_level","title":"<code>heading_level</code>","text":"<ul> <li> Type <code>int</code> <code>2</code></li> </ul> <p>The initial heading level to use.</p> <p>When injecting documentation for an object, the object itself and its members are rendered. For each layer of objects, we increase the heading level by 1.</p> <p>The initial heading level will be used for the first layer. If you set it to 3, then headings will start with <code>&lt;h3&gt;</code>.</p> in mkdocs.yml (global configuration)<pre><code>plugins:\n- mkdocstrings:\n    handlers:\n      twincat:\n        options:\n          heading_level: 2\n</code></pre> or in docs/some_page.md (local configuration)<pre><code>::: path.to.module\n    options:\n      heading_level: 3\n</code></pre> <p>Preview</p> With level 3 and root headingWith level 3, without root heading <code>module</code> (3) <p>Docstring of the module.</p> <code>ClassA</code> (4) <p>Docstring of class A.</p> <code>ClassB</code> (4) <p>Docstring of class B.</p> <code>method_1</code> (5) <p>Docstring of the method.</p> <p>Docstring of the module.</p> <code>ClassA</code> (3) <p>Docstring of class A.</p> <code>ClassB</code> (3) <p>Docstring of class B.</p> <code>method_1</code> (4) <p>Docstring of the method.</p> <p></p>"},{"location":"usage/configuration/headings/#show_symbol_type_heading","title":"<code>show_symbol_type_heading</code><code></code> <code>attribute</code><code></code> <code>function</code><code></code> <code>Class</code><code>attribute</code><code>function</code><code>Class</code>","text":"<ul> <li> Type <code>bool</code> <code>False</code></li> </ul> <p>Show the symbol type in headings.</p> <p>This option will prefix headings with <code></code>, <code></code>, <code></code>, <code></code> or <code></code> types. See also <code>show_symbol_type_toc</code>.</p> <p>To customize symbols, see Customizing symbol types.</p> in mkdocs.yml (global configuration)<pre><code>plugins:\n- mkdocstrings:\n    handlers:\n      twincat:\n        options:\n          show_symbol_type_heading: true\n</code></pre> or in docs/some_page.md (local configuration)<pre><code>::: package.module\n    options:\n      show_symbol_type_heading: false\n</code></pre> <p>Preview</p> With symbol type in headingsWithout symbol type in headings <code></code> <code>module</code> <p>Docstring of the module.</p> <p>Docstring of the module attribute.</p> <p>Docstring of the function.</p> <p>Docstring of the class.</p> <code></code> <code>method</code> <p>Docstring of the method.</p> <code>module</code> <p>Docstring of the module.</p> <p>Docstring of the module attribute.</p> <p>Docstring of the function.</p> <p>Docstring of the class.</p> <code>method</code> <p>Docstring of the method.</p> <p></p>"},{"location":"usage/configuration/headings/#show_symbol_type_toc","title":"<code>show_symbol_type_toc</code>","text":"<ul> <li> Type <code>bool</code> <code>False</code></li> </ul> <p>Show the symbol type in the Table of Contents.</p> <p>This option will prefix items in the ToC with <code></code>, <code></code>, <code></code>, <code></code> or <code></code> types. See also <code>show_symbol_type_heading</code>.</p> <p>To customize symbols, see Customizing symbol types.</p> in mkdocs.yml (global configuration)<pre><code>plugins:\n- mkdocstrings:\n    handlers:\n      twincat:\n        options:\n          show_symbol_type_toc: true\n</code></pre> or in docs/some_page.md (local configuration)<pre><code>::: package.module\n    options:\n      show_symbol_type_toc: false\n</code></pre> <p>Preview</p> With symbol type in ToCWithout symbol type in ToC <ul> <li><code></code> module</li> <li><code></code> attribute</li> <li><code></code> function</li> <li><code></code> Class     <ul> <li><code></code> method</li> </ul> </li> </ul> <ul> <li>module</li> <li>attribute</li> <li>function</li> <li>Class     <ul> <li>method</li> </ul> </li> </ul> <p></p>"},{"location":"usage/configuration/headings/#toc_label","title":"<code>toc_label</code>","text":"<ul> <li> Type <code>str</code> <code>\"\"</code></li> </ul> <p>A custom string to use as the label in the Table of Contents for the root object (i.e. the one specified directly after the identifier <code>:::</code>). This will override the default label generated by the plugin. See also the <code>heading</code> option.</p> <p>Not advised to be used as a global configuration option</p> <p> This option is not advised to be used as a global configuration option, as it will override the default label for all objects. It is recommended to use it only in specific cases where you want to override the label for a specific object.</p> <p>Use with/without <code>heading</code></p> <p> If you use this option without specifying a custom <code>heading</code>, the default heading will be used in the page, but the label in the Table of Contents will be the one you specified. By providing both an option for <code>heading</code> and <code>toc_label</code>, we leave the customization entirely up to you.</p> in docs/some_page.md (local configuration)<pre><code>::: path.to.module\n    options:\n      heading: \"My fancy module\"\n      toc_label: \"My fancy module\"\n</code></pre>"}]}